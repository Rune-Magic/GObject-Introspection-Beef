/* Auto generated by https://github.com/Rune-Magic/C2Beef-Binding-Generator
 * DO NOT EDIT
 */

using System;
using System.Interop;

namespace GObject.Introspection;

static
{
	public const let GI_MAJOR_VERSION = 1;
	public const let GI_MINOR_VERSION = 84;
	public const let GI_MICRO_VERSION = 0;
}

[CRepr] struct GIBaseInfoStub
{
	public gint32 dummy1;
	public gint32 dummy2;
	public gpointer dummy3;
	public gpointer dummy4;
	public gpointer dummy5;
	public guint32 dummy6;
	public guint32 dummy7;
	public gpointer[4] padding;
}

typealias GIBaseInfo = GIBaseInfoStub;
struct GICallableInfo : GIBaseInfo;
struct GIFunctionInfo : GIBaseInfo;
struct GICallbackInfo : GIBaseInfo;
struct GIRegisteredTypeInfo : GIBaseInfo;
struct GIStructInfo : GIBaseInfo;
struct GIUnionInfo : GIBaseInfo;
struct GIEnumInfo : GIBaseInfo;
struct GIObjectInfo : GIBaseInfo;
struct GIInterfaceInfo : GIBaseInfo;
struct GIConstantInfo : GIBaseInfo;
struct GIValueInfo : GIBaseInfo;
struct GISignalInfo : GIBaseInfo;
struct GIVFuncInfo : GIBaseInfo;
struct GIPropertyInfo : GIBaseInfo;
struct GIFieldInfo : GIBaseInfo;
struct GIArgInfo : GIBaseInfo;
struct GITypeInfo : GIBaseInfo;

struct GIUnresolvedInfo;

[Union, CRepr] struct GIArgument
{
	public gboolean v_boolean;
	public gint8 v_int8;
	public guint8 v_uint8;
	public gint16 v_int16;
	public guint16 v_uint16;
	public gint32 v_int32;
	public guint32 v_uint32;
	public gint64 v_int64;
	public guint64 v_uint64;
	public gfloat v_float;
	public gdouble v_double;
	public gshort v_short;
	public gushort v_ushort;
	public gint v_int;
	public guint v_uint;
	public glong v_long;
	public gulong v_ulong;
	public gssize v_ssize;
	public gsize v_size;
	public gchar* v_string;
	public gpointer v_pointer;
}

/** GIInfoType:
 *   @GI _INFO_TYPE_INVALID: invalid type
 *   @GI _INFO_TYPE_FUNCTION: function, see #GIFunctionInfo
 *   @GI _INFO_TYPE_CALLBACK: callback, see #GIFunctionInfo
 *   @GI _INFO_TYPE_STRUCT: struct, see #GIStructInfo
 *   @GI _INFO_TYPE_BOXED: boxed, see #GIStructInfo or #GIUnionInfo
 *   @GI _INFO_TYPE_ENUM: enum, see #GIEnumInfo
 *   @GI _INFO_TYPE_FLAGS: flags, see #GIEnumInfo
 *   @GI _INFO_TYPE_OBJECT: object, see #GIObjectInfo
 *   @GI _INFO_TYPE_INTERFACE: interface, see #GIInterfaceInfo
 *   @GI _INFO_TYPE_CONSTANT: contant, see #GIConstantInfo
 *   @GI _INFO_TYPE_INVALID_0: deleted, used to be GI_INFO_TYPE_ERROR_DOMAIN.
 *   @GI _INFO_TYPE_UNION: union, see #GIUnionInfo
 *   @GI _INFO_TYPE_VALUE: enum value, see #GIValueInfo
 *   @GI _INFO_TYPE_SIGNAL: signal, see #GISignalInfo
 *   @GI _INFO_TYPE_VFUNC: virtual function, see #GIVFuncInfo
 *   @GI _INFO_TYPE_PROPERTY: GObject property, see #GIPropertyInfo
 *   @GI _INFO_TYPE_FIELD: struct or union field, see #GIFieldInfo
 *   @GI _INFO_TYPE_ARG: argument of a function or callback, see #GIArgInfo
 *   @GI _INFO_TYPE_TYPE: type information, see #GITypeInfo
 *   @GI _INFO_TYPE_UNRESOLVED: unresolved type, a type which is not present in
 *  the typelib, or any of its dependencies.
 *  
 *  The type of a GIBaseInfo struct.
 */
[AllowDuplicates] enum GIInfoType : c_int
{
	Invalid = 0,
	Function = 1,
	Callback = 2,
	Struct = 3,
	Boxed = 4,
	Enum = 5,
	Flags = 6,
	Object = 7,
	Interface = 8,
	Constant = 9,
	Invalid0 = 10,
	Union = 11,
	Value = 12,
	Signal = 13,
	Vfunc = 14,
	Property = 15,
	Field = 16,
	Arg = 17,
	Type = 18,
	Unresolved = 19,
}

/** GITransfer:
 *   @GI _TRANSFER_NOTHING: transfer nothing from the callee (function or the type
 *  instance the property belongs to) to the caller. The callee retains the
 *  ownership of the transfer and the caller doesn't need to do anything to free
 *  up the resources of this transfer.
 *   @GI _TRANSFER_CONTAINER: transfer the container (list, array, hash table) from
 *  the callee to the caller. The callee retains the ownership of the individual
 *  items in the container and the caller has to free up the container resources
 *  (g_list_free()/g_hash_table_destroy() etc) of this transfer.
 *   @GI _TRANSFER_EVERYTHING: transfer everything, eg the container and its
 *  contents from the callee to the caller. This is the case when the callee
 *  creates a copy of all the data it returns. The caller is responsible for
 *  cleaning up the container and item resources of this transfer.
 *  
 *  The transfer is the exchange of data between two parts, from the callee to
 *  the caller. The callee is either a function/method/signal or an
 *  object/interface where a property is defined. The caller is the side
 *  accessing a property or calling a function.
 *  #GITransfer specifies who's responsible for freeing the resources after the
 *  ownership transfer is complete. In case of a containing type such as a list,
 *  an array or a hash table the container itself is specified differently from
 *  the items within the container itself. Each container is freed differently,
 *  check the documentation for the types themselves for information on how to
 *  free them.
 */
[AllowDuplicates] enum GITransfer : c_int
{
	Nothing = 0,
	Container = 1,
	Everything = 2,
}

/** GIDirection:
 *   @GI _DIRECTION_IN: in argument.
 *   @GI _DIRECTION_OUT: out argument.
 *   @GI _DIRECTION_INOUT: in and out argument.
 *  
 *  The direction of a #GIArgInfo.
 */
[AllowDuplicates] enum GIDirection : c_int
{
	In = 0,
	Out = 1,
	Inout = 2,
}

/** GIScopeType:
 *   @GI _SCOPE_TYPE_INVALID: The argument is not of callback type.
 *   @GI _SCOPE_TYPE_CALL: The callback and associated user_data is only
 *  used during the call to this function.
 *   @GI _SCOPE_TYPE_ASYNC: The callback and associated user_data is
 *  only used until the callback is invoked, and the callback.
 *  is invoked always exactly once.
 *   @GI _SCOPE_TYPE_NOTIFIED: The callback and associated
 *  user_data is used until the caller is notfied via the destroy_notify.
 *   @GI _SCOPE_TYPE_FOREVER: The callback and associated user_data is
 *  used until the process terminates
 *  
 *  Scope type of a #GIArgInfo representing callback, determines how the
 *  callback is invoked and is used to decided when the invoke structs
 *  can be freed.
 */
[AllowDuplicates] enum GIScopeType : c_int
{
	Invalid = 0,
	Call = 1,
	Async = 2,
	Notified = 3,
	Forever = 4,
}

/** GITypeTag:
 *   @GI _TYPE_TAG_VOID: void
 *   @GI _TYPE_TAG_BOOLEAN: boolean
 *   @GI _TYPE_TAG_INT8: 8-bit signed integer
 *   @GI _TYPE_TAG_UINT8: 8-bit unsigned integer
 *   @GI _TYPE_TAG_INT16: 16-bit signed integer
 *   @GI _TYPE_TAG_UINT16: 16-bit unsigned integer
 *   @GI _TYPE_TAG_INT32: 32-bit signed integer
 *   @GI _TYPE_TAG_UINT32: 32-bit unsigned integer
 *   @GI _TYPE_TAG_INT64: 64-bit signed integer
 *   @GI _TYPE_TAG_UINT64: 64-bit unsigned integer
 *   @GI _TYPE_TAG_FLOAT: float
 *   @GI _TYPE_TAG_DOUBLE: double floating point
 *   @GI _TYPE_TAG_GTYPE: a #GType
 *   @GI _TYPE_TAG_UTF8: a UTF-8 encoded string
 *   @GI _TYPE_TAG_FILENAME: a filename, encoded in the same encoding
 *  as the native filesystem is using.
 *   @GI _TYPE_TAG_ARRAY: an array
 *   @GI _TYPE_TAG_INTERFACE: an extended interface object
 *   @GI _TYPE_TAG_GLIST: a #GList
 *   @GI _TYPE_TAG_GSLIST: a #GSList
 *   @GI _TYPE_TAG_GHASH: a #GHashTable
 *   @GI _TYPE_TAG_ERROR: a #GError
 *   @GI _TYPE_TAG_UNICHAR: Unicode character
 *  
 *  The type tag of a #GITypeInfo.
 */
[AllowDuplicates] enum GITypeTag : c_int
{
	Void = 0,
	Boolean = 1,
	Int8 = 2,
	Uint8 = 3,
	Int16 = 4,
	Uint16 = 5,
	Int32 = 6,
	Uint32 = 7,
	Int64 = 8,
	Uint64 = 9,
	Float = 10,
	Double = 11,
	Gtype = 12,
	Utf8 = 13,
	Filename = 14,
	Array = 15,
	Interface = 16,
	Glist = 17,
	Gslist = 18,
	Ghash = 19,
	Error = 20,
	Unichar = 21,
}

/** GIArrayType:
 *   @GI _ARRAY_TYPE_C: a C array, char[] for instance
 *   @GI _ARRAY_TYPE_ARRAY: a @GArray array
 *   @GI _ARRAY_TYPE_PTR_ARRAY: a #GPtrArray array
 *   @GI _ARRAY_TYPE_BYTE_ARRAY: a #GByteArray array
 *  
 *  The type of array in a #GITypeInfo.
 */
[AllowDuplicates] enum GIArrayType : c_int
{
	C = 0,
	Array = 1,
	PtrArray = 2,
	ByteArray = 3,
}

/** GIFieldInfoFlags:
 *   @GI _FIELD_IS_READABLE: field is readable.
 *   @GI _FIELD_IS_WRITABLE: field is writable.
 *  
 *  Flags for a #GIFieldInfo.
 */
[AllowDuplicates] enum GIFieldInfoFlags : c_int
{
	SReadable = 1 << 0,
	SWritable = 1 << 1,
}

/** GIVFuncInfoFlags:
 *   @GI _VFUNC_MUST_CHAIN_UP: chains up to the parent type
 *   @GI _VFUNC_MUST_OVERRIDE: overrides
 *   @GI _VFUNC_MUST_NOT_OVERRIDE: does not override
 *   @GI _VFUNC_THROWS: Includes a #GError
 *  
 *  Flags of a #GIVFuncInfo struct.
 */
[AllowDuplicates] enum GIVFuncInfoFlags : c_int
{
	MustChainUp = 1 << 0,
	MustOverride = 1 << 1,
	MustNotOverride = 1 << 2,
	Throws = 1 << 3,
}

/** GIFunctionInfoFlags:
 *   @GI _FUNCTION_IS_METHOD: is a method.
 *   @GI _FUNCTION_IS_CONSTRUCTOR: is a constructor.
 *   @GI _FUNCTION_IS_GETTER: is a getter of a #GIPropertyInfo.
 *   @GI _FUNCTION_IS_SETTER: is a setter of a #GIPropertyInfo.
 *   @GI _FUNCTION_WRAPS_VFUNC: represents a virtual function.
 *   @GI _FUNCTION_THROWS: the function may throw an error.
 *  
 *  Flags for a #GIFunctionInfo struct.
 */
[AllowDuplicates] enum GIFunctionInfoFlags : c_int
{
	SMethod = 1 << 0,
	SConstructor = 1 << 1,
	SGetter = 1 << 2,
	SSetter = 1 << 3,
	WrapsVfunc = 1 << 4,
	Throws = 1 << 5,
}

typealias GArgument = GIArgument;

struct GITypelib;
typealias GTypelib = GITypelib;

extension GIR
{
	[LinkName("g_arg_info_get_direction")] public static extern GIDirection GArgInfoGetDirection(GIArgInfo* info);
	[LinkName("g_arg_info_is_return_value")] public static extern gboolean GArgInfoIsReturnValue(GIArgInfo* info);
	[LinkName("g_arg_info_is_optional")] public static extern gboolean GArgInfoIsOptional(GIArgInfo* info);
	[LinkName("g_arg_info_is_caller_allocates")] public static extern gboolean GArgInfoIsCallerAllocates(GIArgInfo* info);
	[LinkName("g_arg_info_may_be_null")] public static extern gboolean GArgInfoMayBeNull(GIArgInfo* info);
	[LinkName("g_arg_info_is_skip")] public static extern gboolean GArgInfoIsSkip(GIArgInfo* info);
	[LinkName("g_arg_info_get_ownership_transfer")] public static extern GITransfer GArgInfoGetOwnershipTransfer(GIArgInfo* info);
	[LinkName("g_arg_info_get_scope")] public static extern GIScopeType GArgInfoGetScope(GIArgInfo* info);
	[LinkName("g_arg_info_get_closure")] public static extern gint GArgInfoGetClosure(GIArgInfo* info);
	[LinkName("g_arg_info_get_destroy")] public static extern gint GArgInfoGetDestroy(GIArgInfo* info);
	[LinkName("g_arg_info_get_type")] public static extern GITypeInfo* GArgInfoGetType(GIArgInfo* info);
	[LinkName("g_arg_info_load_type")] public static extern void GArgInfoLoadType(GIArgInfo* info, GITypeInfo* type);
}


extension GIR
{
	[LinkName("g_typelib_new_from_memory")] public static extern GITypelib* GTypelibNewFromMemory(guint8* memory, gsize len, GError** error);
	[LinkName("g_typelib_new_from_const_memory")] public static extern GITypelib* GTypelibNewFromConstMemory(guint8* memory, gsize len, GError** error);
	[LinkName("g_typelib_new_from_mapped_file")] public static extern GITypelib* GTypelibNewFromMappedFile(GMappedFile* mfile, GError** error);
	[LinkName("g_typelib_free")] public static extern void GTypelibFree(GITypelib* typelib);
	[LinkName("g_typelib_symbol")] public static extern gboolean GTypelibSymbol(GITypelib* typelib, gchar* symbol_name, gpointer* symbol);
	[LinkName("g_typelib_get_namespace")] public static extern gchar* GTypelibGetNamespace(GITypelib* typelib);
}

/** GIAttributeIter:
 *  
 *  An opaque structure used to iterate over attributes
 *  in a #GIBaseInfo struct.
 */
[CRepr] struct GIAttributeIter
{
	public gpointer data;
	public gpointer data2;
	public gpointer data3;
	public gpointer data4;
}

extension GIR
{
	[LinkName("g_base_info_gtype_get_type")] public static extern GType GBaseInfoGtypeGetType();
	[LinkName("g_base_info_ref")] public static extern GIBaseInfo* GBaseInfoRef(GIBaseInfo* info);
	[LinkName("g_base_info_unref")] public static extern void GBaseInfoUnref(GIBaseInfo* info);
	[LinkName("g_base_info_get_type")] public static extern GIInfoType GBaseInfoGetType(GIBaseInfo* info);
	[LinkName("g_base_info_get_name")] public static extern gchar* GBaseInfoGetName(GIBaseInfo* info);
	[LinkName("g_base_info_get_namespace")] public static extern gchar* GBaseInfoGetNamespace(GIBaseInfo* info);
	[LinkName("g_base_info_is_deprecated")] public static extern gboolean GBaseInfoIsDeprecated(GIBaseInfo* info);
	[LinkName("g_base_info_get_attribute")] public static extern gchar* GBaseInfoGetAttribute(GIBaseInfo* info, gchar* name);
	[LinkName("g_base_info_iterate_attributes")] public static extern gboolean GBaseInfoIterateAttributes(GIBaseInfo* info, GIAttributeIter* iterator, c_char** name, c_char** value);
	[LinkName("g_base_info_get_container")] public static extern GIBaseInfo* GBaseInfoGetContainer(GIBaseInfo* info);
	[LinkName("g_base_info_get_typelib")] public static extern GITypelib* GBaseInfoGetTypelib(GIBaseInfo* info);
	[LinkName("g_base_info_equal")] public static extern gboolean GBaseInfoEqual(GIBaseInfo* info1, GIBaseInfo* info2);
	[LinkName("g_info_new")] public static extern GIBaseInfo* GInfoNew(GIInfoType type, GIBaseInfo* container, GITypelib* typelib, guint32 offset);
	[LinkName("g_callable_info_is_method")] public static extern gboolean GCallableInfoIsMethod(GICallableInfo* info);
	[LinkName("g_callable_info_can_throw_gerror")] public static extern gboolean GCallableInfoCanThrowGerror(GICallableInfo* info);
	[LinkName("g_callable_info_get_return_type")] public static extern GITypeInfo* GCallableInfoGetReturnType(GICallableInfo* info);
	[LinkName("g_callable_info_load_return_type")] public static extern void GCallableInfoLoadReturnType(GICallableInfo* info, GITypeInfo* type);
	[LinkName("g_callable_info_get_return_attribute")] public static extern gchar* GCallableInfoGetReturnAttribute(GICallableInfo* info, gchar* name);
	[LinkName("g_callable_info_iterate_return_attributes")] public static extern gboolean GCallableInfoIterateReturnAttributes(GICallableInfo* info, GIAttributeIter* iterator, c_char** name, c_char** value);
	[LinkName("g_callable_info_get_caller_owns")] public static extern GITransfer GCallableInfoGetCallerOwns(GICallableInfo* info);
	[LinkName("g_callable_info_may_return_null")] public static extern gboolean GCallableInfoMayReturnNull(GICallableInfo* info);
	[LinkName("g_callable_info_skip_return")] public static extern gboolean GCallableInfoSkipReturn(GICallableInfo* info);
	[LinkName("g_callable_info_get_n_args")] public static extern gint GCallableInfoGetNArgs(GICallableInfo* info);
	[LinkName("g_callable_info_get_arg")] public static extern GIArgInfo* GCallableInfoGetArg(GICallableInfo* info, gint n);
	[LinkName("g_callable_info_load_arg")] public static extern void GCallableInfoLoadArg(GICallableInfo* info, gint n, GIArgInfo* arg);
	[LinkName("g_callable_info_invoke")] public static extern gboolean GCallableInfoInvoke(GICallableInfo* info, gpointer @function, GIArgument* in_args, c_int n_in_args, GIArgument* out_args, c_int n_out_args, GIArgument* return_value, gboolean is_method, gboolean throws, GError** error);
	[LinkName("g_callable_info_get_instance_ownership_transfer")] public static extern GITransfer GCallableInfoGetInstanceOwnershipTransfer(GICallableInfo* info);
	[LinkName("g_constant_info_get_type")] public static extern GITypeInfo* GConstantInfoGetType(GIConstantInfo* info);
	[LinkName("g_constant_info_free_value")] public static extern void GConstantInfoFreeValue(GIConstantInfo* info, GIArgument* value);
	[LinkName("g_constant_info_get_value")] public static extern gint GConstantInfoGetValue(GIConstantInfo* info, GIArgument* value);
	[LinkName("g_enum_info_get_n_values")] public static extern gint GEnumInfoGetNValues(GIEnumInfo* info);
	[LinkName("g_enum_info_get_value")] public static extern GIValueInfo* GEnumInfoGetValue(GIEnumInfo* info, gint n);
	[LinkName("g_enum_info_get_n_methods")] public static extern gint GEnumInfoGetNMethods(GIEnumInfo* info);
	[LinkName("g_enum_info_get_method")] public static extern GIFunctionInfo* GEnumInfoGetMethod(GIEnumInfo* info, gint n);
	[LinkName("g_enum_info_get_storage_type")] public static extern GITypeTag GEnumInfoGetStorageType(GIEnumInfo* info);
	[LinkName("g_enum_info_get_error_domain")] public static extern gchar* GEnumInfoGetErrorDomain(GIEnumInfo* info);
	[LinkName("g_value_info_get_value")] public static extern gint64 GValueInfoGetValue(GIValueInfo* info);
	[LinkName("g_field_info_get_flags")] public static extern GIFieldInfoFlags GFieldInfoGetFlags(GIFieldInfo* info);
	[LinkName("g_field_info_get_size")] public static extern gint GFieldInfoGetSize(GIFieldInfo* info);
	[LinkName("g_field_info_get_offset")] public static extern gint GFieldInfoGetOffset(GIFieldInfo* info);
	[LinkName("g_field_info_get_type")] public static extern GITypeInfo* GFieldInfoGetType(GIFieldInfo* info);
	[LinkName("g_field_info_get_field")] public static extern gboolean GFieldInfoGetField(GIFieldInfo* field_info, gpointer mem, GIArgument* value);
	[LinkName("g_field_info_set_field")] public static extern gboolean GFieldInfoSetField(GIFieldInfo* field_info, gpointer mem, GIArgument* value);
	[LinkName("g_function_info_get_symbol")] public static extern gchar* GFunctionInfoGetSymbol(GIFunctionInfo* info);
	[LinkName("g_function_info_get_flags")] public static extern GIFunctionInfoFlags GFunctionInfoGetFlags(GIFunctionInfo* info);
	[LinkName("g_function_info_get_property")] public static extern GIPropertyInfo* GFunctionInfoGetProperty(GIFunctionInfo* info);
	[LinkName("g_function_info_get_vfunc")] public static extern GIVFuncInfo* GFunctionInfoGetVfunc(GIFunctionInfo* info);
	[LinkName("g_invoke_error_quark")] public static extern GQuark GInvokeErrorQuark();
}

/** GInvokeError:
 *   @G _INVOKE_ERROR_FAILED: invokation failed, unknown error.
 *   @G _INVOKE_ERROR_SYMBOL_NOT_FOUND: symbol couldn't be found in any of the
 *  libraries associated with the typelib of the function.
 *   @G _INVOKE_ERROR_ARGUMENT_MISMATCH: the arguments provided didn't match
 *  the expected arguments for the functions type signature.
 *  
 *  An error occuring while invoking a function via
 *  g_function_info_invoke().
 */
[AllowDuplicates] enum GInvokeError : c_int
{
	Failed = 0,
	SymbolNotFound = 1,
	ArgumentMismatch = 2,
}

extension GIR
{
	[LinkName("g_function_info_invoke")] public static extern gboolean GFunctionInfoInvoke(GIFunctionInfo* info, GIArgument* in_args, c_int n_in_args, GIArgument* out_args, c_int n_out_args, GIArgument* return_value, GError** error);
	[LinkName("g_interface_info_get_n_prerequisites")] public static extern gint GInterfaceInfoGetNPrerequisites(GIInterfaceInfo* info);
	[LinkName("g_interface_info_get_prerequisite")] public static extern GIBaseInfo* GInterfaceInfoGetPrerequisite(GIInterfaceInfo* info, gint n);
	[LinkName("g_interface_info_get_n_properties")] public static extern gint GInterfaceInfoGetNProperties(GIInterfaceInfo* info);
	[LinkName("g_interface_info_get_property")] public static extern GIPropertyInfo* GInterfaceInfoGetProperty(GIInterfaceInfo* info, gint n);
	[LinkName("g_interface_info_get_n_methods")] public static extern gint GInterfaceInfoGetNMethods(GIInterfaceInfo* info);
	[LinkName("g_interface_info_get_method")] public static extern GIFunctionInfo* GInterfaceInfoGetMethod(GIInterfaceInfo* info, gint n);
	[LinkName("g_interface_info_find_method")] public static extern GIFunctionInfo* GInterfaceInfoFindMethod(GIInterfaceInfo* info, gchar* name);
	[LinkName("g_interface_info_get_n_signals")] public static extern gint GInterfaceInfoGetNSignals(GIInterfaceInfo* info);
	[LinkName("g_interface_info_get_signal")] public static extern GISignalInfo* GInterfaceInfoGetSignal(GIInterfaceInfo* info, gint n);
	[LinkName("g_interface_info_find_signal")] public static extern GISignalInfo* GInterfaceInfoFindSignal(GIInterfaceInfo* info, gchar* name);
	[LinkName("g_interface_info_get_n_vfuncs")] public static extern gint GInterfaceInfoGetNVfuncs(GIInterfaceInfo* info);
	[LinkName("g_interface_info_get_vfunc")] public static extern GIVFuncInfo* GInterfaceInfoGetVfunc(GIInterfaceInfo* info, gint n);
	[LinkName("g_interface_info_find_vfunc")] public static extern GIVFuncInfo* GInterfaceInfoFindVfunc(GIInterfaceInfo* info, gchar* name);
	[LinkName("g_interface_info_get_n_constants")] public static extern gint GInterfaceInfoGetNConstants(GIInterfaceInfo* info);
	[LinkName("g_interface_info_get_constant")] public static extern GIConstantInfo* GInterfaceInfoGetConstant(GIInterfaceInfo* info, gint n);
	[LinkName("g_interface_info_get_iface_struct")] public static extern GIStructInfo* GInterfaceInfoGetIfaceStruct(GIInterfaceInfo* info);
}

/** GIObjectInfoRefFunction: (skip)
 *   @object : object instance pointer
 *  
 *  Increases the reference count of an object instance.
 *  
 *  Returns: (transfer full): the object instance
 */
function void* GIObjectInfoRefFunction(void* object);

/** GIObjectInfoUnrefFunction: (skip)
 *   @object : object instance pointer
 *  
 *  Decreases the reference count of an object instance.
 */
function void GIObjectInfoUnrefFunction(void* object);

/** GIObjectInfoSetValueFunction: (skip)
 *   @value : a #GValue
 *   @object : object instance pointer
 *  
 *  Update @value and attach the object instance pointer @object to it.
 */
function void GIObjectInfoSetValueFunction(GValue* value, void* object);

/** GIObjectInfoGetValueFunction: (skip)
 *   @value : a #GValue
 *  
 *  Extract an object instance out of @value
 *  
 *  Returns: (transfer full): the object instance
 */
function void* GIObjectInfoGetValueFunction(GValue* value);

extension GIR
{
	[LinkName("g_object_info_get_type_name")] public static extern gchar* GObjectInfoGetTypeName(GIObjectInfo* info);
	[LinkName("g_object_info_get_type_init")] public static extern gchar* GObjectInfoGetTypeInit(GIObjectInfo* info);
	[LinkName("g_object_info_get_abstract")] public static extern gboolean GObjectInfoGetAbstract(GIObjectInfo* info);
	[LinkName("g_object_info_get_final")] public static extern gboolean GObjectInfoGetFinal(GIObjectInfo* info);
	[LinkName("g_object_info_get_fundamental")] public static extern gboolean GObjectInfoGetFundamental(GIObjectInfo* info);
	[LinkName("g_object_info_get_parent")] public static extern GIObjectInfo* GObjectInfoGetParent(GIObjectInfo* info);
	[LinkName("g_object_info_get_n_interfaces")] public static extern gint GObjectInfoGetNInterfaces(GIObjectInfo* info);
	[LinkName("g_object_info_get_interface")] public static extern GIInterfaceInfo* GObjectInfoGetInterface(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_get_n_fields")] public static extern gint GObjectInfoGetNFields(GIObjectInfo* info);
	[LinkName("g_object_info_get_field")] public static extern GIFieldInfo* GObjectInfoGetField(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_get_n_properties")] public static extern gint GObjectInfoGetNProperties(GIObjectInfo* info);
	[LinkName("g_object_info_get_property")] public static extern GIPropertyInfo* GObjectInfoGetProperty(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_get_n_methods")] public static extern gint GObjectInfoGetNMethods(GIObjectInfo* info);
	[LinkName("g_object_info_get_method")] public static extern GIFunctionInfo* GObjectInfoGetMethod(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_find_method")] public static extern GIFunctionInfo* GObjectInfoFindMethod(GIObjectInfo* info, gchar* name);
	[LinkName("g_object_info_find_method_using_interfaces")] public static extern GIFunctionInfo* GObjectInfoFindMethodUsingInterfaces(GIObjectInfo* info, gchar* name, GIObjectInfo** implementor);
	[LinkName("g_object_info_get_n_signals")] public static extern gint GObjectInfoGetNSignals(GIObjectInfo* info);
	[LinkName("g_object_info_get_signal")] public static extern GISignalInfo* GObjectInfoGetSignal(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_find_signal")] public static extern GISignalInfo* GObjectInfoFindSignal(GIObjectInfo* info, gchar* name);
	[LinkName("g_object_info_get_n_vfuncs")] public static extern gint GObjectInfoGetNVfuncs(GIObjectInfo* info);
	[LinkName("g_object_info_get_vfunc")] public static extern GIVFuncInfo* GObjectInfoGetVfunc(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_find_vfunc")] public static extern GIVFuncInfo* GObjectInfoFindVfunc(GIObjectInfo* info, gchar* name);
	[LinkName("g_object_info_find_vfunc_using_interfaces")] public static extern GIVFuncInfo* GObjectInfoFindVfuncUsingInterfaces(GIObjectInfo* info, gchar* name, GIObjectInfo** implementor);
	[LinkName("g_object_info_get_n_constants")] public static extern gint GObjectInfoGetNConstants(GIObjectInfo* info);
	[LinkName("g_object_info_get_constant")] public static extern GIConstantInfo* GObjectInfoGetConstant(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_get_class_struct")] public static extern GIStructInfo* GObjectInfoGetClassStruct(GIObjectInfo* info);
	[LinkName("g_object_info_get_ref_function")] public static extern c_char* GObjectInfoGetRefFunction(GIObjectInfo* info);
	[LinkName("g_object_info_get_ref_function_pointer")] public static extern GIObjectInfoRefFunction GObjectInfoGetRefFunctionPointer(GIObjectInfo* info);
	[LinkName("g_object_info_get_unref_function")] public static extern c_char* GObjectInfoGetUnrefFunction(GIObjectInfo* info);
	[LinkName("g_object_info_get_unref_function_pointer")] public static extern GIObjectInfoUnrefFunction GObjectInfoGetUnrefFunctionPointer(GIObjectInfo* info);
	[LinkName("g_object_info_get_set_value_function")] public static extern c_char* GObjectInfoGetSetValueFunction(GIObjectInfo* info);
	[LinkName("g_object_info_get_set_value_function_pointer")] public static extern GIObjectInfoSetValueFunction GObjectInfoGetSetValueFunctionPointer(GIObjectInfo* info);
	[LinkName("g_object_info_get_get_value_function")] public static extern c_char* GObjectInfoGetGetValueFunction(GIObjectInfo* info);
	[LinkName("g_object_info_get_get_value_function_pointer")] public static extern GIObjectInfoGetValueFunction GObjectInfoGetGetValueFunctionPointer(GIObjectInfo* info);
	[LinkName("g_property_info_get_flags")] public static extern GParamFlags GPropertyInfoGetFlags(GIPropertyInfo* info);
	[LinkName("g_property_info_get_type")] public static extern GITypeInfo* GPropertyInfoGetType(GIPropertyInfo* info);
	[LinkName("g_property_info_get_ownership_transfer")] public static extern GITransfer GPropertyInfoGetOwnershipTransfer(GIPropertyInfo* info);
	[LinkName("g_property_info_get_setter")] public static extern GIFunctionInfo* GPropertyInfoGetSetter(GIPropertyInfo* info);
	[LinkName("g_property_info_get_getter")] public static extern GIFunctionInfo* GPropertyInfoGetGetter(GIPropertyInfo* info);
	[LinkName("g_registered_type_info_get_type_name")] public static extern gchar* GRegisteredTypeInfoGetTypeName(GIRegisteredTypeInfo* info);
	[LinkName("g_registered_type_info_get_type_init")] public static extern gchar* GRegisteredTypeInfoGetTypeInit(GIRegisteredTypeInfo* info);
	[LinkName("g_registered_type_info_get_g_type")] public static extern GType GRegisteredTypeInfoGetGType(GIRegisteredTypeInfo* info);
	[LinkName("g_signal_info_get_flags")] public static extern GSignalFlags GSignalInfoGetFlags(GISignalInfo* info);
	[LinkName("g_signal_info_get_class_closure")] public static extern GIVFuncInfo* GSignalInfoGetClassClosure(GISignalInfo* info);
	[LinkName("g_signal_info_true_stops_emit")] public static extern gboolean GSignalInfoTrueStopsEmit(GISignalInfo* info);
	[LinkName("g_struct_info_get_n_fields")] public static extern gint GStructInfoGetNFields(GIStructInfo* info);
	[LinkName("g_struct_info_get_field")] public static extern GIFieldInfo* GStructInfoGetField(GIStructInfo* info, gint n);
	[LinkName("g_struct_info_find_field")] public static extern GIFieldInfo* GStructInfoFindField(GIStructInfo* info, gchar* name);
	[LinkName("g_struct_info_get_n_methods")] public static extern gint GStructInfoGetNMethods(GIStructInfo* info);
	[LinkName("g_struct_info_get_method")] public static extern GIFunctionInfo* GStructInfoGetMethod(GIStructInfo* info, gint n);
	[LinkName("g_struct_info_find_method")] public static extern GIFunctionInfo* GStructInfoFindMethod(GIStructInfo* info, gchar* name);
	[LinkName("g_struct_info_get_size")] public static extern gsize GStructInfoGetSize(GIStructInfo* info);
	[LinkName("g_struct_info_get_alignment")] public static extern gsize GStructInfoGetAlignment(GIStructInfo* info);
	[LinkName("g_struct_info_is_gtype_struct")] public static extern gboolean GStructInfoIsGtypeStruct(GIStructInfo* info);
	[LinkName("g_struct_info_is_foreign")] public static extern gboolean GStructInfoIsForeign(GIStructInfo* info);
	[LinkName("g_struct_info_get_copy_function")] public static extern c_char* GStructInfoGetCopyFunction(GIStructInfo* info);
	[LinkName("g_struct_info_get_free_function")] public static extern c_char* GStructInfoGetFreeFunction(GIStructInfo* info);
	[LinkName("g_type_tag_to_string")] public static extern gchar* GTypeTagToString(GITypeTag type);
	[LinkName("g_info_type_to_string")] public static extern gchar* GInfoTypeToString(GIInfoType type);
	[LinkName("g_type_info_is_pointer")] public static extern gboolean GTypeInfoIsPointer(GITypeInfo* info);
	[LinkName("g_type_info_get_tag")] public static extern GITypeTag GTypeInfoGetTag(GITypeInfo* info);
	[LinkName("g_type_info_get_param_type")] public static extern GITypeInfo* GTypeInfoGetParamType(GITypeInfo* info, gint n);
	[LinkName("g_type_info_get_interface")] public static extern GIBaseInfo* GTypeInfoGetInterface(GITypeInfo* info);
	[LinkName("g_type_info_get_array_length")] public static extern gint GTypeInfoGetArrayLength(GITypeInfo* info);
	[LinkName("g_type_info_get_array_fixed_size")] public static extern gint GTypeInfoGetArrayFixedSize(GITypeInfo* info);
	[LinkName("g_type_info_is_zero_terminated")] public static extern gboolean GTypeInfoIsZeroTerminated(GITypeInfo* info);
	[LinkName("g_type_info_get_array_type")] public static extern GIArrayType GTypeInfoGetArrayType(GITypeInfo* info);
	[LinkName("g_type_info_get_storage_type")] public static extern GITypeTag GTypeInfoGetStorageType(GITypeInfo* info);
	[LinkName("g_type_info_argument_from_hash_pointer")] public static extern void GTypeInfoArgumentFromHashPointer(GITypeInfo* info, gpointer hash_pointer, GIArgument* arg);
	[LinkName("g_type_info_hash_pointer_from_argument")] public static extern gpointer GTypeInfoHashPointerFromArgument(GITypeInfo* info, GIArgument* arg);
	[LinkName("gi_type_tag_argument_from_hash_pointer")] public static extern void GiTypeTagArgumentFromHashPointer(GITypeTag storage_type, gpointer hash_pointer, GIArgument* arg);
	[LinkName("gi_type_tag_hash_pointer_from_argument")] public static extern gpointer GiTypeTagHashPointerFromArgument(GITypeTag storage_type, GIArgument* arg);
	[LinkName("g_union_info_get_n_fields")] public static extern gint GUnionInfoGetNFields(GIUnionInfo* info);
	[LinkName("g_union_info_get_field")] public static extern GIFieldInfo* GUnionInfoGetField(GIUnionInfo* info, gint n);
	[LinkName("g_union_info_get_n_methods")] public static extern gint GUnionInfoGetNMethods(GIUnionInfo* info);
	[LinkName("g_union_info_get_method")] public static extern GIFunctionInfo* GUnionInfoGetMethod(GIUnionInfo* info, gint n);
	[LinkName("g_union_info_is_discriminated")] public static extern gboolean GUnionInfoIsDiscriminated(GIUnionInfo* info);
	[LinkName("g_union_info_get_discriminator_offset")] public static extern gint GUnionInfoGetDiscriminatorOffset(GIUnionInfo* info);
	[LinkName("g_union_info_get_discriminator_type")] public static extern GITypeInfo* GUnionInfoGetDiscriminatorType(GIUnionInfo* info);
	[LinkName("g_union_info_get_discriminator")] public static extern GIConstantInfo* GUnionInfoGetDiscriminator(GIUnionInfo* info, gint n);
	[LinkName("g_union_info_find_method")] public static extern GIFunctionInfo* GUnionInfoFindMethod(GIUnionInfo* info, gchar* name);
	[LinkName("g_union_info_get_size")] public static extern gsize GUnionInfoGetSize(GIUnionInfo* info);
	[LinkName("g_union_info_get_alignment")] public static extern gsize GUnionInfoGetAlignment(GIUnionInfo* info);
	[LinkName("g_union_info_get_copy_function")] public static extern c_char* GUnionInfoGetCopyFunction(GIUnionInfo* info);
	[LinkName("g_union_info_get_free_function")] public static extern c_char* GUnionInfoGetFreeFunction(GIUnionInfo* info);
	[LinkName("g_vfunc_info_get_flags")] public static extern GIVFuncInfoFlags GVfuncInfoGetFlags(GIVFuncInfo* info);
	[LinkName("g_vfunc_info_get_offset")] public static extern gint GVfuncInfoGetOffset(GIVFuncInfo* info);
	[LinkName("g_vfunc_info_get_signal")] public static extern GISignalInfo* GVfuncInfoGetSignal(GIVFuncInfo* info);
	[LinkName("g_vfunc_info_get_invoker")] public static extern GIFunctionInfo* GVfuncInfoGetInvoker(GIVFuncInfo* info);
	[LinkName("g_vfunc_info_get_address")] public static extern gpointer GVfuncInfoGetAddress(GIVFuncInfo* info, GType implementor_gtype, GError** error);
	[LinkName("g_vfunc_info_invoke")] public static extern gboolean GVfuncInfoInvoke(GIVFuncInfo* info, GType implementor, GIArgument* in_args, c_int n_in_args, GIArgument* out_args, c_int n_out_args, GIArgument* return_value, GError** error);
	[LinkName("gi_get_major_version")] public static extern guint GiGetMajorVersion();
	[LinkName("gi_get_minor_version")] public static extern guint GiGetMinorVersion();
	[LinkName("gi_get_micro_version")] public static extern guint GiGetMicroVersion();
}

struct GIRepository;

struct GIRepositoryClass;

struct GIRepositoryPrivate;

/** GIRepositoryLoadFlags:
 *   @G _IREPOSITORY_LOAD_FLAG_LAZY: Lazily load the typelib.
 *  
 *  Flags that control how a typelib is loaded.
 */
[AllowDuplicates] enum GIRepositoryLoadFlags : c_int
{
	Lazy = 1 << 0,
}

extension GIRepository
{
	[LinkName("g_irepository_get_type")] public static extern GType GetType();
	[LinkName("g_irepository_get_default")] public static extern GIRepository* GetDefault();
	[LinkName("g_irepository_prepend_search_path")] public static extern void PrependSearchPath(c_char* directory);
	[LinkName("g_irepository_prepend_library_path")] public static extern void PrependLibraryPath(c_char* directory);
	[LinkName("g_irepository_get_search_path")] public static extern GSList* GetSearchPath();
	[LinkName("g_irepository_load_typelib")] public static extern c_char* LoadTypelib(GIRepository* repository, GITypelib* typelib, GIRepositoryLoadFlags flags, GError** error);
	[LinkName("g_irepository_is_registered")] public static extern gboolean IsRegistered(GIRepository* repository, gchar* @namespace, gchar* version);
	[LinkName("g_irepository_find_by_name")] public static extern GIBaseInfo* FindByName(GIRepository* repository, gchar* @namespace, gchar* name);
	[LinkName("g_irepository_enumerate_versions")] public static extern GList* EnumerateVersions(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_require")] public static extern GITypelib* Require(GIRepository* repository, gchar* @namespace, gchar* version, GIRepositoryLoadFlags flags, GError** error);
	[LinkName("g_irepository_require_private")] public static extern GITypelib* RequirePrivate(GIRepository* repository, gchar* typelib_dir, gchar* @namespace, gchar* version, GIRepositoryLoadFlags flags, GError** error);
	[LinkName("g_irepository_get_immediate_dependencies")] public static extern gchar** GetImmediateDependencies(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_dependencies")] public static extern gchar** GetDependencies(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_loaded_namespaces")] public static extern gchar** GetLoadedNamespaces(GIRepository* repository);
	[LinkName("g_irepository_find_by_gtype")] public static extern GIBaseInfo* FindByGtype(GIRepository* repository, GType gtype);
	[LinkName("g_irepository_get_object_gtype_interfaces")] public static extern void GetObjectGtypeInterfaces(GIRepository* repository, GType gtype, guint* n_interfaces_out, GIInterfaceInfo*** interfaces_out);
	[LinkName("g_irepository_get_n_infos")] public static extern gint GetNInfos(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_info")] public static extern GIBaseInfo* GetInfo(GIRepository* repository, gchar* @namespace, gint index);
	[LinkName("g_irepository_find_by_error_domain")] public static extern GIEnumInfo* FindByErrorDomain(GIRepository* repository, GQuark domain);
	[LinkName("g_irepository_get_typelib_path")] public static extern gchar* GetTypelibPath(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_shared_library")] public static extern gchar* GetSharedLibrary(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_c_prefix")] public static extern gchar* GetCPrefix(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_version")] public static extern gchar* GetVersion(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_option_group")] public static extern GOptionGroup* GetOptionGroup();
	[LinkName("g_irepository_dump")] public static extern gboolean Dump(c_char* arg, GError** error);
}

/** GIRepositoryError:
 *   @G _IREPOSITORY_ERROR_TYPELIB_NOT_FOUND: the typelib could not be found.
 *   @G _IREPOSITORY_ERROR_NAMESPACE_MISMATCH: the namespace does not match the
 *  requested namespace.
 *   @G _IREPOSITORY_ERROR_NAMESPACE_VERSION_CONFLICT: the version of the
 *  typelib does not match the requested version.
 *   @G _IREPOSITORY_ERROR_LIBRARY_NOT_FOUND: the library used by the typelib
 *  could not be found.
 *  
 *  An error code used with #G_IREPOSITORY_ERROR in a #GError returned
 *  from a #GIRepository routine.
 */
[AllowDuplicates] enum GIRepositoryError : c_int
{
	TypelibNotFound = 0,
	NamespaceMismatch = 1,
	NamespaceVersionConflict = 2,
	LibraryNotFound = 3,
}

extension GIRepository
{
	[LinkName("g_irepository_error_quark")] public static extern GQuark ErrorQuark();
}

extension GIR
{
	[LinkName("gi_cclosure_marshal_generic")] public static extern void GiCclosureMarshalGeneric(GClosure* closure, GValue* return_gvalue, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
}

