/* Auto generated by https://github.com/Rune-Magic/C2Beef-Binding-Generator
 * DO NOT EDIT
 */

using GLib;
using System;
using System.Interop;

namespace GIRepository;

static
{
	public const let GI_MAJOR_VERSION = 1;
	public const let GI_MINOR_VERSION = 84;
	public const let GI_MICRO_VERSION = 0;
}

[CRepr] struct GIBaseInfoStub
{
	public gint32 dummy1;
	public gint32 dummy2;
	public gpointer dummy3;
	public gpointer dummy4;
	public gpointer dummy5;
	public guint32 dummy6;
	public guint32 dummy7;
	public gpointer[4] padding;
}

typealias GIBaseInfo = GIBaseInfoStub;
struct GICallableInfo : GIBaseInfo;
struct GIFunctionInfo : GIBaseInfo;
struct GICallbackInfo : GIBaseInfo;
struct GIRegisteredTypeInfo : GIBaseInfo;
struct GIStructInfo : GIBaseInfo;
struct GIUnionInfo : GIBaseInfo;
struct GIEnumInfo : GIBaseInfo;
struct GIObjectInfo : GIBaseInfo;
struct GIInterfaceInfo : GIBaseInfo;
struct GIConstantInfo : GIBaseInfo;
struct GIValueInfo : GIBaseInfo;
struct GISignalInfo : GIBaseInfo;
struct GIVFuncInfo : GIBaseInfo;
struct GIPropertyInfo : GIBaseInfo;
struct GIFieldInfo : GIBaseInfo;
struct GIArgInfo : GIBaseInfo;
struct GITypeInfo : GIBaseInfo;

struct GIUnresolvedInfo;

[Union, CRepr] struct GIArgument
{
	public gboolean v_boolean;
	public gint8 v_int8;
	public guint8 v_uint8;
	public gint16 v_int16;
	public guint16 v_uint16;
	public gint32 v_int32;
	public guint32 v_uint32;
	public gint64 v_int64;
	public guint64 v_uint64;
	public gfloat v_float;
	public gdouble v_double;
	public gshort v_short;
	public gushort v_ushort;
	public gint v_int;
	public guint v_uint;
	public glong v_long;
	public gulong v_ulong;
	public gssize v_ssize;
	public gsize v_size;
	public gchar* v_string;
	public gpointer v_pointer;
}

/** GIInfoType:
 *   @GI _INFO_TYPE_INVALID: invalid type
 *   @GI _INFO_TYPE_FUNCTION: function, see #GIFunctionInfo
 *   @GI _INFO_TYPE_CALLBACK: callback, see #GIFunctionInfo
 *   @GI _INFO_TYPE_STRUCT: struct, see #GIStructInfo
 *   @GI _INFO_TYPE_BOXED: boxed, see #GIStructInfo or #GIUnionInfo
 *   @GI _INFO_TYPE_ENUM: enum, see #GIEnumInfo
 *   @GI _INFO_TYPE_FLAGS: flags, see #GIEnumInfo
 *   @GI _INFO_TYPE_OBJECT: object, see #GIObjectInfo
 *   @GI _INFO_TYPE_INTERFACE: interface, see #GIInterfaceInfo
 *   @GI _INFO_TYPE_CONSTANT: contant, see #GIConstantInfo
 *   @GI _INFO_TYPE_INVALID_0: deleted, used to be GI_INFO_TYPE_ERROR_DOMAIN.
 *   @GI _INFO_TYPE_UNION: union, see #GIUnionInfo
 *   @GI _INFO_TYPE_VALUE: enum value, see #GIValueInfo
 *   @GI _INFO_TYPE_SIGNAL: signal, see #GISignalInfo
 *   @GI _INFO_TYPE_VFUNC: virtual function, see #GIVFuncInfo
 *   @GI _INFO_TYPE_PROPERTY: GObject property, see #GIPropertyInfo
 *   @GI _INFO_TYPE_FIELD: struct or union field, see #GIFieldInfo
 *   @GI _INFO_TYPE_ARG: argument of a function or callback, see #GIArgInfo
 *   @GI _INFO_TYPE_TYPE: type information, see #GITypeInfo
 *   @GI _INFO_TYPE_UNRESOLVED: unresolved type, a type which is not present in
 *  the typelib, or any of its dependencies.
 *  
 *  The type of a GIBaseInfo struct.
 */
[AllowDuplicates] enum GIInfoType : c_int
{
	Invalid = 0,
	Function = 1,
	Callback = 2,
	Struct = 3,
	Boxed = 4,
	Enum = 5,
	Flags = 6,
	Object = 7,
	Interface = 8,
	Constant = 9,
	Invalid0 = 10,
	Union = 11,
	Value = 12,
	Signal = 13,
	Vfunc = 14,
	Property = 15,
	Field = 16,
	Arg = 17,
	Type = 18,
	Unresolved = 19,
}

/** GITransfer:
 *   @GI _TRANSFER_NOTHING: transfer nothing from the callee (function or the type
 *  instance the property belongs to) to the caller. The callee retains the
 *  ownership of the transfer and the caller doesn't need to do anything to free
 *  up the resources of this transfer.
 *   @GI _TRANSFER_CONTAINER: transfer the container (list, array, hash table) from
 *  the callee to the caller. The callee retains the ownership of the individual
 *  items in the container and the caller has to free up the container resources
 *  (g_list_free()/g_hash_table_destroy() etc) of this transfer.
 *   @GI _TRANSFER_EVERYTHING: transfer everything, eg the container and its
 *  contents from the callee to the caller. This is the case when the callee
 *  creates a copy of all the data it returns. The caller is responsible for
 *  cleaning up the container and item resources of this transfer.
 *  
 *  The transfer is the exchange of data between two parts, from the callee to
 *  the caller. The callee is either a function/method/signal or an
 *  object/interface where a property is defined. The caller is the side
 *  accessing a property or calling a function.
 *  #GITransfer specifies who's responsible for freeing the resources after the
 *  ownership transfer is complete. In case of a containing type such as a list,
 *  an array or a hash table the container itself is specified differently from
 *  the items within the container itself. Each container is freed differently,
 *  check the documentation for the types themselves for information on how to
 *  free them.
 */
[AllowDuplicates] enum GITransfer : c_int
{
	Nothing = 0,
	Container = 1,
	Everything = 2,
}

/** GIDirection:
 *   @GI _DIRECTION_IN: in argument.
 *   @GI _DIRECTION_OUT: out argument.
 *   @GI _DIRECTION_INOUT: in and out argument.
 *  
 *  The direction of a #GIArgInfo.
 */
[AllowDuplicates] enum GIDirection : c_int
{
	In = 0,
	Out = 1,
	Inout = 2,
}

/** GIScopeType:
 *   @GI _SCOPE_TYPE_INVALID: The argument is not of callback type.
 *   @GI _SCOPE_TYPE_CALL: The callback and associated user_data is only
 *  used during the call to this function.
 *   @GI _SCOPE_TYPE_ASYNC: The callback and associated user_data is
 *  only used until the callback is invoked, and the callback.
 *  is invoked always exactly once.
 *   @GI _SCOPE_TYPE_NOTIFIED: The callback and associated
 *  user_data is used until the caller is notfied via the destroy_notify.
 *   @GI _SCOPE_TYPE_FOREVER: The callback and associated user_data is
 *  used until the process terminates
 *  
 *  Scope type of a #GIArgInfo representing callback, determines how the
 *  callback is invoked and is used to decided when the invoke structs
 *  can be freed.
 */
[AllowDuplicates] enum GIScopeType : c_int
{
	Invalid = 0,
	Call = 1,
	Async = 2,
	Notified = 3,
	Forever = 4,
}

/** GITypeTag:
 *   @GI _TYPE_TAG_VOID: void
 *   @GI _TYPE_TAG_BOOLEAN: boolean
 *   @GI _TYPE_TAG_INT8: 8-bit signed integer
 *   @GI _TYPE_TAG_UINT8: 8-bit unsigned integer
 *   @GI _TYPE_TAG_INT16: 16-bit signed integer
 *   @GI _TYPE_TAG_UINT16: 16-bit unsigned integer
 *   @GI _TYPE_TAG_INT32: 32-bit signed integer
 *   @GI _TYPE_TAG_UINT32: 32-bit unsigned integer
 *   @GI _TYPE_TAG_INT64: 64-bit signed integer
 *   @GI _TYPE_TAG_UINT64: 64-bit unsigned integer
 *   @GI _TYPE_TAG_FLOAT: float
 *   @GI _TYPE_TAG_DOUBLE: double floating point
 *   @GI _TYPE_TAG_GTYPE: a #GType
 *   @GI _TYPE_TAG_UTF8: a UTF-8 encoded string
 *   @GI _TYPE_TAG_FILENAME: a filename, encoded in the same encoding
 *  as the native filesystem is using.
 *   @GI _TYPE_TAG_ARRAY: an array
 *   @GI _TYPE_TAG_INTERFACE: an extended interface object
 *   @GI _TYPE_TAG_GLIST: a #GList
 *   @GI _TYPE_TAG_GSLIST: a #GSList
 *   @GI _TYPE_TAG_GHASH: a #GHashTable
 *   @GI _TYPE_TAG_ERROR: a #GError
 *   @GI _TYPE_TAG_UNICHAR: Unicode character
 *  
 *  The type tag of a #GITypeInfo.
 */
[AllowDuplicates] enum GITypeTag : c_int
{
	Void = 0,
	Boolean = 1,
	Int8 = 2,
	Uint8 = 3,
	Int16 = 4,
	Uint16 = 5,
	Int32 = 6,
	Uint32 = 7,
	Int64 = 8,
	Uint64 = 9,
	Float = 10,
	Double = 11,
	Gtype = 12,
	Utf8 = 13,
	Filename = 14,
	Array = 15,
	Interface = 16,
	Glist = 17,
	Gslist = 18,
	Ghash = 19,
	Error = 20,
	Unichar = 21,
}

/** GIArrayType:
 *   @GI _ARRAY_TYPE_C: a C array, char[] for instance
 *   @GI _ARRAY_TYPE_ARRAY: a @GArray array
 *   @GI _ARRAY_TYPE_PTR_ARRAY: a #GPtrArray array
 *   @GI _ARRAY_TYPE_BYTE_ARRAY: a #GByteArray array
 *  
 *  The type of array in a #GITypeInfo.
 */
[AllowDuplicates] enum GIArrayType : c_int
{
	C = 0,
	Array = 1,
	PtrArray = 2,
	ByteArray = 3,
}

/** GIFieldInfoFlags:
 *   @GI _FIELD_IS_READABLE: field is readable.
 *   @GI _FIELD_IS_WRITABLE: field is writable.
 *  
 *  Flags for a #GIFieldInfo.
 */
[AllowDuplicates] enum GIFieldInfoFlags : c_int
{
	SReadable = 1 << 0,
	SWritable = 1 << 1,
}

/** GIVFuncInfoFlags:
 *   @GI _VFUNC_MUST_CHAIN_UP: chains up to the parent type
 *   @GI _VFUNC_MUST_OVERRIDE: overrides
 *   @GI _VFUNC_MUST_NOT_OVERRIDE: does not override
 *   @GI _VFUNC_THROWS: Includes a #GError
 *  
 *  Flags of a #GIVFuncInfo struct.
 */
[AllowDuplicates] enum GIVFuncInfoFlags : c_int
{
	MustChainUp = 1 << 0,
	MustOverride = 1 << 1,
	MustNotOverride = 1 << 2,
	Throws = 1 << 3,
}

/** GIFunctionInfoFlags:
 *   @GI _FUNCTION_IS_METHOD: is a method.
 *   @GI _FUNCTION_IS_CONSTRUCTOR: is a constructor.
 *   @GI _FUNCTION_IS_GETTER: is a getter of a #GIPropertyInfo.
 *   @GI _FUNCTION_IS_SETTER: is a setter of a #GIPropertyInfo.
 *   @GI _FUNCTION_WRAPS_VFUNC: represents a virtual function.
 *   @GI _FUNCTION_THROWS: the function may throw an error.
 *  
 *  Flags for a #GIFunctionInfo struct.
 */
[AllowDuplicates] enum GIFunctionInfoFlags : c_int
{
	SMethod = 1 << 0,
	SConstructor = 1 << 1,
	SGetter = 1 << 2,
	SSetter = 1 << 3,
	WrapsVfunc = 1 << 4,
	Throws = 1 << 5,
}

typealias GArgument = GIArgument;

struct GITypelib;
typealias GTypelib = GITypelib;

extension GIR
{
	[LinkName("g_arg_info_get_direction")] public static extern GIDirection ArgInfoGetDirection(GIArgInfo* info);
	[LinkName("g_arg_info_is_return_value")] public static extern gboolean ArgInfoIsReturnValue(GIArgInfo* info);
	[LinkName("g_arg_info_is_optional")] public static extern gboolean ArgInfoIsOptional(GIArgInfo* info);
	[LinkName("g_arg_info_is_caller_allocates")] public static extern gboolean ArgInfoIsCallerAllocates(GIArgInfo* info);
	[LinkName("g_arg_info_may_be_null")] public static extern gboolean ArgInfoMayBeNull(GIArgInfo* info);
	[LinkName("g_arg_info_is_skip")] public static extern gboolean ArgInfoIsSkip(GIArgInfo* info);
	[LinkName("g_arg_info_get_ownership_transfer")] public static extern GITransfer ArgInfoGetOwnershipTransfer(GIArgInfo* info);
	[LinkName("g_arg_info_get_scope")] public static extern GIScopeType ArgInfoGetScope(GIArgInfo* info);
	[LinkName("g_arg_info_get_closure")] public static extern gint ArgInfoGetClosure(GIArgInfo* info);
	[LinkName("g_arg_info_get_destroy")] public static extern gint ArgInfoGetDestroy(GIArgInfo* info);
	[LinkName("g_arg_info_get_type")] public static extern GITypeInfo* ArgInfoGetType(GIArgInfo* info);
	[LinkName("g_arg_info_load_type")] public static extern void ArgInfoLoadType(GIArgInfo* info, GITypeInfo* type);
}


extension GIR
{
	[LinkName("g_typelib_new_from_memory")] public static extern GITypelib* TypelibNewFromMemory(guint8* memory, gsize len, GError** error);
	[LinkName("g_typelib_new_from_const_memory")] public static extern GITypelib* TypelibNewFromConstMemory(guint8* memory, gsize len, GError** error);
	[LinkName("g_typelib_new_from_mapped_file")] public static extern GITypelib* TypelibNewFromMappedFile(GMappedFile* mfile, GError** error);
	[LinkName("g_typelib_free")] public static extern void TypelibFree(GITypelib* typelib);
	[LinkName("g_typelib_symbol")] public static extern gboolean TypelibSymbol(GITypelib* typelib, gchar* symbol_name, gpointer* symbol);
	[LinkName("g_typelib_get_namespace")] public static extern gchar* TypelibGetNamespace(GITypelib* typelib);
}

/** GIAttributeIter:
 *  
 *  An opaque structure used to iterate over attributes
 *  in a #GIBaseInfo struct.
 */
[CRepr] struct GIAttributeIter
{
	public gpointer data;
	public gpointer data2;
	public gpointer data3;
	public gpointer data4;
}

extension GIR
{
	[LinkName("g_base_info_gtype_get_type")] public static extern GType BaseInfoGtypeGetType();
	[LinkName("g_base_info_ref")] public static extern GIBaseInfo* BaseInfoRef(GIBaseInfo* info);
	[LinkName("g_base_info_unref")] public static extern void BaseInfoUnref(GIBaseInfo* info);
	[LinkName("g_base_info_get_type")] public static extern GIInfoType BaseInfoGetType(GIBaseInfo* info);
	[LinkName("g_base_info_get_name")] public static extern gchar* BaseInfoGetName(GIBaseInfo* info);
	[LinkName("g_base_info_get_namespace")] public static extern gchar* BaseInfoGetNamespace(GIBaseInfo* info);
	[LinkName("g_base_info_is_deprecated")] public static extern gboolean BaseInfoIsDeprecated(GIBaseInfo* info);
	[LinkName("g_base_info_get_attribute")] public static extern gchar* BaseInfoGetAttribute(GIBaseInfo* info, gchar* name);
	[LinkName("g_base_info_iterate_attributes")] public static extern gboolean BaseInfoIterateAttributes(GIBaseInfo* info, GIAttributeIter* iterator, c_char** name, c_char** value);
	[LinkName("g_base_info_get_container")] public static extern GIBaseInfo* BaseInfoGetContainer(GIBaseInfo* info);
	[LinkName("g_base_info_get_typelib")] public static extern GITypelib* BaseInfoGetTypelib(GIBaseInfo* info);
	[LinkName("g_base_info_equal")] public static extern gboolean BaseInfoEqual(GIBaseInfo* info1, GIBaseInfo* info2);
	[LinkName("g_info_new")] public static extern GIBaseInfo* NfoNew(GIInfoType type, GIBaseInfo* container, GITypelib* typelib, guint32 offset);
	[LinkName("g_callable_info_is_method")] public static extern gboolean CallableInfoIsMethod(GICallableInfo* info);
	[LinkName("g_callable_info_can_throw_gerror")] public static extern gboolean CallableInfoCanThrowGerror(GICallableInfo* info);
	[LinkName("g_callable_info_get_return_type")] public static extern GITypeInfo* CallableInfoGetReturnType(GICallableInfo* info);
	[LinkName("g_callable_info_load_return_type")] public static extern void CallableInfoLoadReturnType(GICallableInfo* info, GITypeInfo* type);
	[LinkName("g_callable_info_get_return_attribute")] public static extern gchar* CallableInfoGetReturnAttribute(GICallableInfo* info, gchar* name);
	[LinkName("g_callable_info_iterate_return_attributes")] public static extern gboolean CallableInfoIterateReturnAttributes(GICallableInfo* info, GIAttributeIter* iterator, c_char** name, c_char** value);
	[LinkName("g_callable_info_get_caller_owns")] public static extern GITransfer CallableInfoGetCallerOwns(GICallableInfo* info);
	[LinkName("g_callable_info_may_return_null")] public static extern gboolean CallableInfoMayReturnNull(GICallableInfo* info);
	[LinkName("g_callable_info_skip_return")] public static extern gboolean CallableInfoSkipReturn(GICallableInfo* info);
	[LinkName("g_callable_info_get_n_args")] public static extern gint CallableInfoGetNArgs(GICallableInfo* info);
	[LinkName("g_callable_info_get_arg")] public static extern GIArgInfo* CallableInfoGetArg(GICallableInfo* info, gint n);
	[LinkName("g_callable_info_load_arg")] public static extern void CallableInfoLoadArg(GICallableInfo* info, gint n, GIArgInfo* arg);
	[LinkName("g_callable_info_invoke")] public static extern gboolean CallableInfoInvoke(GICallableInfo* info, gpointer @function, GIArgument* in_args, c_int n_in_args, GIArgument* out_args, c_int n_out_args, GIArgument* return_value, gboolean is_method, gboolean throws, GError** error);
	[LinkName("g_callable_info_get_instance_ownership_transfer")] public static extern GITransfer CallableInfoGetInstanceOwnershipTransfer(GICallableInfo* info);
	[LinkName("g_constant_info_get_type")] public static extern GITypeInfo* ConstantInfoGetType(GIConstantInfo* info);
	[LinkName("g_constant_info_free_value")] public static extern void ConstantInfoFreeValue(GIConstantInfo* info, GIArgument* value);
	[LinkName("g_constant_info_get_value")] public static extern gint ConstantInfoGetValue(GIConstantInfo* info, GIArgument* value);
	[LinkName("g_enum_info_get_n_values")] public static extern gint EnumInfoGetNValues(GIEnumInfo* info);
	[LinkName("g_enum_info_get_value")] public static extern GIValueInfo* EnumInfoGetValue(GIEnumInfo* info, gint n);
	[LinkName("g_enum_info_get_n_methods")] public static extern gint EnumInfoGetNMethods(GIEnumInfo* info);
	[LinkName("g_enum_info_get_method")] public static extern GIFunctionInfo* EnumInfoGetMethod(GIEnumInfo* info, gint n);
	[LinkName("g_enum_info_get_storage_type")] public static extern GITypeTag EnumInfoGetStorageType(GIEnumInfo* info);
	[LinkName("g_enum_info_get_error_domain")] public static extern gchar* EnumInfoGetErrorDomain(GIEnumInfo* info);
	[LinkName("g_value_info_get_value")] public static extern gint64 ValueInfoGetValue(GIValueInfo* info);
	[LinkName("g_field_info_get_flags")] public static extern GIFieldInfoFlags FieldInfoGetFlags(GIFieldInfo* info);
	[LinkName("g_field_info_get_size")] public static extern gint FieldInfoGetSize(GIFieldInfo* info);
	[LinkName("g_field_info_get_offset")] public static extern gint FieldInfoGetOffset(GIFieldInfo* info);
	[LinkName("g_field_info_get_type")] public static extern GITypeInfo* FieldInfoGetType(GIFieldInfo* info);
	[LinkName("g_field_info_get_field")] public static extern gboolean FieldInfoGetField(GIFieldInfo* field_info, gpointer mem, GIArgument* value);
	[LinkName("g_field_info_set_field")] public static extern gboolean FieldInfoSetField(GIFieldInfo* field_info, gpointer mem, GIArgument* value);
	[LinkName("g_function_info_get_symbol")] public static extern gchar* FunctionInfoGetSymbol(GIFunctionInfo* info);
	[LinkName("g_function_info_get_flags")] public static extern GIFunctionInfoFlags FunctionInfoGetFlags(GIFunctionInfo* info);
	[LinkName("g_function_info_get_property")] public static extern GIPropertyInfo* FunctionInfoGetProperty(GIFunctionInfo* info);
	[LinkName("g_function_info_get_vfunc")] public static extern GIVFuncInfo* FunctionInfoGetVfunc(GIFunctionInfo* info);
	[LinkName("g_invoke_error_quark")] public static extern GQuark NvokeErrorQuark();
}

/** GInvokeError:
 *   @G _INVOKE_ERROR_FAILED: invokation failed, unknown error.
 *   @G _INVOKE_ERROR_SYMBOL_NOT_FOUND: symbol couldn't be found in any of the
 *  libraries associated with the typelib of the function.
 *   @G _INVOKE_ERROR_ARGUMENT_MISMATCH: the arguments provided didn't match
 *  the expected arguments for the functions type signature.
 *  
 *  An error occuring while invoking a function via
 *  g_function_info_invoke().
 */
[AllowDuplicates] enum GInvokeError : c_int
{
	Failed = 0,
	SymbolNotFound = 1,
	ArgumentMismatch = 2,
}

extension GIR
{
	[LinkName("g_function_info_invoke")] public static extern gboolean FunctionInfoInvoke(GIFunctionInfo* info, GIArgument* in_args, c_int n_in_args, GIArgument* out_args, c_int n_out_args, GIArgument* return_value, GError** error);
	[LinkName("g_interface_info_get_n_prerequisites")] public static extern gint NterfaceInfoGetNPrerequisites(GIInterfaceInfo* info);
	[LinkName("g_interface_info_get_prerequisite")] public static extern GIBaseInfo* NterfaceInfoGetPrerequisite(GIInterfaceInfo* info, gint n);
	[LinkName("g_interface_info_get_n_properties")] public static extern gint NterfaceInfoGetNProperties(GIInterfaceInfo* info);
	[LinkName("g_interface_info_get_property")] public static extern GIPropertyInfo* NterfaceInfoGetProperty(GIInterfaceInfo* info, gint n);
	[LinkName("g_interface_info_get_n_methods")] public static extern gint NterfaceInfoGetNMethods(GIInterfaceInfo* info);
	[LinkName("g_interface_info_get_method")] public static extern GIFunctionInfo* NterfaceInfoGetMethod(GIInterfaceInfo* info, gint n);
	[LinkName("g_interface_info_find_method")] public static extern GIFunctionInfo* NterfaceInfoFindMethod(GIInterfaceInfo* info, gchar* name);
	[LinkName("g_interface_info_get_n_signals")] public static extern gint NterfaceInfoGetNSignals(GIInterfaceInfo* info);
	[LinkName("g_interface_info_get_signal")] public static extern GISignalInfo* NterfaceInfoGetSignal(GIInterfaceInfo* info, gint n);
	[LinkName("g_interface_info_find_signal")] public static extern GISignalInfo* NterfaceInfoFindSignal(GIInterfaceInfo* info, gchar* name);
	[LinkName("g_interface_info_get_n_vfuncs")] public static extern gint NterfaceInfoGetNVfuncs(GIInterfaceInfo* info);
	[LinkName("g_interface_info_get_vfunc")] public static extern GIVFuncInfo* NterfaceInfoGetVfunc(GIInterfaceInfo* info, gint n);
	[LinkName("g_interface_info_find_vfunc")] public static extern GIVFuncInfo* NterfaceInfoFindVfunc(GIInterfaceInfo* info, gchar* name);
	[LinkName("g_interface_info_get_n_constants")] public static extern gint NterfaceInfoGetNConstants(GIInterfaceInfo* info);
	[LinkName("g_interface_info_get_constant")] public static extern GIConstantInfo* NterfaceInfoGetConstant(GIInterfaceInfo* info, gint n);
	[LinkName("g_interface_info_get_iface_struct")] public static extern GIStructInfo* NterfaceInfoGetIfaceStruct(GIInterfaceInfo* info);
}

/** GIObjectInfoRefFunction: (skip)
 *   @object : object instance pointer
 *  
 *  Increases the reference count of an object instance.
 *  
 *  Returns: (transfer full): the object instance
 */
function void* GIObjectInfoRefFunction(void* object);

/** GIObjectInfoUnrefFunction: (skip)
 *   @object : object instance pointer
 *  
 *  Decreases the reference count of an object instance.
 */
function void GIObjectInfoUnrefFunction(void* object);

/** GIObjectInfoSetValueFunction: (skip)
 *   @value : a #GValue
 *   @object : object instance pointer
 *  
 *  Update @value and attach the object instance pointer @object to it.
 */
function void GIObjectInfoSetValueFunction(GValue* value, void* object);

/** GIObjectInfoGetValueFunction: (skip)
 *   @value : a #GValue
 *  
 *  Extract an object instance out of @value
 *  
 *  Returns: (transfer full): the object instance
 */
function void* GIObjectInfoGetValueFunction(GValue* value);

extension GIR
{
	[LinkName("g_object_info_get_type_name")] public static extern gchar* ObjectInfoGetTypeName(GIObjectInfo* info);
	[LinkName("g_object_info_get_type_init")] public static extern gchar* ObjectInfoGetTypeInit(GIObjectInfo* info);
	[LinkName("g_object_info_get_abstract")] public static extern gboolean ObjectInfoGetAbstract(GIObjectInfo* info);
	[LinkName("g_object_info_get_final")] public static extern gboolean ObjectInfoGetFinal(GIObjectInfo* info);
	[LinkName("g_object_info_get_fundamental")] public static extern gboolean ObjectInfoGetFundamental(GIObjectInfo* info);
	[LinkName("g_object_info_get_parent")] public static extern GIObjectInfo* ObjectInfoGetParent(GIObjectInfo* info);
	[LinkName("g_object_info_get_n_interfaces")] public static extern gint ObjectInfoGetNInterfaces(GIObjectInfo* info);
	[LinkName("g_object_info_get_interface")] public static extern GIInterfaceInfo* ObjectInfoGetInterface(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_get_n_fields")] public static extern gint ObjectInfoGetNFields(GIObjectInfo* info);
	[LinkName("g_object_info_get_field")] public static extern GIFieldInfo* ObjectInfoGetField(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_get_n_properties")] public static extern gint ObjectInfoGetNProperties(GIObjectInfo* info);
	[LinkName("g_object_info_get_property")] public static extern GIPropertyInfo* ObjectInfoGetProperty(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_get_n_methods")] public static extern gint ObjectInfoGetNMethods(GIObjectInfo* info);
	[LinkName("g_object_info_get_method")] public static extern GIFunctionInfo* ObjectInfoGetMethod(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_find_method")] public static extern GIFunctionInfo* ObjectInfoFindMethod(GIObjectInfo* info, gchar* name);
	[LinkName("g_object_info_find_method_using_interfaces")] public static extern GIFunctionInfo* ObjectInfoFindMethodUsingInterfaces(GIObjectInfo* info, gchar* name, GIObjectInfo** implementor);
	[LinkName("g_object_info_get_n_signals")] public static extern gint ObjectInfoGetNSignals(GIObjectInfo* info);
	[LinkName("g_object_info_get_signal")] public static extern GISignalInfo* ObjectInfoGetSignal(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_find_signal")] public static extern GISignalInfo* ObjectInfoFindSignal(GIObjectInfo* info, gchar* name);
	[LinkName("g_object_info_get_n_vfuncs")] public static extern gint ObjectInfoGetNVfuncs(GIObjectInfo* info);
	[LinkName("g_object_info_get_vfunc")] public static extern GIVFuncInfo* ObjectInfoGetVfunc(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_find_vfunc")] public static extern GIVFuncInfo* ObjectInfoFindVfunc(GIObjectInfo* info, gchar* name);
	[LinkName("g_object_info_find_vfunc_using_interfaces")] public static extern GIVFuncInfo* ObjectInfoFindVfuncUsingInterfaces(GIObjectInfo* info, gchar* name, GIObjectInfo** implementor);
	[LinkName("g_object_info_get_n_constants")] public static extern gint ObjectInfoGetNConstants(GIObjectInfo* info);
	[LinkName("g_object_info_get_constant")] public static extern GIConstantInfo* ObjectInfoGetConstant(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_get_class_struct")] public static extern GIStructInfo* ObjectInfoGetClassStruct(GIObjectInfo* info);
	[LinkName("g_object_info_get_ref_function")] public static extern c_char* ObjectInfoGetRefFunction(GIObjectInfo* info);
	[LinkName("g_object_info_get_ref_function_pointer")] public static extern GIObjectInfoRefFunction ObjectInfoGetRefFunctionPointer(GIObjectInfo* info);
	[LinkName("g_object_info_get_unref_function")] public static extern c_char* ObjectInfoGetUnrefFunction(GIObjectInfo* info);
	[LinkName("g_object_info_get_unref_function_pointer")] public static extern GIObjectInfoUnrefFunction ObjectInfoGetUnrefFunctionPointer(GIObjectInfo* info);
	[LinkName("g_object_info_get_set_value_function")] public static extern c_char* ObjectInfoGetSetValueFunction(GIObjectInfo* info);
	[LinkName("g_object_info_get_set_value_function_pointer")] public static extern GIObjectInfoSetValueFunction ObjectInfoGetSetValueFunctionPointer(GIObjectInfo* info);
	[LinkName("g_object_info_get_get_value_function")] public static extern c_char* ObjectInfoGetGetValueFunction(GIObjectInfo* info);
	[LinkName("g_object_info_get_get_value_function_pointer")] public static extern GIObjectInfoGetValueFunction ObjectInfoGetGetValueFunctionPointer(GIObjectInfo* info);
	[LinkName("g_property_info_get_flags")] public static extern GParamFlags PropertyInfoGetFlags(GIPropertyInfo* info);
	[LinkName("g_property_info_get_type")] public static extern GITypeInfo* PropertyInfoGetType(GIPropertyInfo* info);
	[LinkName("g_property_info_get_ownership_transfer")] public static extern GITransfer PropertyInfoGetOwnershipTransfer(GIPropertyInfo* info);
	[LinkName("g_property_info_get_setter")] public static extern GIFunctionInfo* PropertyInfoGetSetter(GIPropertyInfo* info);
	[LinkName("g_property_info_get_getter")] public static extern GIFunctionInfo* PropertyInfoGetGetter(GIPropertyInfo* info);
	[LinkName("g_registered_type_info_get_type_name")] public static extern gchar* RegisteredTypeInfoGetTypeName(GIRegisteredTypeInfo* info);
	[LinkName("g_registered_type_info_get_type_init")] public static extern gchar* RegisteredTypeInfoGetTypeInit(GIRegisteredTypeInfo* info);
	[LinkName("g_registered_type_info_get_g_type")] public static extern GType RegisteredTypeInfoGetGType(GIRegisteredTypeInfo* info);
	[LinkName("g_signal_info_get_flags")] public static extern GSignalFlags SignalInfoGetFlags(GISignalInfo* info);
	[LinkName("g_signal_info_get_class_closure")] public static extern GIVFuncInfo* SignalInfoGetClassClosure(GISignalInfo* info);
	[LinkName("g_signal_info_true_stops_emit")] public static extern gboolean SignalInfoTrueStopsEmit(GISignalInfo* info);
	[LinkName("g_struct_info_get_n_fields")] public static extern gint StructInfoGetNFields(GIStructInfo* info);
	[LinkName("g_struct_info_get_field")] public static extern GIFieldInfo* StructInfoGetField(GIStructInfo* info, gint n);
	[LinkName("g_struct_info_find_field")] public static extern GIFieldInfo* StructInfoFindField(GIStructInfo* info, gchar* name);
	[LinkName("g_struct_info_get_n_methods")] public static extern gint StructInfoGetNMethods(GIStructInfo* info);
	[LinkName("g_struct_info_get_method")] public static extern GIFunctionInfo* StructInfoGetMethod(GIStructInfo* info, gint n);
	[LinkName("g_struct_info_find_method")] public static extern GIFunctionInfo* StructInfoFindMethod(GIStructInfo* info, gchar* name);
	[LinkName("g_struct_info_get_size")] public static extern gsize StructInfoGetSize(GIStructInfo* info);
	[LinkName("g_struct_info_get_alignment")] public static extern gsize StructInfoGetAlignment(GIStructInfo* info);
	[LinkName("g_struct_info_is_gtype_struct")] public static extern gboolean StructInfoIsGtypeStruct(GIStructInfo* info);
	[LinkName("g_struct_info_is_foreign")] public static extern gboolean StructInfoIsForeign(GIStructInfo* info);
	[LinkName("g_struct_info_get_copy_function")] public static extern c_char* StructInfoGetCopyFunction(GIStructInfo* info);
	[LinkName("g_struct_info_get_free_function")] public static extern c_char* StructInfoGetFreeFunction(GIStructInfo* info);
	[LinkName("g_type_tag_to_string")] public static extern gchar* TypeTagToString(GITypeTag type);
	[LinkName("g_info_type_to_string")] public static extern gchar* NfoTypeToString(GIInfoType type);
	[LinkName("g_type_info_is_pointer")] public static extern gboolean TypeInfoIsPointer(GITypeInfo* info);
	[LinkName("g_type_info_get_tag")] public static extern GITypeTag TypeInfoGetTag(GITypeInfo* info);
	[LinkName("g_type_info_get_param_type")] public static extern GITypeInfo* TypeInfoGetParamType(GITypeInfo* info, gint n);
	[LinkName("g_type_info_get_interface")] public static extern GIBaseInfo* TypeInfoGetInterface(GITypeInfo* info);
	[LinkName("g_type_info_get_array_length")] public static extern gint TypeInfoGetArrayLength(GITypeInfo* info);
	[LinkName("g_type_info_get_array_fixed_size")] public static extern gint TypeInfoGetArrayFixedSize(GITypeInfo* info);
	[LinkName("g_type_info_is_zero_terminated")] public static extern gboolean TypeInfoIsZeroTerminated(GITypeInfo* info);
	[LinkName("g_type_info_get_array_type")] public static extern GIArrayType TypeInfoGetArrayType(GITypeInfo* info);
	[LinkName("g_type_info_get_storage_type")] public static extern GITypeTag TypeInfoGetStorageType(GITypeInfo* info);
	[LinkName("g_type_info_argument_from_hash_pointer")] public static extern void TypeInfoArgumentFromHashPointer(GITypeInfo* info, gpointer hash_pointer, GIArgument* arg);
	[LinkName("g_type_info_hash_pointer_from_argument")] public static extern gpointer TypeInfoHashPointerFromArgument(GITypeInfo* info, GIArgument* arg);
	[LinkName("gi_type_tag_argument_from_hash_pointer")] public static extern void GiTypeTagArgumentFromHashPointer(GITypeTag storage_type, gpointer hash_pointer, GIArgument* arg);
	[LinkName("gi_type_tag_hash_pointer_from_argument")] public static extern gpointer GiTypeTagHashPointerFromArgument(GITypeTag storage_type, GIArgument* arg);
	[LinkName("g_union_info_get_n_fields")] public static extern gint UnionInfoGetNFields(GIUnionInfo* info);
	[LinkName("g_union_info_get_field")] public static extern GIFieldInfo* UnionInfoGetField(GIUnionInfo* info, gint n);
	[LinkName("g_union_info_get_n_methods")] public static extern gint UnionInfoGetNMethods(GIUnionInfo* info);
	[LinkName("g_union_info_get_method")] public static extern GIFunctionInfo* UnionInfoGetMethod(GIUnionInfo* info, gint n);
	[LinkName("g_union_info_is_discriminated")] public static extern gboolean UnionInfoIsDiscriminated(GIUnionInfo* info);
	[LinkName("g_union_info_get_discriminator_offset")] public static extern gint UnionInfoGetDiscriminatorOffset(GIUnionInfo* info);
	[LinkName("g_union_info_get_discriminator_type")] public static extern GITypeInfo* UnionInfoGetDiscriminatorType(GIUnionInfo* info);
	[LinkName("g_union_info_get_discriminator")] public static extern GIConstantInfo* UnionInfoGetDiscriminator(GIUnionInfo* info, gint n);
	[LinkName("g_union_info_find_method")] public static extern GIFunctionInfo* UnionInfoFindMethod(GIUnionInfo* info, gchar* name);
	[LinkName("g_union_info_get_size")] public static extern gsize UnionInfoGetSize(GIUnionInfo* info);
	[LinkName("g_union_info_get_alignment")] public static extern gsize UnionInfoGetAlignment(GIUnionInfo* info);
	[LinkName("g_union_info_get_copy_function")] public static extern c_char* UnionInfoGetCopyFunction(GIUnionInfo* info);
	[LinkName("g_union_info_get_free_function")] public static extern c_char* UnionInfoGetFreeFunction(GIUnionInfo* info);
	[LinkName("g_vfunc_info_get_flags")] public static extern GIVFuncInfoFlags VfuncInfoGetFlags(GIVFuncInfo* info);
	[LinkName("g_vfunc_info_get_offset")] public static extern gint VfuncInfoGetOffset(GIVFuncInfo* info);
	[LinkName("g_vfunc_info_get_signal")] public static extern GISignalInfo* VfuncInfoGetSignal(GIVFuncInfo* info);
	[LinkName("g_vfunc_info_get_invoker")] public static extern GIFunctionInfo* VfuncInfoGetInvoker(GIVFuncInfo* info);
	[LinkName("g_vfunc_info_get_address")] public static extern gpointer VfuncInfoGetAddress(GIVFuncInfo* info, GType implementor_gtype, GError** error);
	[LinkName("g_vfunc_info_invoke")] public static extern gboolean VfuncInfoInvoke(GIVFuncInfo* info, GType implementor, GIArgument* in_args, c_int n_in_args, GIArgument* out_args, c_int n_out_args, GIArgument* return_value, GError** error);
	[LinkName("gi_get_major_version")] public static extern guint GiGetMajorVersion();
	[LinkName("gi_get_minor_version")] public static extern guint GiGetMinorVersion();
	[LinkName("gi_get_micro_version")] public static extern guint GiGetMicroVersion();
}

struct GIRepository;

struct GIRepositoryClass;

struct GIRepositoryPrivate;

/** GIRepositoryLoadFlags:
 *   @G _IREPOSITORY_LOAD_FLAG_LAZY: Lazily load the typelib.
 *  
 *  Flags that control how a typelib is loaded.
 */
[AllowDuplicates] enum GIRepositoryLoadFlags : c_int
{
	Lazy = 1 << 0,
}

extension GIR
{
	[LinkName("g_irepository_get_type")] public static extern GType RepositoryGetType();
	[LinkName("g_irepository_get_default")] public static extern GIRepository* RepositoryGetDefault();
	[LinkName("g_irepository_prepend_search_path")] public static extern void RepositoryPrependSearchPath(c_char* directory);
	[LinkName("g_irepository_prepend_library_path")] public static extern void RepositoryPrependLibraryPath(c_char* directory);
	[LinkName("g_irepository_get_search_path")] public static extern GSList* RepositoryGetSearchPath();
	[LinkName("g_irepository_load_typelib")] public static extern c_char* RepositoryLoadTypelib(GIRepository* repository, GITypelib* typelib, GIRepositoryLoadFlags flags, GError** error);
	[LinkName("g_irepository_is_registered")] public static extern gboolean RepositoryIsRegistered(GIRepository* repository, gchar* @namespace, gchar* version);
	[LinkName("g_irepository_find_by_name")] public static extern GIBaseInfo* RepositoryFindByName(GIRepository* repository, gchar* @namespace, gchar* name);
	[LinkName("g_irepository_enumerate_versions")] public static extern GList* RepositoryEnumerateVersions(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_require")] public static extern GITypelib* RepositoryRequire(GIRepository* repository, gchar* @namespace, gchar* version, GIRepositoryLoadFlags flags, GError** error);
	[LinkName("g_irepository_require_private")] public static extern GITypelib* RepositoryRequirePrivate(GIRepository* repository, gchar* typelib_dir, gchar* @namespace, gchar* version, GIRepositoryLoadFlags flags, GError** error);
	[LinkName("g_irepository_get_immediate_dependencies")] public static extern gchar** RepositoryGetImmediateDependencies(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_dependencies")] public static extern gchar** RepositoryGetDependencies(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_loaded_namespaces")] public static extern gchar** RepositoryGetLoadedNamespaces(GIRepository* repository);
	[LinkName("g_irepository_find_by_gtype")] public static extern GIBaseInfo* RepositoryFindByGtype(GIRepository* repository, GType gtype);
	[LinkName("g_irepository_get_object_gtype_interfaces")] public static extern void RepositoryGetObjectGtypeInterfaces(GIRepository* repository, GType gtype, guint* n_interfaces_out, GIInterfaceInfo*** interfaces_out);
	[LinkName("g_irepository_get_n_infos")] public static extern gint RepositoryGetNInfos(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_info")] public static extern GIBaseInfo* RepositoryGetInfo(GIRepository* repository, gchar* @namespace, gint index);
	[LinkName("g_irepository_find_by_error_domain")] public static extern GIEnumInfo* RepositoryFindByErrorDomain(GIRepository* repository, GQuark domain);
	[LinkName("g_irepository_get_typelib_path")] public static extern gchar* RepositoryGetTypelibPath(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_shared_library")] public static extern gchar* RepositoryGetSharedLibrary(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_c_prefix")] public static extern gchar* RepositoryGetCPrefix(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_version")] public static extern gchar* RepositoryGetVersion(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_option_group")] public static extern GOptionGroup* RepositoryGetOptionGroup();
	[LinkName("g_irepository_dump")] public static extern gboolean RepositoryDump(c_char* arg, GError** error);
}

/** GIRepositoryError:
 *   @G _IREPOSITORY_ERROR_TYPELIB_NOT_FOUND: the typelib could not be found.
 *   @G _IREPOSITORY_ERROR_NAMESPACE_MISMATCH: the namespace does not match the
 *  requested namespace.
 *   @G _IREPOSITORY_ERROR_NAMESPACE_VERSION_CONFLICT: the version of the
 *  typelib does not match the requested version.
 *   @G _IREPOSITORY_ERROR_LIBRARY_NOT_FOUND: the library used by the typelib
 *  could not be found.
 *  
 *  An error code used with #G_IREPOSITORY_ERROR in a #GError returned
 *  from a #GIRepository routine.
 */
[AllowDuplicates] enum GIRepositoryError : c_int
{
	TypelibNotFound = 0,
	NamespaceMismatch = 1,
	NamespaceVersionConflict = 2,
	LibraryNotFound = 3,
}

extension GIR
{
	[LinkName("g_irepository_error_quark")] public static extern GQuark RepositoryErrorQuark();
	[LinkName("gi_cclosure_marshal_generic")] public static extern void GiCclosureMarshalGeneric(GClosure* closure, GValue* return_gvalue, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
}

