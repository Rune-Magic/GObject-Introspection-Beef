/* Auto generated by https://github.com/Rune-Magic/C2Beef-Binding-Generator
 * DO NOT EDIT
 */

using GLib;
using System;
using System.Interop;

namespace GObject;

typealias GType = gsize;


struct GTypeCValue;

struct GTypePlugin;









/** GTypeClass:
 *  
 *  An opaque structure used as the base of all classes.
 */
[CRepr] struct GTypeClass
{
	public GType g_type;
}

/** GTypeInstance:
 *  
 *  An opaque structure used as the base of all type instances.
 */
[CRepr] struct GTypeInstance
{
	public GTypeClass* g_class;
}

/** GTypeInterface:
 *  
 *  An opaque structure used as the base of all interface types.
 */
[CRepr] struct GTypeInterface
{
	public GType g_type;
	public GType g_instance_type;
}

/** GTypeQuery:
 *   @type : the #GType value of the type
 *   @type _name: the name of the type
 *  
 *  `_size: the size of the class structure`
 *  
 *   @instance _size: the size of the instance structure
 *  
 *  A structure holding information for a specific type.
 *  
 *  See also: g_type_query()
 */
[CRepr] struct GTypeQuery
{
	public GType type;
	public gchar* type_name;
	public guint class_size;
	public guint instance_size;
}

/** GTypeDebugFlags:
 *   @G _TYPE_DEBUG_NONE: Print no messages
 *   @G _TYPE_DEBUG_OBJECTS: Print messages about object bookkeeping
 *   @G _TYPE_DEBUG_SIGNALS: Print messages about signal emissions
 *   @G _TYPE_DEBUG_MASK: Mask covering all debug flags
 *   @G _TYPE_DEBUG_INSTANCE_COUNT: Keep a count of instances of each type
 *  
 *  These flags used to be passed to g_type_init_with_debug_flags() which
 *  is now deprecated.
 *  
 *  If you need to enable debugging features, use the `GOBJECT_DEBUG`
 *  environment variable.
 *  
 *  Deprecated: 2.36: g_type_init() is now done automatically
 */
[AllowDuplicates] enum GTypeDebugFlags : c_int
{
	None = 0,
	Objects = 1 << 0,
	Signals = 1 << 1,
	InstanceCount = 1 << 2,
	Mask = 0x07,
}

extension GObject
{
	[LinkName("g_type_init")] public static extern void TypeInit();
	[LinkName("g_type_init_with_debug_flags")] public static extern void TypeInitWithDebugFlags(GTypeDebugFlags debug_flags);
	[LinkName("g_type_name")] public static extern gchar* TypeName(GType type);
	[LinkName("g_type_qname")] public static extern GQuark TypeQname(GType type);
	[LinkName("g_type_from_name")] public static extern GType TypeFromName(gchar* name);
	[LinkName("g_type_parent")] public static extern GType TypeParent(GType type);
	[LinkName("g_type_depth")] public static extern guint TypeDepth(GType type);
	[LinkName("g_type_next_base")] public static extern GType TypeNextBase(GType leaf_type, GType root_type);
	[LinkName("g_type_is_a")] public static extern gboolean TypeIsA(GType type, GType is_a_type);
	[LinkName("g_type_class_get")] public static extern gpointer TypeClassGet(GType type);
	[LinkName("g_type_class_ref")] public static extern gpointer TypeClassRef(GType type);
	[LinkName("g_type_class_peek")] public static extern gpointer TypeClassPeek(GType type);
	[LinkName("g_type_class_peek_static")] public static extern gpointer TypeClassPeekStatic(GType type);
	[LinkName("g_type_class_unref")] public static extern void TypeClassUnref(gpointer g_class);
	[LinkName("g_type_class_peek_parent")] public static extern gpointer TypeClassPeekParent(gpointer g_class);
	[LinkName("g_type_interface_peek")] public static extern gpointer TypeInterfacePeek(gpointer instance_class, GType iface_type);
	[LinkName("g_type_interface_peek_parent")] public static extern gpointer TypeInterfacePeekParent(gpointer g_iface);
	[LinkName("g_type_default_interface_get")] public static extern gpointer TypeDefaultInterfaceGet(GType g_type);
	[LinkName("g_type_default_interface_ref")] public static extern gpointer TypeDefaultInterfaceRef(GType g_type);
	[LinkName("g_type_default_interface_peek")] public static extern gpointer TypeDefaultInterfacePeek(GType g_type);
	[LinkName("g_type_default_interface_unref")] public static extern void TypeDefaultInterfaceUnref(gpointer g_iface);
	[LinkName("g_type_children")] public static extern GType* TypeChildren(GType type, guint* n_children);
	[LinkName("g_type_interfaces")] public static extern GType* TypeInterfaces(GType type, guint* n_interfaces);
	[LinkName("g_type_set_qdata")] public static extern void TypeSetQdata(GType type, GQuark quark, gpointer data);
	[LinkName("g_type_get_qdata")] public static extern gpointer TypeGetQdata(GType type, GQuark quark);
	[LinkName("g_type_query")] public static extern void TypeQuery(GType type, GTypeQuery* query);
	[LinkName("g_type_get_instance_count")] public static extern c_int TypeGetInstanceCount(GType type);
}

/** GBaseInitFunc:
 *   @g _class: (type GObject.TypeClass): The #GTypeClass structure to initialize
 *  
 *  A callback function used by the type system to do base initialization
 *  of the class structures of derived types.
 *  
 *  This function is called as part of the initialization process of all derived
 *  classes and should reallocate or reset all dynamic class members copied over
 *  from the parent class.
 *  
 *  For example, class members (such as strings) that are not sufficiently
 *  handled by a plain memory copy of the parent class into the derived class
 *  have to be altered. See GClassInitFunc() for a discussion of the class
 *  initialization process.
 */
function void GBaseInitFunc(gpointer g_class);

/** GBaseFinalizeFunc:
 *   @g _class: (type GObject.TypeClass): The #GTypeClass structure to finalize
 *  
 *  A callback function used by the type system to finalize those portions
 *  of a derived types class structure that were setup from the corresponding
 *  GBaseInitFunc() function.
 *  
 *  Class finalization basically works the inverse way in which class
 *  initialization is performed.
 *  
 *  See GClassInitFunc() for a discussion of the class initialization process.
 */
function void GBaseFinalizeFunc(gpointer g_class);

/** GClassInitFunc:
 *   @g _class: (type GObject.TypeClass): The #GTypeClass structure to initialize.
 *  
 *  `_data: The @class_data member supplied via the #GTypeInfo structure.`
 *  
 *  
 *  A callback function used by the type system to initialize the class
 *  of a specific type.
 *  
 *  This function should initialize all static class members.
 *  
 *  The initialization process of a class involves:
 *  
 *  - Copying common members from the parent class over to the
 *  derived class structure.
 *  - Zero initialization of the remaining members not copied
 *  over from the parent class.
 *  - Invocation of the GBaseInitFunc() initializers of all parent
 *  types and the class' type.
 *  - Invocation of the class' GClassInitFunc() initializer.
 *  
 *  Since derived classes are partially initialized through a memory copy
 *  of the parent class, the general rule is that GBaseInitFunc() and
 *  GBaseFinalizeFunc() should take care of necessary reinitialization
 *  and release of those class members that were introduced by the type
 *  that specified these GBaseInitFunc()/GBaseFinalizeFunc().
 *  GClassInitFunc() should only care about initializing static
 *  class members, while dynamic class members (such as allocated strings
 *  or reference counted resources) are better handled by a GBaseInitFunc()
 *  for this type, so proper initialization of the dynamic class members
 *  is performed for class initialization of derived types as well.
 *  
 *  An example may help to correspond the intend of the different class
 *  initializers:
 *  
 *  |[<!-- language="C" -->
 *  typedef struct {
 *  GObjectClass parent_class;
 *  gint         static_integer;
 *  gchar       *dynamic_string;
 *  } TypeAClass;
 *  static void
 *  type_a_base_class_init (TypeAClass *class)
 *  {
 *  class->dynamic_string = g_strdup ("some string");
 *  }
 *  static void
 *  type_a_base_class_finalize (TypeAClass *class)
 *  {
 *  g_free (class->dynamic_string);
 *  }
 *  static void
 *  type_a_class_init (TypeAClass *class)
 *  {
 *  class->static_integer = 42;
 *  }
 *  
 *  typedef struct {
 *  TypeAClass   parent_class;
 *  gfloat       static_float;
 *  GString     *dynamic_gstring;
 *  } TypeBClass;
 *  static void
 *  type_b_base_class_init (TypeBClass *class)
 *  {
 *  class->dynamic_gstring = g_string_new ("some other string");
 *  }
 *  static void
 *  type_b_base_class_finalize (TypeBClass *class)
 *  {
 *  g_string_free (class->dynamic_gstring);
 *  }
 *  static void
 *  type_b_class_init (TypeBClass *class)
 *  {
 *  class->static_float = 3.14159265358979323846;
 *  }
 *  ]|
 *  
 *  Initialization of TypeBClass will first cause initialization of
 *  TypeAClass (derived classes reference their parent classes, see
 *  g_type_class_ref() on this).
 *  
 *  Initialization of TypeAClass roughly involves zero-initializing its fields,
 *  then calling its GBaseInitFunc() type_a_base_class_init() to allocate
 *  its dynamic members (dynamic_string), and finally calling its GClassInitFunc()
 *  type_a_class_init() to initialize its static members (static_integer).
 *  The first step in the initialization process of TypeBClass is then
 *  a plain memory copy of the contents of TypeAClass into TypeBClass and
 *  zero-initialization of the remaining fields in TypeBClass.
 *  The dynamic members of TypeAClass within TypeBClass now need
 *  reinitialization which is performed by calling type_a_base_class_init()
 *  with an argument of TypeBClass.
 *  
 *  After that, the GBaseInitFunc() of TypeBClass, type_b_base_class_init()
 *  is called to allocate the dynamic members of TypeBClass (dynamic_gstring),
 *  and finally the GClassInitFunc() of TypeBClass, type_b_class_init(),
 *  is called to complete the initialization process with the static members
 *  (static_float).
 *  
 *  Corresponding finalization counter parts to the GBaseInitFunc() functions
 *  have to be provided to release allocated resources at class finalization
 *  time.
 */
function void GClassInitFunc(gpointer g_class, gpointer class_data);

/** GClassFinalizeFunc:
 *   @g _class: (type GObject.TypeClass): The #GTypeClass structure to finalize
 *  
 *  `_data: The @class_data member supplied via the #GTypeInfo structure`
 *  
 *  
 *  A callback function used by the type system to finalize a class.
 *  
 *  This function is rarely needed, as dynamically allocated class resources
 *  should be handled by GBaseInitFunc() and GBaseFinalizeFunc().
 *  
 *  Also, specification of a GClassFinalizeFunc() in the #GTypeInfo
 *  structure of a static type is invalid, because classes of static types
 *  will never be finalized (they are artificially kept alive when their
 *  reference count drops to zero).
 */
function void GClassFinalizeFunc(gpointer g_class, gpointer class_data);

/** GInstanceInitFunc:
 *   @instance : The instance to initialize
 *   @g _class: (type GObject.TypeClass): The class of the type the instance is
 *  created for
 *  
 *  A callback function used by the type system to initialize a new
 *  instance of a type.
 *  
 *  This function initializes all instance members and allocates any resources
 *  required by it.
 *  
 *  Initialization of a derived instance involves calling all its parent
 *  types instance initializers, so the class member of the instance
 *  is altered during its initialization to always point to the class that
 *  belongs to the type the current initializer was introduced for.
 *  
 *  The extended members of @instance are guaranteed to have been filled with
 *  zeros before this function is called.
 */
function void GInstanceInitFunc(GTypeInstance* instance, gpointer g_class);

/** GInterfaceInitFunc:
 *   @g _iface: (type GObject.TypeInterface): The interface structure to initialize
 *   @iface _data: The
 *  `_data supplied via the #GInterfaceInfo structure`
 *  
 *  
 *  A callback function used by the type system to initialize a new
 *  interface.
 *  
 *  This function should initialize all internal data and* allocate any
 *  resources required by the interface.
 *  
 *  The members of @iface _data are guaranteed to have been filled with
 *  zeros before this function is called.
 */
function void GInterfaceInitFunc(gpointer g_iface, gpointer iface_data);

/** GInterfaceFinalizeFunc:
 *   @g _iface: (type GObject.TypeInterface): The interface structure to finalize
 *   @iface _data: The
 *  `_data supplied via the #GInterfaceInfo structure`
 *  
 *  
 *  A callback function used by the type system to finalize an interface.
 *  
 *  This function should destroy any internal data and release any resources
 *  allocated by the corresponding GInterfaceInitFunc() function.
 */
function void GInterfaceFinalizeFunc(gpointer g_iface, gpointer iface_data);

/** GTypeClassCacheFunc:
 *   @cache _data: data that was given to the g_type_add_class_cache_func() call
 *   @g _class: (type GObject.TypeClass): The #GTypeClass structure which is
 *  unreferenced
 *  
 *  A callback function which is called when the reference count of a class
 *  drops to zero.
 *  
 *  It may use g_type_class_ref() to prevent the class from being freed. You
 *  should not call g_type_class_unref() from a #GTypeClassCacheFunc function
 *  to prevent infinite recursion, use g_type_class_unref_uncached() instead.
 *  
 *  The functions have to check the class id passed in to figure
 *  whether they actually want to cache the class of this type, since all
 *  classes are routed through the same #GTypeClassCacheFunc chain.
 *  
 *  Returns: %TRUE to stop further #GTypeClassCacheFuncs from being
 *  called, %FALSE to continue
 */
function gboolean GTypeClassCacheFunc(gpointer cache_data, GTypeClass* g_class);

/** GTypeInterfaceCheckFunc:
 *   @check _data: data passed to g_type_add_interface_check()
 *   @g _iface: (type GObject.TypeInterface): the interface that has been
 *  initialized
 *  
 *  A callback called after an interface vtable is initialized.
 *  
 *  See g_type_add_interface_check().
 *  
 *  Since: 2.4
 */
function void GTypeInterfaceCheckFunc(gpointer check_data, gpointer g_iface);

/** GTypeFundamentalFlags:
 *   @G _TYPE_FLAG_CLASSED: Indicates a classed type
 *   @G _TYPE_FLAG_INSTANTIATABLE: Indicates an instantiatable type (implies classed)
 *   @G _TYPE_FLAG_DERIVABLE: Indicates a flat derivable type
 *   @G _TYPE_FLAG_DEEP_DERIVABLE: Indicates a deep derivable type (implies derivable)
 *  
 *  Bit masks used to check or determine specific characteristics of a
 *  fundamental type.
 */
[AllowDuplicates] enum GTypeFundamentalFlags : c_int
{
	LagClassed = (1 << 0),
	LagInstantiatable = (1 << 1),
	LagDerivable = (1 << 2),
	LagDeepDerivable = (1 << 3),
}

/** GTypeFlags:
 *   @G _TYPE_FLAG_NONE: No special flags. Since: 2.74
 *   @G _TYPE_FLAG_ABSTRACT: Indicates an abstract type. No instances can be
 *  created for an abstract type
 *   @G _TYPE_FLAG_VALUE_ABSTRACT: Indicates an abstract value type, i.e. a type
 *  that introduces a value table, but can't be used for
 *  g_value_init()
 *   @G _TYPE_FLAG_FINAL: Indicates a final type. A final type is a non-derivable
 *  leaf node in a deep derivable type hierarchy tree. Since: 2.70
 *   @G _TYPE_FLAG_DEPRECATED: The type is deprecated and may be removed in a
 *  future version. A warning will be emitted if it is instantiated while
 *  running with `G_ENABLE_DIAGNOSTIC=1`. Since 2.76
 *  
 *  Bit masks used to check or determine characteristics of a type.
 */
[AllowDuplicates] enum GTypeFlags : c_int
{
	None = 0,
	Abstract = (1 << 4),
	ValueAbstract = (1 << 5),
	Final = (1 << 6),
	Deprecated = (1 << 7),
}

/** GTypeInfo:
 *  
 *  `_size: Size of the class structure (required for interface, classed and instantiatable types)`
 *  
 *   @base _init: Location of the base initialization function (optional)
 *   @base _finalize: Location of the base finalization function (optional)
 *  
 *  `_init: Location of the class initialization function for`
 *  
 *  classed and instantiatable types. Location of the default vtable
 *  initialization function for interface types. (optional) This function
 *  is used both to fill in virtual functions in the class or default vtable,
 *  and to do type-specific setup such as registering signals and object
 *  properties.
 *  
 *  `_finalize: Location of the class finalization function for`
 *  
 *  classed and instantiatable types. Location of the default vtable
 *  finalization function for interface types. (optional)
 *  
 *  `_data: User-supplied data passed to the class init/finalize functions`
 *  
 *   @instance _size: Size of the instance (object) structure (required for instantiatable types only)
 *   @n _preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10 this field is ignored.
 *   @instance _init: Location of the instance initialization function (optional, for instantiatable types only)
 *   @value _table: A #GTypeValueTable function table for generic handling of GValues
 *  of this type (usually only useful for fundamental types)
 *  
 *  This structure is used to provide the type system with the information
 *  required to initialize and destruct (finalize) a type's class and
 *  its instances.
 *  
 *  The initialized structure is passed to the g_type_register_static() function
 *  (or is copied into the provided #GTypeInfo structure in the
 *  g_type_plugin_complete_type_info()). The type system will perform a deep
 *  copy of this structure, so its memory does not need to be persistent
 *  across invocation of g_type_register_static().
 */
[CRepr] struct GTypeInfo
{
	public guint16 class_size;
	public GBaseInitFunc base_init;
	public GBaseFinalizeFunc base_finalize;
	public GClassInitFunc class_init;
	public GClassFinalizeFunc class_finalize;
	public gconstpointer class_data;
	public guint16 instance_size;
	public guint16 n_preallocs;
	public GInstanceInitFunc instance_init;
	public GTypeValueTable* value_table;
}

/** GTypeFundamentalInfo:
 *   @type _flags: #GTypeFundamentalFlags describing the characteristics of the fundamental type
 *  
 *  A structure that provides information to the type system which is
 *  used specifically for managing fundamental types.
 */
[CRepr] struct GTypeFundamentalInfo
{
	public GTypeFundamentalFlags type_flags;
}

/** GInterfaceInfo:
 *  
 *  `_init: location of the interface initialization function`
 *  
 *  
 *  `_finalize: location of the interface finalization function`
 *  
 *  
 *  `_data: user-supplied data passed to the interface init/finalize functions`
 *  
 *  
 *  A structure that provides information to the type system which is
 *  used specifically for managing interface types.
 */
[CRepr] struct GInterfaceInfo
{
	public GInterfaceInitFunc interface_init;
	public GInterfaceFinalizeFunc interface_finalize;
	public gpointer interface_data;
}

/** GTypeValueInitFunc:
 *   @value : the value to initialize
 *  
 *  Initializes the value contents by setting the fields of the `value->data`
 *  array.
 *  
 *  The data array of the #GValue passed into this function was zero-filled
 *  with `memset()`, so no care has to be taken to free any old contents.
 *  For example, in the case of a string value that may never be %NULL, the
 *  implementation might look like:
 *  
 *  |[<!-- language="C" -->
 *  value->data[0].v_pointer = g_strdup ("");
 *  ]|
 *  
 *  Since: 2.78
 */
function void GTypeValueInitFunc(GValue* value);

/** GTypeValueFreeFunc:
 *   @value : the value to free
 *  
 *  Frees any old contents that might be left in the `value->data` array of
 *  the given value.
 *  
 *  No resources may remain allocated through the #GValue contents after this
 *  function returns. E.g. for our above string type:
 *  
 *  |[<!-- language="C" -->
 *  // only free strings without a specific flag for static storage
 *  if (!(value->data[1].v_uint &G_VALUE_NOCOPY_CONTENTS))
 *  g_free (value->data[0].v_pointer);
 *  ]|
 *  
 *  Since: 2.78
 */
function void GTypeValueFreeFunc(GValue* value);

/** GTypeValueCopyFunc:
 *   @src _value: the value to copy
 *  @test _value: (out): the location of the copy
 *  
 *  Copies the content of a #GValue into another.
 *  
 *  The@test _value is a #GValue with zero-filled data section and @src _value
 *        is a properly initialized #GValue of same type, or derived type.
 *  
 *  The purpose of this function is to copy the contents of @src _value
 *  into@test _value in a way, that even after @src _value has been freed, the
 *        contents of@test _value remain valid. String type example:
 *  
 *  |[<!-- language="C" -->
 *  dest_value->data[0].v_pointer = g_strdup (src_value->data[0].v_pointer);
 *  ]|
 *  
 *  Since: 2.78
 */
function void GTypeValueCopyFunc(GValue* src_value, GValue* dest_value);

/** GTypeValuePeekPointerFunc:
 *   @value : the value to peek
 *  
 *  If the value contents fit into a pointer, such as objects or strings,
 *  return this pointer, so the caller can peek at the current contents.
 *  
 *  To extend on our above string example:
 *  
 *  |[<!-- language="C" -->
 *  return value->data[0].v_pointer;
 *  ]|
 *  
 *  Returns: (transfer none): a pointer to the value contents
 *  
 *  Since: 2.78
 */
function gpointer GTypeValuePeekPointerFunc(GValue* value);

/** GTypeValueCollectFunc:
 *   @value : the value to initialize
 *   @n _collect_values: the number of collected values
 *   @collect _values: (array length=n_collect_values): the collected values
 *   @collect _flags: optional flags
 *  
 *  This function is responsible for converting the values collected from
 *  a variadic argument list into contents suitable for storage in a #GValue.
 *  
 *  This function should setup @value similar to #GTypeValueInitFunc; e.g.
 *  for a string value that does not allow `NULL` pointers, it needs to either
 *  emit an error, or do an implicit conversion by storing an empty string.
 *  
 *  The @value passed in to this function has a zero-filled data array, so
 *  just like for #GTypeValueInitFunc it is guaranteed to not contain any old
 *  contents that might need freeing.
 *  
 *  The @n _collect_values argument is the string length of the `collect_format`
 *  field of #GTypeValueTable, and `collect_values` is an array of #GTypeCValue
 *  with length of @n _collect_values, containing the collected values according
 *  to `collect_format`.
 *  
 *  The @collect _flags argument provided as a hint by the caller. It may
 *  contain the flag %G_VALUE_NOCOPY_CONTENTS indicating that the collected
 *  value contents may be considered ‘static’ for the duration of the @value
 *  lifetime. Thus an extra copy of the contents stored in @collect _values is
 *  not required for assignment to @value .
 *  
 *  For our above string example, we continue with:
 *  
 *  |[<!-- language="C" -->
 *  if (!collect_values[0].v_pointer)
 *  value->data[0].v_pointer = g_strdup ("");
 *  else if (collect_flags &G_VALUE_NOCOPY_CONTENTS)
 *  {
 *  value->data[0].v_pointer = collect_values[0].v_pointer;
 *  // keep a flag for the value_free() implementation to not free this string
 *  value->data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;
 *  }
 *  else
 *  value->data[0].v_pointer = g_strdup (collect_values[0].v_pointer);
 *  return NULL;
 *  ]|
 *  
 *  It should be noted, that it is generally a bad idea to follow the
 *  %G_VALUE_NOCOPY_CONTENTS hint for reference counted types. Due to
 *  reentrancy requirements and reference count assertions performed
 *  by the signal emission code, reference counts should always be
 *  incremented for reference counted contents stored in the `value->data`
 *  array. To deviate from our string example for a moment, and taking
 *  a look at an exemplary implementation for `GTypeValueTable.collect_value()`
 *  of `GObject`:
 *  
 *  |[<!-- language="C" -->
 *  GObject *object = G_OBJECT (collect_values[0].v_pointer);
 *  g_return_val_if_fail (object != NULL,
 *  g_strdup_printf ("Object %p passed as invalid NULL pointer", object));
 *  // never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types
 *  value->data[0].v_pointer = g_object_ref (object);
 *  return NULL;
 *  ]|
 *  
 *  The reference count for valid objects is always incremented, regardless
 *  of `collect_flags`. For invalid objects, the example returns a newly
 *  allocated string without altering `value`.
 *  
 *  Upon success, `collect_value()` needs to return `NULL`. If, however,
 *  an error condition occurred, `collect_value()` should return a newly
 *  allocated string containing an error diagnostic.
 *  
 *  The calling code makes no assumptions about the `value` contents being
 *  valid upon error returns, `value` is simply thrown away without further
 *  freeing. As such, it is a good idea to not allocate `GValue` contents
 *  prior to returning an error; however, `collect_values()` is not obliged
 *  to return a correctly setup @value for error returns, simply because
 *  any non-`NULL` return is considered a fatal programming error, and
 *  further program behaviour is undefined.
 *  
 *  Returns: (transfer full) (nullable): `NULL` on success, otherwise a
 *  newly allocated error string on failure
 *  
 *  Since: 2.78
 */
function gchar* GTypeValueCollectFunc(GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags);

/** GTypeValueLCopyFunc:
 *   @value : the value to lcopy
 *   @n _collect_values: the number of collected values
 *   @collect _values: (array length=n_collect_values): the collected
 *  locations for storage
 *   @collect _flags: optional flags
 *  
 *  This function is responsible for storing the `value`
 *  contents into arguments passed through a variadic argument list which
 *  got collected into `collect_values` according to `lcopy_format`.
 *  
 *  The `n_collect_values` argument equals the string length of
 *  `lcopy_format`, and `collect_flags` may contain %G_VALUE_NOCOPY_CONTENTS.
 *  
 *  In contrast to #GTypeValueCollectFunc, this function is obliged to always
 *  properly support %G_VALUE_NOCOPY_CONTENTS.
 *  
 *  Similar to #GTypeValueCollectFunc the function may prematurely abort by
 *  returning a newly allocated string describing an error condition. To
 *  complete the string example:
 *  
 *  |[<!-- language="C" -->
 *  gchar **string_p = collect_values[0].v_pointer;
 *  g_return_val_if_fail (string_p != NULL,
 *  g_strdup ("string location passed as NULL"));
 *  
 *  if (collect_flags &G_VALUE_NOCOPY_CONTENTS)
 *  *string_p = value->data[0].v_pointer;
 *  else
 *  *string_p = g_strdup (value->data[0].v_pointer);
 *  ]|
 *  
 *  And an illustrative version of this function for reference-counted
 *  types:
 *  
 *  |[<!-- language="C" -->
 *  GObject **object_p = collect_values[0].v_pointer;
 *  g_return_val_if_fail (object_p != NULL,
 *  g_strdup ("object location passed as NULL"));
 *  
 *  if (value->data[0].v_pointer == NULL)
 *  *object_p = NULL;
 *  else if (collect_flags &G_VALUE_NOCOPY_CONTENTS) // always honour
 *  *object_p = value->data[0].v_pointer;
 *  else
 *  *object_p = g_object_ref (value->data[0].v_pointer);
 *  
 *  return NULL;
 *  ]|
 *  
 *  Returns: (transfer full) (nullable): `NULL` on success, otherwise
 *  a newly allocated error string on failure
 *  
 *  Since: 2.78
 */
function gchar* GTypeValueLCopyFunc(GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags);

/** GTypeValueTable:
 *   @value _init: Function to initialize a GValue
 *   @value _free: Function to free a GValue
 *   @value _copy: Function to copy a GValue
 *   @value _peek_pointer: Function to peek the contents of a GValue if they fit
 *  into a pointer
 *   @collect _format: A string format describing how to collect the contents of
 *  this value bit-by-bit. Each character in the format represents
 *  an argument to be collected, and the characters themselves indicate
 *  the type of the argument. Currently supported arguments are:
 *  
 *  - `'i'`: Integers, passed as `collect_values[].v_int`
 *  - `'l'`: Longs, passed as `collect_values[].v_long`
 *  - `'d'`: Doubles, passed as `collect_values[].v_double`
 *  - `'p'`: Pointers, passed as `collect_values[].v_pointer`
 *  
 *  It should be noted that for variable argument list construction,
 *  ANSI C promotes every type smaller than an integer to an int, and
 *  floats to doubles. So for collection of short int or char, `'i'`
 *  needs to be used, and for collection of floats `'d'`.
 *   @collect _value: Function to initialize a GValue from the values
 *  collected from variadic arguments
 *   @lcopy _format: Format description of the arguments to collect for @lcopy _value,
 *  analogous to @collect _format. Usually,@lcopy _format string consists
 *  only of `'p'`s to provide lcopy_value() with pointers to storage locations.
 *   @lcopy _value: Function to store the contents of a value into the
 *  locations collected from variadic arguments
 *  
 *  The #GTypeValueTable provides the functions required by the #GValue
 *  implementation, to serve as a container for values of a type.
 */
[CRepr] struct GTypeValueTable
{
	public GTypeValueInitFunc value_init;
	public GTypeValueFreeFunc value_free;
	public GTypeValueCopyFunc value_copy;
	public GTypeValuePeekPointerFunc value_peek_pointer;
	public gchar* collect_format;
	public GTypeValueCollectFunc collect_value;
	public gchar* lcopy_format;
	public GTypeValueLCopyFunc lcopy_value;
}

extension GObject
{
	[LinkName("g_type_register_static")] public static extern GType TypeRegisterStatic(GType parent_type, gchar* type_name, GTypeInfo* info, GTypeFlags flags);
	[LinkName("g_type_register_static_simple")] public static extern GType TypeRegisterStaticSimple(GType parent_type, gchar* type_name, guint class_size, GClassInitFunc class_init, guint instance_size, GInstanceInitFunc instance_init, GTypeFlags flags);
	[LinkName("g_type_register_dynamic")] public static extern GType TypeRegisterDynamic(GType parent_type, gchar* type_name, GTypePlugin* plugin, GTypeFlags flags);
	[LinkName("g_type_register_fundamental")] public static extern GType TypeRegisterFundamental(GType type_id, gchar* type_name, GTypeInfo* info, GTypeFundamentalInfo* finfo, GTypeFlags flags);
	[LinkName("g_type_add_interface_static")] public static extern void TypeAddInterfaceStatic(GType instance_type, GType interface_type, GInterfaceInfo* info);
	[LinkName("g_type_add_interface_dynamic")] public static extern void TypeAddInterfaceDynamic(GType instance_type, GType interface_type, GTypePlugin* plugin);
	[LinkName("g_type_interface_add_prerequisite")] public static extern void TypeInterfaceAddPrerequisite(GType interface_type, GType prerequisite_type);
	[LinkName("g_type_interface_prerequisites")] public static extern GType* TypeInterfacePrerequisites(GType interface_type, guint* n_prerequisites);
	[LinkName("g_type_interface_instantiatable_prerequisite")] public static extern GType TypeInterfaceInstantiatablePrerequisite(GType interface_type);
	[LinkName("g_type_class_add_private")] public static extern void TypeClassAddPrivate(gpointer g_class, gsize private_size);
	[LinkName("g_type_add_instance_private")] public static extern gint TypeAddInstancePrivate(GType class_type, gsize private_size);
	[LinkName("g_type_instance_get_private")] public static extern gpointer TypeInstanceGetPrivate(GTypeInstance* instance, GType private_type);
	[LinkName("g_type_class_adjust_private_offset")] public static extern void TypeClassAdjustPrivateOffset(gpointer g_class, gint* private_size_or_offset);
	[LinkName("g_type_add_class_private")] public static extern void TypeAddClassPrivate(GType class_type, gsize private_size);
	[LinkName("g_type_class_get_private")] public static extern gpointer TypeClassGetPrivate(GTypeClass* klass, GType private_type);
	[LinkName("g_type_class_get_instance_private_offset")] public static extern gint TypeClassGetInstancePrivateOffset(gpointer g_class);
	[LinkName("g_type_ensure")] public static extern void TypeEnsure(GType type);
	[LinkName("g_type_get_type_registration_serial")] public static extern guint TypeGetTypeRegistrationSerial();
	[LinkName("g_type_get_plugin")] public static extern GTypePlugin* TypeGetPlugin(GType type);
	[LinkName("g_type_interface_get_plugin")] public static extern GTypePlugin* TypeInterfaceGetPlugin(GType instance_type, GType interface_type);
	[LinkName("g_type_fundamental_next")] public static extern GType TypeFundamentalNext();
	[LinkName("g_type_fundamental")] public static extern GType TypeFundamental(GType type_id);
	[LinkName("g_type_create_instance")] public static extern GTypeInstance* TypeCreateInstance(GType type);
	[LinkName("g_type_free_instance")] public static extern void TypeFreeInstance(GTypeInstance* instance);
	[LinkName("g_type_add_class_cache_func")] public static extern void TypeAddClassCacheFunc(gpointer cache_data, GTypeClassCacheFunc cache_func);
	[LinkName("g_type_remove_class_cache_func")] public static extern void TypeRemoveClassCacheFunc(gpointer cache_data, GTypeClassCacheFunc cache_func);
	[LinkName("g_type_class_unref_uncached")] public static extern void TypeClassUnrefUncached(gpointer g_class);
	[LinkName("g_type_add_interface_check")] public static extern void TypeAddInterfaceCheck(gpointer check_data, GTypeInterfaceCheckFunc check_func);
	[LinkName("g_type_remove_interface_check")] public static extern void TypeRemoveInterfaceCheck(gpointer check_data, GTypeInterfaceCheckFunc check_func);
	[LinkName("g_type_value_table_peek")] public static extern GTypeValueTable* TypeValueTablePeek(GType type);
	[LinkName("g_type_check_instance")] public static extern gboolean TypeCheckInstance(GTypeInstance* instance);
	[LinkName("g_type_check_instance_cast")] public static extern GTypeInstance* TypeCheckInstanceCast(GTypeInstance* instance, GType iface_type);
	[LinkName("g_type_check_instance_is_a")] public static extern gboolean TypeCheckInstanceIsA(GTypeInstance* instance, GType iface_type);
	[LinkName("g_type_check_instance_is_fundamentally_a")] public static extern gboolean TypeCheckInstanceIsFundamentallyA(GTypeInstance* instance, GType fundamental_type);
	[LinkName("g_type_check_class_cast")] public static extern GTypeClass* TypeCheckClassCast(GTypeClass* g_class, GType is_a_type);
	[LinkName("g_type_check_class_is_a")] public static extern gboolean TypeCheckClassIsA(GTypeClass* g_class, GType is_a_type);
	[LinkName("g_type_check_is_value_type")] public static extern gboolean TypeCheckIsValueType(GType type);
	[LinkName("g_type_check_value")] public static extern gboolean TypeCheckValue(GValue* value);
	[LinkName("g_type_check_value_holds")] public static extern gboolean TypeCheckValueHolds(GValue* value, GType type);
	[LinkName("g_type_test_flags")] public static extern gboolean TypeTestFlags(GType type, guint flags);
	[LinkName("g_type_name_from_instance")] public static extern gchar* TypeNameFromInstance(GTypeInstance* instance);
	[LinkName("g_type_name_from_class")] public static extern gchar* TypeNameFromClass(GTypeClass* g_class);
}

/** GValueTransform:
 *   @src _value: Source value.
 *  @test _value: Target value.
 *  
 *  The type of value transformation functions which can be registered with
 *  g_value_register_transform_func().
 *  
 *  @test _value will be initialized to the correct destination type.
 */
function void GValueTransform(GValue* src_value, GValue* dest_value);

extension GObject
{
	[LinkName("g_value_init")] public static extern GValue* ValueInit(GValue* value, GType g_type);
	[LinkName("g_value_copy")] public static extern void ValueCopy(GValue* src_value, GValue* dest_value);
	[LinkName("g_value_reset")] public static extern GValue* ValueReset(GValue* value);
	[LinkName("g_value_unset")] public static extern void ValueUnset(GValue* value);
	[LinkName("g_value_set_instance")] public static extern void ValueSetInstance(GValue* value, gpointer instance);
	[LinkName("g_value_init_from_instance")] public static extern void ValueInitFromInstance(GValue* value, gpointer instance);
	[LinkName("g_value_fits_pointer")] public static extern gboolean ValueFitsPointer(GValue* value);
	[LinkName("g_value_peek_pointer")] public static extern gpointer ValuePeekPointer(GValue* value);
	[LinkName("g_value_type_compatible")] public static extern gboolean ValueTypeCompatible(GType src_type, GType dest_type);
	[LinkName("g_value_type_transformable")] public static extern gboolean ValueTypeTransformable(GType src_type, GType dest_type);
	[LinkName("g_value_transform")] public static extern gboolean ValueTransform(GValue* src_value, GValue* dest_value);
	[LinkName("g_value_register_transform_func")] public static extern void ValueRegisterTransformFunc(GType src_type, GType dest_type, GValueTransform transform_func);
}

/** GParamFlags:
 *   @G _PARAM_READABLE: the parameter is readable
 *   @G _PARAM_WRITABLE: the parameter is writable
 *   @G _PARAM_READWRITE: alias for %G_PARAM_READABLE | %G_PARAM_WRITABLE
 *   @G _PARAM_CONSTRUCT: the parameter will be set upon object construction.
 *  See [vfunc @Object .constructed] for more details
 *   @G _PARAM_CONSTRUCT_ONLY: the parameter can only be set upon object construction.
 *  See [vfunc @Object .constructed] for more details
 *   @G _PARAM_LAX_VALIDATION: upon parameter conversion (see g_param_value_convert())
 *  strict validation is not required
 *   @G _PARAM_STATIC_NAME: the string used as name when constructing the
 *  parameter is guaranteed to remain valid and
 *  unmodified for the lifetime of the parameter.
 *  Since 2.8
 *   @G _PARAM_STATIC_NICK: the string used as nick when constructing the
 *  parameter is guaranteed to remain valid and
 *  unmmodified for the lifetime of the parameter.
 *  Since 2.8
 *   @G _PARAM_STATIC_BLURB: the string used as blurb when constructing the
 *  parameter is guaranteed to remain valid and
 *  unmodified for the lifetime of the parameter.
 *  Since 2.8
 *   @G _PARAM_EXPLICIT_NOTIFY: calls to g_object_set_property() for this
 *  property will not automatically result in a "notify" signal being
 *  emitted: the implementation must call g_object_notify() themselves
 *  in case the property actually changes.  Since: 2.42.
 *   @G _PARAM_PRIVATE: internal
 *   @G _PARAM_DEPRECATED: the parameter is deprecated and will be removed
 *  in a future version. A warning will be generated if it is used
 *  while running with G_ENABLE_DIAGNOSTIC=1.
 *  Since 2.26
 *  
 *  Through the #GParamFlags flag values, certain aspects of parameters
 *  can be configured.
 *  
 *  See also: %G_PARAM_STATIC_STRINGS
 */
[AllowDuplicates] enum GParamFlags : c_int
{
	Readable = 1 << 0,
	Writable = 1 << 1,
	Readwrite = (Readable | Writable),
	Construct = 1 << 2,
	ConstructOnly = 1 << 3,
	LaxValidation = 1 << 4,
	StaticName = 1 << 5,
	Private = StaticName,
	StaticNick = 1 << 6,
	StaticBlurb = 1 << 7,
	ExplicitNotify = 1 << 30,
	Deprecated = -2147483648 /* (int)(1u << 31) */,
}




struct GParamSpecPool;

[CRepr] struct GParamSpec
{
	public GTypeInstance g_type_instance;
	public gchar* name;
	public GParamFlags flags;
	public GType value_type;
	public GType owner_type;
	public gchar* nick;
	public gchar* blurb;
	public GData* qdata;
	public guint ref_count;
	public guint param_id;
}

/** GParamSpecClass:
 *   @g _type_class: the parent class
 *   @value _type: the #GValue type for this parameter
 *   @finalize : The instance finalization function (optional), should chain
 *  up to the finalize method of the parent class.
 *   @value _set_default: Resets a @value to the default value for this type
 *  (recommended, the default is g_value_reset()), see
 *  g_param_value_set_default().
 *   @value _validate: Ensures that the contents of @value comply with the
 *  specifications set out by this type (optional), see
 *  g_param_value_validate().
 *   @values _cmp: Compares @value1 with @value2 according to this type
 *  (recommended, the default is memcmp()), see g_param_values_cmp().
 *   @value _is_valid: Checks if contents of @value comply with the specifications
 *  set out by this type, without modifying the value. This vfunc is optional.
 *  If it isn't set, GObject will use @value _validate. Since 2.74
 *  
 *  The class structure for the GParamSpec type.
 *  Normally, GParamSpec classes are filled by
 *  g_param_type_register_static().
 */
[CRepr] struct GParamSpecClass
{
	public GTypeClass g_type_class;
	public GType value_type;
	public function void(GParamSpec*) finalize;
	public function void(GParamSpec*, GValue*) value_set_default;
	public function gboolean(GParamSpec*, GValue*) value_validate;
	public function gint(GParamSpec*, GValue*, GValue*) values_cmp;
	public function gboolean(GParamSpec*, GValue*) value_is_valid;
	public gpointer[3] dummy;
}

/** GParameter:
 *  
 *  `: the parameter name`
 *  
 *   @value : the parameter value
 *  
 *  The GParameter struct is an auxiliary structure used
 *  to hand parameter name/value pairs to g_object_newv().
 *  
 *  Deprecated: 2.54: This type is not introspectable.
 */
[CRepr] struct GParameter
{
	public gchar* name;
	public GValue value;
}

extension GObject
{
	[LinkName("g_param_spec_ref")] public static extern GParamSpec* ParamSpecRef(GParamSpec* pspec);
	[LinkName("g_param_spec_unref")] public static extern void ParamSpecUnref(GParamSpec* pspec);
	[LinkName("g_param_spec_sink")] public static extern void ParamSpecSink(GParamSpec* pspec);
	[LinkName("g_param_spec_ref_sink")] public static extern GParamSpec* ParamSpecRefSink(GParamSpec* pspec);
	[LinkName("g_param_spec_get_qdata")] public static extern gpointer ParamSpecGetQdata(GParamSpec* pspec, GQuark quark);
	[LinkName("g_param_spec_set_qdata")] public static extern void ParamSpecSetQdata(GParamSpec* pspec, GQuark quark, gpointer data);
	[LinkName("g_param_spec_set_qdata_full")] public static extern void ParamSpecSetQdataFull(GParamSpec* pspec, GQuark quark, gpointer data, GDestroyNotify destroy);
	[LinkName("g_param_spec_steal_qdata")] public static extern gpointer ParamSpecStealQdata(GParamSpec* pspec, GQuark quark);
	[LinkName("g_param_spec_get_redirect_target")] public static extern GParamSpec* ParamSpecGetRedirectTarget(GParamSpec* pspec);
	[LinkName("g_param_value_set_default")] public static extern void ParamValueSetDefault(GParamSpec* pspec, GValue* value);
	[LinkName("g_param_value_defaults")] public static extern gboolean ParamValueDefaults(GParamSpec* pspec, GValue* value);
	[LinkName("g_param_value_validate")] public static extern gboolean ParamValueValidate(GParamSpec* pspec, GValue* value);
	[LinkName("g_param_value_is_valid")] public static extern gboolean ParamValueIsValid(GParamSpec* pspec, GValue* value);
	[LinkName("g_param_value_convert")] public static extern gboolean ParamValueConvert(GParamSpec* pspec, GValue* src_value, GValue* dest_value, gboolean strict_validation);
	[LinkName("g_param_values_cmp")] public static extern gint ParamValuesCmp(GParamSpec* pspec, GValue* value1, GValue* value2);
	[LinkName("g_param_spec_get_name")] public static extern gchar* ParamSpecGetName(GParamSpec* pspec);
	[LinkName("g_param_spec_get_nick")] public static extern gchar* ParamSpecGetNick(GParamSpec* pspec);
	[LinkName("g_param_spec_get_blurb")] public static extern gchar* ParamSpecGetBlurb(GParamSpec* pspec);
	[LinkName("g_value_set_param")] public static extern void ValueSetParam(GValue* value, GParamSpec* param);
	[LinkName("g_value_get_param")] public static extern GParamSpec* ValueGetParam(GValue* value);
	[LinkName("g_value_dup_param")] public static extern GParamSpec* ValueDupParam(GValue* value);
	[LinkName("g_value_take_param")] public static extern void ValueTakeParam(GValue* value, GParamSpec* param);
	[LinkName("g_value_set_param_take_ownership")] public static extern void ValueSetParamTakeOwnership(GValue* value, GParamSpec* param);
	[LinkName("g_param_spec_get_default_value")] public static extern GValue* ParamSpecGetDefaultValue(GParamSpec* pspec);
	[LinkName("g_param_spec_get_name_quark")] public static extern GQuark ParamSpecGetNameQuark(GParamSpec* pspec);
}


/** GParamSpecTypeInfo:
 *   @instance _size: Size of the instance (object) structure.
 *   @n _preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.
 *   @instance _init: Location of the instance initialization function (optional).
 *   @value _type: The #GType of values conforming to this #GParamSpec
 *   @finalize : The instance finalization function (optional).
 *   @value _set_default: Resets a @value to the default value for @pspec 
 *  (recommended, the default is g_value_reset()), see
 *  g_param_value_set_default().
 *   @value _validate: Ensures that the contents of @value comply with the
 *  specifications set out by @pspec (optional), see
 *  g_param_value_validate().
 *   @values _cmp: Compares @value1 with @value2 according to @pspec 
 *  (recommended, the default is memcmp()), see g_param_values_cmp().
 *  
 *  This structure is used to provide the type system with the information
 *  required to initialize and destruct (finalize) a parameter's class and
 *  instances thereof.
 *  
 *  The initialized structure is passed to the g_param_type_register_static()
 *  The type system will perform a deep copy of this structure, so its memory
 *  does not need to be persistent across invocation of
 *  g_param_type_register_static().
 */
[CRepr] struct GParamSpecTypeInfo
{
	public guint16 instance_size;
	public guint16 n_preallocs;
	public function void(GParamSpec*) instance_init;
	public GType value_type;
	public function void(GParamSpec*) finalize;
	public function void(GParamSpec*, GValue*) value_set_default;
	public function gboolean(GParamSpec*, GValue*) value_validate;
	public function gint(GParamSpec*, GValue*, GValue*) values_cmp;
}

extension GObject
{
	[LinkName("g_param_type_register_static")] public static extern GType ParamTypeRegisterStatic(gchar* name, GParamSpecTypeInfo* pspec_info);
	[LinkName("g_param_spec_is_valid_name")] public static extern gboolean ParamSpecIsValidName(gchar* name);
}

static
{
	[LinkName("_g_param_type_register_static_constant")] public static extern GType GParamTypeRegisterStaticConstant(gchar* name, GParamSpecTypeInfo* pspec_info, GType opt_type);
}

extension GObject
{
	[LinkName("g_param_spec_internal")] public static extern gpointer ParamSpecInternal(GType param_type, gchar* name, gchar* nick, gchar* blurb, GParamFlags flags);
	[LinkName("g_param_spec_pool_new")] public static extern GParamSpecPool* ParamSpecPoolNew(gboolean type_prefixing);
	[LinkName("g_param_spec_pool_insert")] public static extern void ParamSpecPoolInsert(GParamSpecPool* pool, GParamSpec* pspec, GType owner_type);
	[LinkName("g_param_spec_pool_remove")] public static extern void ParamSpecPoolRemove(GParamSpecPool* pool, GParamSpec* pspec);
	[LinkName("g_param_spec_pool_lookup")] public static extern GParamSpec* ParamSpecPoolLookup(GParamSpecPool* pool, gchar* param_name, GType owner_type, gboolean walk_ancestors);
	[LinkName("g_param_spec_pool_list_owned")] public static extern GList* ParamSpecPoolListOwned(GParamSpecPool* pool, GType owner_type);
	[LinkName("g_param_spec_pool_list")] public static extern GParamSpec** ParamSpecPoolList(GParamSpecPool* pool, GType owner_type, guint* n_pspecs_p);
	[LinkName("g_param_spec_pool_free")] public static extern void ParamSpecPoolFree(GParamSpecPool* pool);
}



/** GCallback:
 *  
 *  The type used for callback functions in structure definitions and function
 *  signatures.
 *  
 *  This doesn't mean that all callback functions must take no  parameters and
 *  return void. The required signature of a callback function is determined by
 *  the context in which is used (e.g. the signal to which it is connected).
 *  
 *  Use G_CALLBACK() to cast the callback function to a #GCallback.
 */
function void GCallback();

/** GClosureNotify:
 *  @date : data specified when registering the notification callback
 *         @closure : the #GClosure on which the notification is emitted
 *  
 *  The type used for the various notification callbacks which can be registered
 *  on closures.
 */
function void GClosureNotify(gpointer data, GClosure* closure);

/** GClosureMarshal:
 *   @closure : the #GClosure to which the marshaller belongs
 *  @return _value: (nullable): a #GValue to store the return
 *          value. May be %NULL if the callback of @closure doesn't return a
 *          value.
 *           @n _param_values: the length of the@param _values array
 *                 @param _values: (array length=n_param_values): an array of
 *                  #GValues holding the arguments on which to invoke the
 *                  callback of @closure
 *                   @invocation _hint: (nullable): the invocation hint given as the
 *                  last argument to g_closure_invoke()
 *                   @marshal _data: (nullable): additional data specified when
 *                  registering the marshaller, see g_closure_set_marshal() and
 *                  g_closure_set_meta_marshal()
 *  
 *  The type used for marshaller functions.
 */
function void GClosureMarshal(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);

/** GVaClosureMarshal:
 *   @closure : the #GClosure to which the marshaller belongs
 *  @return _value: (nullable): a #GValue to store the return
 *          value. May be %NULL if the callback of @closure doesn't return a
 *          value.
 *           @instance : (type GObject.TypeInstance): the instance on which the closure is
 *          invoked.
 *          @arg : va_list of arguments to be passed to the closure.
 *        @marshal _data: (nullable): additional data specified when
 *       registering the marshaller, see g_closure_set_marshal() and
 *       g_closure_set_meta_marshal()
 *        @n _params: the length of the@param _types array
 *                @param _types: (array length=n_params): the #GType of each argument from
 *                 @arg .
 *  
 *  This is the signature of va_list marshaller functions, an optional
 *  marshaller that can be used in some situations to avoid
 *  marshalling the signal argument into GValues.
 */
function void GVaClosureMarshal(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);


[CRepr] struct GClosureNotifyData
{
	public gpointer data;
	public GClosureNotify notify;
}

[CRepr] struct GClosure
{
	[Bitfield(.Public, .BitsAt(bits: 15, pos: 0), "ref_count")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 15), "meta_marshal_nouse")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 16), "n_guards")]
	[Bitfield(.Public, .BitsAt(bits: 2, pos: 17), "n_fnotifiers")]
	[Bitfield(.Public, .BitsAt(bits: 8, pos: 19), "n_inotifiers")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 27), "in_inotify")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 28), "floating")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 29), "derivative_flag")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 30), "in_marshal")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 31), "is_invalid")]
	private uint32 __bitfield_2776987;
	public function void(GClosure*, GValue*, guint, GValue*, gpointer, gpointer) marshal;
	public gpointer data;
	public GClosureNotifyData* notifiers;
}

[CRepr] struct GCClosure
{
	public GClosure closure;
	public gpointer callback;
}

extension GObject
{
	[LinkName("g_cclosure_new")] public static extern GClosure* CclosureNew(GCallback callback_func, gpointer user_data, GClosureNotify destroy_data);
	[LinkName("g_cclosure_new_swap")] public static extern GClosure* CclosureNewSwap(GCallback callback_func, gpointer user_data, GClosureNotify destroy_data);
	[LinkName("g_signal_type_cclosure_new")] public static extern GClosure* SignalTypeCclosureNew(GType itype, guint struct_offset);
	[LinkName("g_closure_ref")] public static extern GClosure* ClosureRef(GClosure* closure);
	[LinkName("g_closure_sink")] public static extern void ClosureSink(GClosure* closure);
	[LinkName("g_closure_unref")] public static extern void ClosureUnref(GClosure* closure);
	[LinkName("g_closure_new_simple")] public static extern GClosure* ClosureNewSimple(guint sizeof_closure, gpointer data);
	[LinkName("g_closure_add_finalize_notifier")] public static extern void ClosureAddFinalizeNotifier(GClosure* closure, gpointer notify_data, GClosureNotify notify_func);
	[LinkName("g_closure_remove_finalize_notifier")] public static extern void ClosureRemoveFinalizeNotifier(GClosure* closure, gpointer notify_data, GClosureNotify notify_func);
	[LinkName("g_closure_add_invalidate_notifier")] public static extern void ClosureAddInvalidateNotifier(GClosure* closure, gpointer notify_data, GClosureNotify notify_func);
	[LinkName("g_closure_remove_invalidate_notifier")] public static extern void ClosureRemoveInvalidateNotifier(GClosure* closure, gpointer notify_data, GClosureNotify notify_func);
	[LinkName("g_closure_add_marshal_guards")] public static extern void ClosureAddMarshalGuards(GClosure* closure, gpointer pre_marshal_data, GClosureNotify pre_marshal_notify, gpointer post_marshal_data, GClosureNotify post_marshal_notify);
	[LinkName("g_closure_set_marshal")] public static extern void ClosureSetMarshal(GClosure* closure, GClosureMarshal marshal);
	[LinkName("g_closure_set_meta_marshal")] public static extern void ClosureSetMetaMarshal(GClosure* closure, gpointer marshal_data, GClosureMarshal meta_marshal);
	[LinkName("g_closure_invalidate")] public static extern void ClosureInvalidate(GClosure* closure);
	[LinkName("g_closure_invoke")] public static extern void ClosureInvoke(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint);
	[LinkName("g_cclosure_marshal_generic")] public static extern void CclosureMarshalGeneric(GClosure* closure, GValue* return_gvalue, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_generic_va")] public static extern void CclosureMarshalGenericVa(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args_list, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__VOID")] public static extern void CclosureMarshalVOIDVOID(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__VOIDv")] public static extern void CclosureMarshalVOIDVOIDv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__BOOLEAN")] public static extern void CclosureMarshalVOIDBOOLEAN(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__BOOLEANv")] public static extern void CclosureMarshalVOIDBOOLEANv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__CHAR")] public static extern void CclosureMarshalVOIDCHAR(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__CHARv")] public static extern void CclosureMarshalVOIDCHARv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__UCHAR")] public static extern void CclosureMarshalVOIDUCHAR(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__UCHARv")] public static extern void CclosureMarshalVOIDUCHARv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__INT")] public static extern void CclosureMarshalVOIDINT(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__INTv")] public static extern void CclosureMarshalVOIDINTv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__UINT")] public static extern void CclosureMarshalVOIDUINT(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__UINTv")] public static extern void CclosureMarshalVOIDUINTv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__LONG")] public static extern void CclosureMarshalVOIDLONG(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__LONGv")] public static extern void CclosureMarshalVOIDLONGv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__ULONG")] public static extern void CclosureMarshalVOIDULONG(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__ULONGv")] public static extern void CclosureMarshalVOIDULONGv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__ENUM")] public static extern void CclosureMarshalVOIDENUM(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__ENUMv")] public static extern void CclosureMarshalVOIDENUMv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__FLAGS")] public static extern void CclosureMarshalVOIDFLAGS(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__FLAGSv")] public static extern void CclosureMarshalVOIDFLAGSv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__FLOAT")] public static extern void CclosureMarshalVOIDFLOAT(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__FLOATv")] public static extern void CclosureMarshalVOIDFLOATv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__DOUBLE")] public static extern void CclosureMarshalVOIDDOUBLE(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__DOUBLEv")] public static extern void CclosureMarshalVOIDDOUBLEv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__STRING")] public static extern void CclosureMarshalVOIDSTRING(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__STRINGv")] public static extern void CclosureMarshalVOIDSTRINGv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__PARAM")] public static extern void CclosureMarshalVOIDPARAM(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__PARAMv")] public static extern void CclosureMarshalVOIDPARAMv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__BOXED")] public static extern void CclosureMarshalVOIDBOXED(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__BOXEDv")] public static extern void CclosureMarshalVOIDBOXEDv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__POINTER")] public static extern void CclosureMarshalVOIDPOINTER(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__POINTERv")] public static extern void CclosureMarshalVOIDPOINTERv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__OBJECT")] public static extern void CclosureMarshalVOIDOBJECT(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__OBJECTv")] public static extern void CclosureMarshalVOIDOBJECTv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__VARIANT")] public static extern void CclosureMarshalVOIDVARIANT(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__VARIANTv")] public static extern void CclosureMarshalVOIDVARIANTv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_VOID__UINT_POINTER")] public static extern void CclosureMarshalVOIDUINTPOINTER(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_VOID__UINT_POINTERv")] public static extern void CclosureMarshalVOIDUINTPOINTERv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_BOOLEAN__FLAGS")] public static extern void CclosureMarshalBOOLEANFLAGS(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_BOOLEAN__FLAGSv")] public static extern void CclosureMarshalBOOLEANFLAGSv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_STRING__OBJECT_POINTER")] public static extern void CclosureMarshalSTRINGOBJECTPOINTER(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_STRING__OBJECT_POINTERv")] public static extern void CclosureMarshalSTRINGOBJECTPOINTERv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
	[LinkName("g_cclosure_marshal_BOOLEAN__BOXED_BOXED")] public static extern void CclosureMarshalBOOLEANBOXEDBOXED(GClosure* closure, GValue* return_value, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
	[LinkName("g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv")] public static extern void CclosureMarshalBOOLEANBOXEDBOXEDv(GClosure* closure, GValue* return_value, gpointer instance, VarArgs args, gpointer marshal_data, c_int n_params, GType* param_types);
}



/** GSignalCMarshaller:
 *  
 *  This is the signature of marshaller functions, required to marshall
 *  arrays of parameter values to signal emissions into C language callback
 *  invocations.
 *  
 *  It is merely an alias to #GClosureMarshal since the #GClosure mechanism
 *  takes over responsibility of actual function invocation for the signal
 *  system.
 */
typealias GSignalCMarshaller = GClosureMarshal;

/** GSignalCVaMarshaller:
 *  
 *  This is the signature of va_list marshaller functions, an optional
 *  marshaller that can be used in some situations to avoid
 *  marshalling the signal argument into GValues.
 */
typealias GSignalCVaMarshaller = GVaClosureMarshal;

/** GSignalEmissionHook:
 *   @ihint : Signal invocation hint, see #GSignalInvocationHint.
 *   @n _param_values: the number of parameters to the function, including
 *  the instance on which the signal was emitted.
 *  @param _values: (array length=n_param_values): the instance on which
 *                  the signal was emitted, followed by the parameters of the emission.
 *                  @date : user data associated with the hook.
 *  
 *  A simple function pointer to get invoked when the signal is emitted.
 *  
 *  Emission hooks allow you to tie a hook to the signal type, so that it will
 *  trap all emissions of that signal, from any object.
 *  
 *  You may not attach these to signals created with the %G_SIGNAL_NO_HOOKS flag.
 *  
 *  Returns: whether it wants to stay connected. If it returns %FALSE, the signal
 *  hook is disconnected (and destroyed).
 */
function gboolean GSignalEmissionHook(GSignalInvocationHint* ihint, guint n_param_values, GValue* param_values, gpointer data);

/** GSignalAccumulator:
 *   @ihint : Signal invocation hint, see #GSignalInvocationHint.
 *  @return _accu: Accumulator to collect callback return values in, this
 *          is the return value of the current signal emission.
 *           @handler _return: A #GValue holding the return value of the signal handler.
 *          @date : Callback data that was specified when creating the signal.
 *  
 *  The signal accumulator is a special callback function that can be used
 *  to collect return values of the various callbacks that are called
 *  during a signal emission.
 *  
 *  The signal accumulator is specified at signal creation time, if it is
 *  left %NULL, no accumulation of callback return values is performed.
 *  The return value of signal emissions is then the value returned by the
 *  last callback.
 *  
 *  Returns: The accumulator function returns whether the signal emission
 *  should be aborted. Returning %TRUE will continue with
 *  the signal emission. Returning %FALSE will abort the current emission.
 *  Since 2.62, returning %FALSE will skip to the CLEANUP stage. In this case,
 *  emission will occur as normal in the CLEANUP stage and the handler's
 *  return value will be accumulated.
 */
function gboolean GSignalAccumulator(GSignalInvocationHint* ihint, GValue* return_accu, GValue* handler_return, gpointer data);

/** GSignalFlags:
 *   @G _SIGNAL_RUN_FIRST: Invoke the object method handler in the first emission stage.
 *   @G _SIGNAL_RUN_LAST: Invoke the object method handler in the third emission stage.
 *   @G _SIGNAL_RUN_CLEANUP: Invoke the object method handler in the last emission stage.
 *   @G _SIGNAL_NO_RECURSE: Signals being emitted for an object while currently being in
 *  emission for this very object will not be emitted recursively,
 *  but instead cause the first emission to be restarted.
 *   @G _SIGNAL_DETAILED: This signal supports "::detail" appendices to the signal name
 *  upon handler connections and emissions.
 *   @G _SIGNAL_ACTION: Action signals are signals that may freely be emitted on alive
 *  objects from user code via g_signal_emit() and friends, without
 *  the need of being embedded into extra code that performs pre or
 *  post emission adjustments on the object. They can also be thought
 *  of as object methods which can be called generically by
 *  third-party code.
 *   @G _SIGNAL_NO_HOOKS: No emissions hooks are supported for this signal.
 *  
 *  The signal flags are used to specify a signal's behaviour.
 */
[AllowDuplicates] enum GSignalFlags : c_int
{
	RunFirst = 1 << 0,
	RunLast = 1 << 1,
	RunCleanup = 1 << 2,
	NoRecurse = 1 << 3,
	Detailed = 1 << 4,
	Action = 1 << 5,
	NoHooks = 1 << 6,
	MustCollect = 1 << 7,
	Deprecated = 1 << 8,
	AccumulatorFirstRun = 1 << 17,
}

/** GConnectFlags:
 *   @G _CONNECT_DEFAULT: Default behaviour (no special flags). Since: 2.74
 *   @G _CONNECT_AFTER: If set, the handler should be called after the
 *  default handler of the signal. Normally, the handler is called before
 *  the default handler.
 *   @G _CONNECT_SWAPPED: If set, the instance and data should be swapped when
 *  calling the handler; see g_signal_connect_swapped() for an example.
 *  
 *  The connection flags are used to specify the behaviour of a signal's
 *  connection.
 */
[AllowDuplicates] enum GConnectFlags : c_int
{
	Default = 0,
	After = 1 << 0,
	Swapped = 1 << 1,
}

/** GSignalMatchType:
 *   @G _SIGNAL_MATCH_ID: The signal id must be equal.
 *   @G _SIGNAL_MATCH_DETAIL: The signal detail must be equal.
 *   @G _SIGNAL_MATCH_CLOSURE: The closure must be the same.
 *   @G _SIGNAL_MATCH_FUNC: The C closure callback must be the same.
 *   @G _SIGNAL_MATCH_DATA: The closure data must be the same.
 *   @G _SIGNAL_MATCH_UNBLOCKED: Only unblocked signals may be matched.
 *  
 *  The match types specify what g_signal_handlers_block_matched(),
 *  g_signal_handlers_unblock_matched() and g_signal_handlers_disconnect_matched()
 *  match signals by.
 */
[AllowDuplicates] enum GSignalMatchType : c_int
{
	Id = 1 << 0,
	Detail = 1 << 1,
	Closure = 1 << 2,
	Func = 1 << 3,
	Data = 1 << 4,
	Unblocked = 1 << 5,
}

/** GSignalInvocationHint:
 *   @signal _id: The signal id of the signal invoking the callback
 *  @details : The detail passed on for this emission
 *            @run _type: The stage the signal emission is currently in, this
 *           field will contain one of %G_SIGNAL_RUN_FIRST,
 *           %G_SIGNAL_RUN_LAST or %G_SIGNAL_RUN_CLEANUP and %G_SIGNAL_ACCUMULATOR_FIRST_RUN.
 *           %G_SIGNAL_ACCUMULATOR_FIRST_RUN is only set for the first run of the accumulator
 *           function for a signal emission.
 *  
 *  The #GSignalInvocationHint structure is used to pass on additional information
 *  to callbacks during a signal emission.
 */
[CRepr] struct GSignalInvocationHint
{
	public guint signal_id;
	public GQuark detail;
	public GSignalFlags run_type;
}

/** GSignalQuery:
 *   @signal _id: The signal id of the signal being queried, or 0 if the
 *  signal to be queried was unknown.
 *   @signal _name: The signal name.
 *   @itype : The interface/instance type that this signal can be emitted for.
 *   @signal _flags: The signal flags as passed in to g_signal_new().
 *  @return _type: The return type for user callbacks.
 *           @n _params: The number of parameters that user callbacks take.
 *          @param _types: (array length=n_params): The individual parameter types for
 *                 user callbacks, note that the effective callback signature is:
 *                 |[<!-- language="C" -->
 *                 @return _type callback (#gpointer     data1,
 *          [param_types param_names,]
 *          gpointer     data2);
 *          ]|
 *  
 *  A structure holding in-depth information for a specific signal.
 *  
 *  See also: g_signal_query()
 */
[CRepr] struct GSignalQuery
{
	public guint signal_id;
	public gchar* signal_name;
	public GType itype;
	public GSignalFlags signal_flags;
	public GType return_type;
	public guint n_params;
	public GType* param_types;
}

extension GObject
{
	[LinkName("g_signal_newv")] public static extern guint SignalNewv(gchar* signal_name, GType itype, GSignalFlags signal_flags, GClosure* class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, GType* param_types);
	[LinkName("g_signal_new_valist")] public static extern guint SignalNewValist(gchar* signal_name, GType itype, GSignalFlags signal_flags, GClosure* class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, VarArgs args);
	[LinkName("g_signal_new")] public static extern guint SignalNew(gchar* signal_name, GType itype, GSignalFlags signal_flags, guint class_offset, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, ...);
	[LinkName("g_signal_new_class_handler")] public static extern guint SignalNewClassHandler(gchar* signal_name, GType itype, GSignalFlags signal_flags, GCallback class_handler, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, ...);
	[LinkName("g_signal_set_va_marshaller")] public static extern void SignalSetVaMarshaller(guint signal_id, GType instance_type, GSignalCVaMarshaller va_marshaller);
	[LinkName("g_signal_emitv")] public static extern void SignalEmitv(GValue* instance_and_params, guint signal_id, GQuark detail, GValue* return_value);
	[LinkName("g_signal_emit_valist")] public static extern void SignalEmitValist(gpointer instance, guint signal_id, GQuark detail, VarArgs var_args);
	[LinkName("g_signal_emit")] public static extern void SignalEmit(gpointer instance, guint signal_id, GQuark detail, ...);
	[LinkName("g_signal_emit_by_name")] public static extern void SignalEmitByName(gpointer instance, gchar* detailed_signal, ...);
	[LinkName("g_signal_lookup")] public static extern guint SignalLookup(gchar* name, GType itype);
	[LinkName("g_signal_name")] public static extern gchar* SignalName(guint signal_id);
	[LinkName("g_signal_query")] public static extern void SignalQuery(guint signal_id, GSignalQuery* query);
	[LinkName("g_signal_list_ids")] public static extern guint* SignalListIds(GType itype, guint* n_ids);
	[LinkName("g_signal_is_valid_name")] public static extern gboolean SignalIsValidName(gchar* name);
	[LinkName("g_signal_parse_name")] public static extern gboolean SignalParseName(gchar* detailed_signal, GType itype, guint* signal_id_p, GQuark* detail_p, gboolean force_detail_quark);
	[LinkName("g_signal_get_invocation_hint")] public static extern GSignalInvocationHint* SignalGetInvocationHint(gpointer instance);
	[LinkName("g_signal_stop_emission")] public static extern void SignalStopEmission(gpointer instance, guint signal_id, GQuark detail);
	[LinkName("g_signal_stop_emission_by_name")] public static extern void SignalStopEmissionByName(gpointer instance, gchar* detailed_signal);
	[LinkName("g_signal_add_emission_hook")] public static extern gulong SignalAddEmissionHook(guint signal_id, GQuark detail, GSignalEmissionHook hook_func, gpointer hook_data, GDestroyNotify data_destroy);
	[LinkName("g_signal_remove_emission_hook")] public static extern void SignalRemoveEmissionHook(guint signal_id, gulong hook_id);
	[LinkName("g_signal_has_handler_pending")] public static extern gboolean SignalHasHandlerPending(gpointer instance, guint signal_id, GQuark detail, gboolean may_be_blocked);
	[LinkName("g_signal_connect_closure_by_id")] public static extern gulong SignalConnectClosureById(gpointer instance, guint signal_id, GQuark detail, GClosure* closure, gboolean after);
	[LinkName("g_signal_connect_closure")] public static extern gulong SignalConnectClosure(gpointer instance, gchar* detailed_signal, GClosure* closure, gboolean after);
	[LinkName("g_signal_connect_data")] public static extern gulong SignalConnectData(gpointer instance, gchar* detailed_signal, GCallback c_handler, gpointer data, GClosureNotify destroy_data, GConnectFlags connect_flags);
	[LinkName("g_signal_handler_block")] public static extern void SignalHandlerBlock(gpointer instance, gulong handler_id);
	[LinkName("g_signal_handler_unblock")] public static extern void SignalHandlerUnblock(gpointer instance, gulong handler_id);
	[LinkName("g_signal_handler_disconnect")] public static extern void SignalHandlerDisconnect(gpointer instance, gulong handler_id);
	[LinkName("g_signal_handler_is_connected")] public static extern gboolean SignalHandlerIsConnected(gpointer instance, gulong handler_id);
	[LinkName("g_signal_handler_find")] public static extern gulong SignalHandlerFind(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure* closure, gpointer func, gpointer data);
	[LinkName("g_signal_handlers_block_matched")] public static extern guint SignalHandlersBlockMatched(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure* closure, gpointer func, gpointer data);
	[LinkName("g_signal_handlers_unblock_matched")] public static extern guint SignalHandlersUnblockMatched(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure* closure, gpointer func, gpointer data);
	[LinkName("g_signal_handlers_disconnect_matched")] public static extern guint SignalHandlersDisconnectMatched(gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure* closure, gpointer func, gpointer data);
	[LinkName("g_clear_signal_handler")] public static extern void ClearSignalHandler(gulong* handler_id_ptr, gpointer instance);
	[LinkName("g_signal_override_class_closure")] public static extern void SignalOverrideClassClosure(guint signal_id, GType instance_type, GClosure* class_closure);
	[LinkName("g_signal_override_class_handler")] public static extern void SignalOverrideClassHandler(gchar* signal_name, GType instance_type, GCallback class_handler);
	[LinkName("g_signal_chain_from_overridden")] public static extern void SignalChainFromOverridden(GValue* instance_and_params, GValue* return_value);
	[LinkName("g_signal_chain_from_overridden_handler")] public static extern void SignalChainFromOverriddenHandler(gpointer instance, ...);
	[LinkName("g_signal_accumulator_true_handled")] public static extern gboolean SignalAccumulatorTrueHandled(GSignalInvocationHint* ihint, GValue* return_accu, GValue* handler_return, gpointer dummy);
	[LinkName("g_signal_accumulator_first_wins")] public static extern gboolean SignalAccumulatorFirstWins(GSignalInvocationHint* ihint, GValue* return_accu, GValue* handler_return, gpointer dummy);
	[LinkName("g_signal_handlers_destroy")] public static extern void SignalHandlersDestroy(gpointer instance);
}

static
{
	[LinkName("_g_signals_destroy")] public static extern void GSignalsDestroy(GType itype);
}

extension GObject
{
	[LinkName("g_date_get_type")] public static extern GType DateGetType();
	[LinkName("g_strv_get_type")] public static extern GType StrvGetType();
	[LinkName("g_gstring_get_type")] public static extern GType GstringGetType();
	[LinkName("g_hash_table_get_type")] public static extern GType HashTableGetType();
	[LinkName("g_array_get_type")] public static extern GType ArrayGetType();
	[LinkName("g_byte_array_get_type")] public static extern GType ByteArrayGetType();
	[LinkName("g_ptr_array_get_type")] public static extern GType PtrArrayGetType();
	[LinkName("g_bytes_get_type")] public static extern GType BytesGetType();
	[LinkName("g_variant_type_get_gtype")] public static extern GType VariantTypeGetGtype();
	[LinkName("g_regex_get_type")] public static extern GType RegexGetType();
	[LinkName("g_match_info_get_type")] public static extern GType MatchInfoGetType();
	[LinkName("g_error_get_type")] public static extern GType ErrorGetType();
	[LinkName("g_date_time_get_type")] public static extern GType DateTimeGetType();
	[LinkName("g_time_zone_get_type")] public static extern GType TimeZoneGetType();
	[LinkName("g_io_channel_get_type")] public static extern GType IoChannelGetType();
	[LinkName("g_io_condition_get_type")] public static extern GType IoConditionGetType();
	[LinkName("g_variant_builder_get_type")] public static extern GType VariantBuilderGetType();
	[LinkName("g_variant_dict_get_type")] public static extern GType VariantDictGetType();
	[LinkName("g_key_file_get_type")] public static extern GType KeyFileGetType();
	[LinkName("g_main_loop_get_type")] public static extern GType MainLoopGetType();
	[LinkName("g_main_context_get_type")] public static extern GType MainContextGetType();
	[LinkName("g_source_get_type")] public static extern GType SourceGetType();
	[LinkName("g_pollfd_get_type")] public static extern GType PollfdGetType();
	[LinkName("g_thread_get_type")] public static extern GType ThreadGetType();
	[LinkName("g_checksum_get_type")] public static extern GType ChecksumGetType();
	[LinkName("g_markup_parse_context_get_type")] public static extern GType MarkupParseContextGetType();
	[LinkName("g_mapped_file_get_type")] public static extern GType MappedFileGetType();
	[LinkName("g_option_group_get_type")] public static extern GType OptionGroupGetType();
	[LinkName("g_uri_get_type")] public static extern GType UriGetType();
	[LinkName("g_tree_get_type")] public static extern GType TreeGetType();
	[LinkName("g_pattern_spec_get_type")] public static extern GType PatternSpecGetType();
	[LinkName("g_bookmark_file_get_type")] public static extern GType BookmarkFileGetType();
	[LinkName("g_hmac_get_type")] public static extern GType HmacGetType();
	[LinkName("g_dir_get_type")] public static extern GType DirGetType();
	[LinkName("g_rand_get_type")] public static extern GType RandGetType();
	[LinkName("g_strv_builder_get_type")] public static extern GType StrvBuilderGetType();
	[LinkName("g_variant_get_gtype")] public static extern GType VariantGetGtype();
}

/** GBoxedCopyFunc:
 *   @boxed : (not nullable): The boxed structure to be copied.
 *  
 *  This function is provided by the user and should produce a copy
 *  of the passed in boxed structure.
 *  
 *  Returns: (not nullable): The newly created copy of the boxed structure.
 */
function gpointer GBoxedCopyFunc(gpointer boxed);

/** GBoxedFreeFunc:
 *   @boxed : (not nullable): The boxed structure to be freed.
 *  
 *  This function is provided by the user and should free the boxed
 *  structure passed.
 */
function void GBoxedFreeFunc(gpointer boxed);

extension GObject
{
	[LinkName("g_boxed_copy")] public static extern gpointer BoxedCopy(GType boxed_type, gconstpointer src_boxed);
	[LinkName("g_boxed_free")] public static extern void BoxedFree(GType boxed_type, gpointer boxed);
	[LinkName("g_value_set_boxed")] public static extern void ValueSetBoxed(GValue* value, gconstpointer v_boxed);
	[LinkName("g_value_set_static_boxed")] public static extern void ValueSetStaticBoxed(GValue* value, gconstpointer v_boxed);
	[LinkName("g_value_take_boxed")] public static extern void ValueTakeBoxed(GValue* value, gconstpointer v_boxed);
	[LinkName("g_value_set_boxed_take_ownership")] public static extern void ValueSetBoxedTakeOwnership(GValue* value, gconstpointer v_boxed);
	[LinkName("g_value_get_boxed")] public static extern gpointer ValueGetBoxed(GValue* value);
	[LinkName("g_value_dup_boxed")] public static extern gpointer ValueDupBoxed(GValue* value);
	[LinkName("g_boxed_type_register_static")] public static extern GType BoxedTypeRegisterStatic(gchar* name, GBoxedCopyFunc boxed_copy, GBoxedFreeFunc boxed_free);
	[LinkName("g_closure_get_type")] public static extern GType ClosureGetType();
	[LinkName("g_value_get_type")] public static extern GType ValueGetType();
}



typealias GInitiallyUnowned = GObject;

/** GObjectClass:
 *   @g _type_class: the parent class
 *   @constructor : the @constructor function is called by g_object_new () to
 *  complete the object initialization after all the construction properties are
 *  set. The first thing a @constructor implementation must do is chain up to the
 *   @constructor of the parent class. Overriding @constructor should be rarely
 *  needed, e.g. to handle construct properties, or to implement singletons.
 *  @see _property: the generic setter for all properties of this type. Should be
 *       overridden for every type with properties. If implementations of
 *       @see _property don't emit property change notification explicitly, this will
 *       be done implicitly by the type system. However, if the notify signal is
 *       emitted explicitly, the type system will not emit it a second time.
 *        @get _property: the generic getter for all properties of this type. Should be
 *       overridden for every type with properties.
 *        @dispose : the @dispose function is supposed to drop all references to other
 *       objects, but keep the instance otherwise intact, so that client method
 *       invocations still work. It may be run multiple times (due to reference
 *       loops). Before returning,@dispose should chain up to the @dispose method
 *       of the parent class.
 *        @finalize : instance finalization function, should finish the finalization of
 *       the instance begun in @dispose and chain up to the @finalize method of the
 *       parent class.
 *        @dispatch _properties_changed: emits property change notification for a bunch
 *       of properties. Overriding @dispatch _properties_changed should be rarely
 *       needed.
 *        @notify : the class closure for the notify signal
 *        @constructed : the @constructed function is called by g_object_new() as the
 *       final step of the object creation process.  At the point of the call, all
 *       construction properties have been set on the object.  The purpose of this
 *       call is to allow for object initialisation steps that can only be performed
 *       after construction properties have been set.@constructed implementors
 *       should chain up to the @constructed call of their parent class to allow it
 *       to complete its initialisation.
 *  
 *  The class structure for the GObject type.
 *  
 *  |[<!-- language="C" -->
 *  // Example of implementing a singleton using a constructor.
 *  static MySingleton *the_singleton = NULL;
 *  
 *  static GObject*
 *  my_singleton_constructor (GType                  type,
 *  guint                  n_construct_params,
 *  GObjectConstructParam *construct_params)
 *  {
 *  GObject *object;
 *  
 *  if (!the_singleton)
 *  {
 *  object = G_OBJECT_CLASS (parent_class)->constructor (type,
 *  n_construct_params,
 *  construct_params);
 *  the_singleton = MY_SINGLETON (object);
 *  }
 *  else
 *  object = g_object_ref (G_OBJECT (the_singleton));
 *  
 *  return object;
 *  }
 *  ]|
 */
typealias GInitiallyUnownedClass = GObjectClass;


/** GObjectGetPropertyFunc:
 *   @object : a #GObject
 *  
 *  `_id: the numeric id under which the property was registered with`
 *  
 *  g_object_class_install_property().
 *   @value : a #GValue to return the property value in
 *   @pspec : the #GParamSpec describing the property
 *  
 *  The type of the @get _property function of #GObjectClass.
 */
function void GObjectGetPropertyFunc(GObject* object, guint property_id, GValue* value, GParamSpec* pspec);

/** GObjectSetPropertyFunc:
 *   @object : a #GObject
 *  
 *  `_id: the numeric id under which the property was registered with`
 *  
 *  g_object_class_install_property().
 *   @value : the new value for the property
 *   @pspec : the #GParamSpec describing the property
 *  
 *  The type of the@see _property function of #GObjectClass.
 */
function void GObjectSetPropertyFunc(GObject* object, guint property_id, GValue* value, GParamSpec* pspec);

/** GObjectFinalizeFunc:
 *   @object : the #GObject being finalized
 *  
 *  The type of the @finalize function of #GObjectClass.
 */
function void GObjectFinalizeFunc(GObject* object);

/** GWeakNotify:
 *  @date : data that was provided when the weak reference was established
 *         @where _the_object_was: the object being disposed
 *  
 *  A #GWeakNotify function can be added to an object as a callback that gets
 *  triggered when the object is finalized.
 *  
 *  Since the object is already being disposed when the #GWeakNotify is called,
 *  there's not much you could do with the object, apart from e.g. using its
 *  address as hash-index or the like.
 *  
 *  In particular, this means it’s invalid to call g_object_ref(),
 *  g_weak_ref_init(), g_weak_ref_set(), g_object_add_toggle_ref(),
 *  g_object_weak_ref(), g_object_add_weak_pointer() or any function which calls
 *  them on the object from this callback.
 */
function void GWeakNotify(gpointer data, GObject* where_the_object_was);

[CRepr] struct GObject
{
	public GTypeInstance g_type_instance;
	public guint ref_count;
	public GData* qdata;
}

/** GObjectClass:
 *   @g _type_class: the parent class
 *   @constructor : the @constructor function is called by g_object_new () to
 *  complete the object initialization after all the construction properties are
 *  set. The first thing a @constructor implementation must do is chain up to the
 *   @constructor of the parent class. Overriding @constructor should be rarely
 *  needed, e.g. to handle construct properties, or to implement singletons.
 *  @see _property: the generic setter for all properties of this type. Should be
 *       overridden for every type with properties. If implementations of
 *       @see _property don't emit property change notification explicitly, this will
 *       be done implicitly by the type system. However, if the notify signal is
 *       emitted explicitly, the type system will not emit it a second time.
 *        @get _property: the generic getter for all properties of this type. Should be
 *       overridden for every type with properties.
 *        @dispose : the @dispose function is supposed to drop all references to other
 *       objects, but keep the instance otherwise intact, so that client method
 *       invocations still work. It may be run multiple times (due to reference
 *       loops). Before returning,@dispose should chain up to the @dispose method
 *       of the parent class.
 *        @finalize : instance finalization function, should finish the finalization of
 *       the instance begun in @dispose and chain up to the @finalize method of the
 *       parent class.
 *        @dispatch _properties_changed: emits property change notification for a bunch
 *       of properties. Overriding @dispatch _properties_changed should be rarely
 *       needed.
 *        @notify : the class closure for the notify signal
 *        @constructed : the @constructed function is called by g_object_new() as the
 *       final step of the object creation process.  At the point of the call, all
 *       construction properties have been set on the object.  The purpose of this
 *       call is to allow for object initialisation steps that can only be performed
 *       after construction properties have been set.@constructed implementors
 *       should chain up to the @constructed call of their parent class to allow it
 *       to complete its initialisation.
 *  
 *  The class structure for the GObject type.
 *  
 *  |[<!-- language="C" -->
 *  // Example of implementing a singleton using a constructor.
 *  static MySingleton *the_singleton = NULL;
 *  
 *  static GObject*
 *  my_singleton_constructor (GType                  type,
 *  guint                  n_construct_params,
 *  GObjectConstructParam *construct_params)
 *  {
 *  GObject *object;
 *  
 *  if (!the_singleton)
 *  {
 *  object = G_OBJECT_CLASS (parent_class)->constructor (type,
 *  n_construct_params,
 *  construct_params);
 *  the_singleton = MY_SINGLETON (object);
 *  }
 *  else
 *  object = g_object_ref (G_OBJECT (the_singleton));
 *  
 *  return object;
 *  }
 *  ]|
 */
[CRepr] struct GObjectClass
{
	public GTypeClass g_type_class;
	public GSList* construct_properties;
	public function GObject*(GType, guint, GObjectConstructParam*) constructor;
	public function void(GObject*, guint, GValue*, GParamSpec*) set_property;
	public function void(GObject*, guint, GValue*, GParamSpec*) get_property;
	public function void(GObject*) dispose;
	public function void(GObject*) finalize;
	public function void(GObject*, guint, GParamSpec**) dispatch_properties_changed;
	public function void(GObject*, GParamSpec*) notify;
	public function void(GObject*) constructed;
	public gsize flags;
	public gsize n_construct_properties;
	public gpointer pspecs;
	public gsize n_pspecs;
	public gpointer[3] pdummy;
}

/** GObjectConstructParam:
 *   @pspec : the #GParamSpec of the construct parameter
 *   @value : the value to set the parameter to
 *  
 *  The GObjectConstructParam struct is an auxiliary structure used to hand
 *  #GParamSpec/#GValue pairs to the @constructor of a #GObjectClass.
 */
[CRepr] struct GObjectConstructParam
{
	public GParamSpec* pspec;
	public GValue* value;
}

extension GObject
{
	/** GInitiallyUnowned:
	 *  
	 *  A type for objects that have an initially floating reference.
	 *  
	 *  All the fields in the `GInitiallyUnowned` structure are private to the
	 *  implementation and should never be accessed directly.
	 *  
	 *  GInitiallyUnownedClass:
	 *  
	 *  The class structure for the GInitiallyUnowned type.
	 */
	[LinkName("g_initially_unowned_get_type")] public static extern GType InitiallyUnownedGetType();

	[LinkName("g_object_class_install_property")] public static extern void ObjectClassInstallProperty(GObjectClass* oclass, guint property_id, GParamSpec* pspec);
	[LinkName("g_object_class_find_property")] public static extern GParamSpec* ObjectClassFindProperty(GObjectClass* oclass, gchar* property_name);
	[LinkName("g_object_class_list_properties")] public static extern GParamSpec** ObjectClassListProperties(GObjectClass* oclass, guint* n_properties);
	[LinkName("g_object_class_override_property")] public static extern void ObjectClassOverrideProperty(GObjectClass* oclass, guint property_id, gchar* name);
	[LinkName("g_object_class_install_properties")] public static extern void ObjectClassInstallProperties(GObjectClass* oclass, guint n_pspecs, GParamSpec** pspecs);
	[LinkName("g_object_interface_install_property")] public static extern void ObjectInterfaceInstallProperty(gpointer g_iface, GParamSpec* pspec);
	[LinkName("g_object_interface_find_property")] public static extern GParamSpec* ObjectInterfaceFindProperty(gpointer g_iface, gchar* property_name);
	[LinkName("g_object_interface_list_properties")] public static extern GParamSpec** ObjectInterfaceListProperties(gpointer g_iface, guint* n_properties_p);
	[LinkName("g_object_get_type")] public static extern GType ObjectGetType();
	[LinkName("g_object_new")] public static extern gpointer ObjectNew(GType object_type, gchar* first_property_name, ...);
	[LinkName("g_object_new_with_properties")] public static extern GObject* ObjectNewWithProperties(GType object_type, guint n_properties, c_char** names, GValue* values);
	[LinkName("g_object_newv")] public static extern gpointer ObjectNewv(GType object_type, guint n_parameters, GParameter* parameters);
	[LinkName("g_object_new_valist")] public static extern GObject* ObjectNewValist(GType object_type, gchar* first_property_name, VarArgs var_args);
	[LinkName("g_object_set")] public static extern void ObjectSet(gpointer object, gchar* first_property_name, ...);
	[LinkName("g_object_get")] public static extern void ObjectGet(gpointer object, gchar* first_property_name, ...);
	[LinkName("g_object_connect")] public static extern gpointer ObjectConnect(gpointer object, gchar* signal_spec, ...);
	[LinkName("g_object_disconnect")] public static extern void ObjectDisconnect(gpointer object, gchar* signal_spec, ...);
	[LinkName("g_object_setv")] public static extern void ObjectSetv(GObject* object, guint n_properties, gchar** names, GValue* values);
	[LinkName("g_object_set_valist")] public static extern void ObjectSetValist(GObject* object, gchar* first_property_name, VarArgs var_args);
	[LinkName("g_object_getv")] public static extern void ObjectGetv(GObject* object, guint n_properties, gchar** names, GValue* values);
	[LinkName("g_object_get_valist")] public static extern void ObjectGetValist(GObject* object, gchar* first_property_name, VarArgs var_args);
	[LinkName("g_object_set_property")] public static extern void ObjectSetProperty(GObject* object, gchar* property_name, GValue* value);
	[LinkName("g_object_get_property")] public static extern void ObjectGetProperty(GObject* object, gchar* property_name, GValue* value);
	[LinkName("g_object_freeze_notify")] public static extern void ObjectFreezeNotify(GObject* object);
	[LinkName("g_object_notify")] public static extern void ObjectNotify(GObject* object, gchar* property_name);
	[LinkName("g_object_notify_by_pspec")] public static extern void ObjectNotifyByPspec(GObject* object, GParamSpec* pspec);
	[LinkName("g_object_thaw_notify")] public static extern void ObjectThawNotify(GObject* object);
	[LinkName("g_object_is_floating")] public static extern gboolean ObjectIsFloating(gpointer object);
	[LinkName("g_object_ref_sink")] public static extern gpointer ObjectRefSink(gpointer object);
	[LinkName("g_object_take_ref")] public static extern gpointer ObjectTakeRef(gpointer object);
	[LinkName("g_object_ref")] public static extern gpointer ObjectRef(gpointer object);
	[LinkName("g_object_unref")] public static extern void ObjectUnref(gpointer object);
	[LinkName("g_object_weak_ref")] public static extern void ObjectWeakRef(GObject* object, GWeakNotify notify, gpointer data);
	[LinkName("g_object_weak_unref")] public static extern void ObjectWeakUnref(GObject* object, GWeakNotify notify, gpointer data);
	[LinkName("g_object_add_weak_pointer")] public static extern void ObjectAddWeakPointer(GObject* object, gpointer* weak_pointer_location);
	[LinkName("g_object_remove_weak_pointer")] public static extern void ObjectRemoveWeakPointer(GObject* object, gpointer* weak_pointer_location);
}

/** GToggleNotify:
 *  @date : Callback data passed to g_object_add_toggle_ref()
 *         @object : The object on which g_object_add_toggle_ref() was called.
 *        
 *  `_last_ref: %TRUE if the toggle reference is now the`
 *  
 *  last reference to the object. %FALSE if the toggle
 *  reference was the last reference and there are now other
 *  references.
 *  
 *  A callback function used for notification when the state
 *  of a toggle reference changes.
 *  
 *  See also: g_object_add_toggle_ref()
 */
function void GToggleNotify(gpointer data, GObject* object, gboolean is_last_ref);

extension GObject
{
	[LinkName("g_object_add_toggle_ref")] public static extern void ObjectAddToggleRef(GObject* object, GToggleNotify notify, gpointer data);
	[LinkName("g_object_remove_toggle_ref")] public static extern void ObjectRemoveToggleRef(GObject* object, GToggleNotify notify, gpointer data);
	[LinkName("g_object_get_qdata")] public static extern gpointer ObjectGetQdata(GObject* object, GQuark quark);
	[LinkName("g_object_set_qdata")] public static extern void ObjectSetQdata(GObject* object, GQuark quark, gpointer data);
	[LinkName("g_object_set_qdata_full")] public static extern void ObjectSetQdataFull(GObject* object, GQuark quark, gpointer data, GDestroyNotify destroy);
	[LinkName("g_object_steal_qdata")] public static extern gpointer ObjectStealQdata(GObject* object, GQuark quark);
	[LinkName("g_object_dup_qdata")] public static extern gpointer ObjectDupQdata(GObject* object, GQuark quark, GDuplicateFunc dup_func, gpointer user_data);
	[LinkName("g_object_replace_qdata")] public static extern gboolean ObjectReplaceQdata(GObject* object, GQuark quark, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify* old_destroy);
	[LinkName("g_object_get_data")] public static extern gpointer ObjectGetData(GObject* object, gchar* key);
	[LinkName("g_object_set_data")] public static extern void ObjectSetData(GObject* object, gchar* key, gpointer data);
	[LinkName("g_object_set_data_full")] public static extern void ObjectSetDataFull(GObject* object, gchar* key, gpointer data, GDestroyNotify destroy);
	[LinkName("g_object_steal_data")] public static extern gpointer ObjectStealData(GObject* object, gchar* key);
	[LinkName("g_object_dup_data")] public static extern gpointer ObjectDupData(GObject* object, gchar* key, GDuplicateFunc dup_func, gpointer user_data);
	[LinkName("g_object_replace_data")] public static extern gboolean ObjectReplaceData(GObject* object, gchar* key, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify* old_destroy);
	[LinkName("g_object_watch_closure")] public static extern void ObjectWatchClosure(GObject* object, GClosure* closure);
	[LinkName("g_cclosure_new_object")] public static extern GClosure* CclosureNewObject(GCallback callback_func, GObject* object);
	[LinkName("g_cclosure_new_object_swap")] public static extern GClosure* CclosureNewObjectSwap(GCallback callback_func, GObject* object);
	[LinkName("g_closure_new_object")] public static extern GClosure* ClosureNewObject(guint sizeof_closure, GObject* object);
	[LinkName("g_value_set_object")] public static extern void ValueSetObject(GValue* value, gpointer v_object);
	[LinkName("g_value_get_object")] public static extern gpointer ValueGetObject(GValue* value);
	[LinkName("g_value_dup_object")] public static extern gpointer ValueDupObject(GValue* value);
	[LinkName("g_signal_connect_object")] public static extern gulong SignalConnectObject(gpointer instance, gchar* detailed_signal, GCallback c_handler, gpointer gobject, GConnectFlags connect_flags);
	[LinkName("g_object_force_floating")] public static extern void ObjectForceFloating(GObject* object);
	[LinkName("g_object_run_dispose")] public static extern void ObjectRunDispose(GObject* object);
	[LinkName("g_value_take_object")] public static extern void ValueTakeObject(GValue* value, gpointer v_object);
	[LinkName("g_value_set_object_take_ownership")] public static extern void ValueSetObjectTakeOwnership(GValue* value, gpointer v_object);
	[LinkName("g_object_compat_control")] public static extern gsize ObjectCompatControl(gsize what, gpointer data);
	[LinkName("g_clear_object")] public static extern void ClearObject(GObject** object_ptr);
}

[CRepr] struct GWeakRef
{
	[Union, CRepr]public  struct 
	{
		public gpointer p;
	} priv;
}

extension GObject
{
	[LinkName("g_weak_ref_init")] public static extern void WeakRefInit(GWeakRef* weak_ref, gpointer object);
	[LinkName("g_weak_ref_clear")] public static extern void WeakRefClear(GWeakRef* weak_ref);
	[LinkName("g_weak_ref_get")] public static extern gpointer WeakRefGet(GWeakRef* weak_ref);
	[LinkName("g_weak_ref_set")] public static extern void WeakRefSet(GWeakRef* weak_ref, gpointer object);
}

struct GBinding;

/** GBindingTransformFunc:
 *   @binding : a #GBinding
 *   @from _value: the #GValue containing the value to transform
 *   @to _value: the #GValue in which to store the transformed value
 *   @user _data: data passed to the transform function
 *  
 *  A function to be called to transform @from _value to @to _value.
 *  
 *  If this is the @transform _to function of a binding, then @from _value
 *  is the @source _property on the @source object, and @to _value is the
 *   @target _property on the @target object. If this is the
 *   @transform _from function of a %G_BINDING_BIDIRECTIONAL binding,
 *  then those roles are reversed.
 *  
 *  Returns: %TRUE if the transformation was successful, and %FALSE
 *  otherwise
 *  
 *  Since: 2.26
 */
function gboolean GBindingTransformFunc(GBinding* binding, GValue* from_value, GValue* to_value, gpointer user_data);

/** GBindingFlags:
 *   @G _BINDING_DEFAULT: The default binding; if the source property
 *  changes, the target property is updated with its value.
 *   @G _BINDING_BIDIRECTIONAL: Bidirectional binding; if either the
 *  property of the source or the property of the target changes,
 *  the other is updated.
 *   @G _BINDING_SYNC_CREATE: Synchronize the values of the source and
 *  target properties when creating the binding; the direction of
 *  the synchronization is always from the source to the target.
 *   @G _BINDING_INVERT_BOOLEAN: If the two properties being bound are
 *  booleans, setting one to %TRUE will result in the other being
 *  set to %FALSE and vice versa. This flag will only work for
 *  boolean properties, and cannot be used when passing custom
 *  transformation functions to g_object_bind_property_full().
 *  
 *  Flags to be passed to g_object_bind_property() or
 *  g_object_bind_property_full().
 *  
 *  This enumeration can be extended at later date.
 *  
 *  Since: 2.26
 */
[AllowDuplicates] enum GBindingFlags : c_int
{
	Default = 0,
	Bidirectional = 1 << 0,
	SyncCreate = 1 << 1,
	InvertBoolean = 1 << 2,
}

extension GObject
{
	[LinkName("g_binding_flags_get_type")] public static extern GType BindingFlagsGetType();
	[LinkName("g_binding_get_type")] public static extern GType BindingGetType();
	[LinkName("g_binding_get_flags")] public static extern GBindingFlags BindingGetFlags(GBinding* binding);
	[LinkName("g_binding_get_source")] public static extern GObject* BindingGetSource(GBinding* binding);
	[LinkName("g_binding_dup_source")] public static extern GObject* BindingDupSource(GBinding* binding);
	[LinkName("g_binding_get_target")] public static extern GObject* BindingGetTarget(GBinding* binding);
	[LinkName("g_binding_dup_target")] public static extern GObject* BindingDupTarget(GBinding* binding);
	[LinkName("g_binding_get_source_property")] public static extern gchar* BindingGetSourceProperty(GBinding* binding);
	[LinkName("g_binding_get_target_property")] public static extern gchar* BindingGetTargetProperty(GBinding* binding);
	[LinkName("g_binding_unbind")] public static extern void BindingUnbind(GBinding* binding);
	[LinkName("g_object_bind_property")] public static extern GBinding* ObjectBindProperty(gpointer source, gchar* source_property, gpointer target, gchar* target_property, GBindingFlags flags);
	[LinkName("g_object_bind_property_full")] public static extern GBinding* ObjectBindPropertyFull(gpointer source, gchar* source_property, gpointer target, gchar* target_property, GBindingFlags flags, GBindingTransformFunc transform_to, GBindingTransformFunc transform_from, gpointer user_data, GDestroyNotify notify);
	[LinkName("g_object_bind_property_with_closures")] public static extern GBinding* ObjectBindPropertyWithClosures(gpointer source, gchar* source_property, gpointer target, gchar* target_property, GBindingFlags flags, GClosure* transform_to, GClosure* transform_from);
}

struct GBindingGroup;

extension GObject
{
	[LinkName("g_binding_group_get_type")] public static extern GType BindingGroupGetType();
	[LinkName("g_binding_group_new")] public static extern GBindingGroup* BindingGroupNew();
	[LinkName("g_binding_group_dup_source")] public static extern gpointer BindingGroupDupSource(GBindingGroup* self);
	[LinkName("g_binding_group_set_source")] public static extern void BindingGroupSetSource(GBindingGroup* self, gpointer source);
	[LinkName("g_binding_group_bind")] public static extern void BindingGroupBind(GBindingGroup* self, gchar* source_property, gpointer target, gchar* target_property, GBindingFlags flags);
	[LinkName("g_binding_group_bind_full")] public static extern void BindingGroupBindFull(GBindingGroup* self, gchar* source_property, gpointer target, gchar* target_property, GBindingFlags flags, GBindingTransformFunc transform_to, GBindingTransformFunc transform_from, gpointer user_data, GDestroyNotify user_data_destroy);
	[LinkName("g_binding_group_bind_with_closures")] public static extern void BindingGroupBindWithClosures(GBindingGroup* self, gchar* source_property, gpointer target, gchar* target_property, GBindingFlags flags, GClosure* transform_to, GClosure* transform_from);
}





/** GEnumClass:
 *   @g _type_class: the parent class
 *   @minimum : the smallest possible value.
 *   @maximum : the largest possible value.
 *   @n _values: the number of possible values.
 *   @values : an array of #GEnumValue structs describing the
 *  individual values.
 *  
 *  The class of an enumeration type holds information about its
 *  possible values.
 */
[CRepr] struct GEnumClass
{
	public GTypeClass g_type_class;
	public gint minimum;
	public gint maximum;
	public guint n_values;
	public GEnumValue* values;
}

/** GFlagsClass:
 *   @g _type_class: the parent class
 *   @mask : a mask covering all possible values.
 *   @n _values: the number of possible values.
 *   @values : an array of #GFlagsValue structs describing the
 *  individual values.
 *  
 *  The class of a flags type holds information about its
 *  possible values.
 */
[CRepr] struct GFlagsClass
{
	public GTypeClass g_type_class;
	public guint mask;
	public guint n_values;
	public GFlagsValue* values;
}

/** GEnumValue:
 *   @value : the enum value
 *   @value _name: the name of the value
 *   @value _nick: the nickname of the value
 *  
 *  A structure which contains a single enum value, its name, and its
 *  nickname.
 */
[CRepr] struct GEnumValue
{
	public gint value;
	public gchar* value_name;
	public gchar* value_nick;
}

/** GFlagsValue:
 *   @value : the flags value
 *   @value _name: the name of the value
 *   @value _nick: the nickname of the value
 *  
 *  A structure which contains a single flags value, its name, and its
 *  nickname.
 */
[CRepr] struct GFlagsValue
{
	public guint value;
	public gchar* value_name;
	public gchar* value_nick;
}

extension GObject
{
	[LinkName("g_enum_get_value")] public static extern GEnumValue* EnumGetValue(GEnumClass* enum_class, gint value);
	[LinkName("g_enum_get_value_by_name")] public static extern GEnumValue* EnumGetValueByName(GEnumClass* enum_class, gchar* name);
	[LinkName("g_enum_get_value_by_nick")] public static extern GEnumValue* EnumGetValueByNick(GEnumClass* enum_class, gchar* nick);
	[LinkName("g_flags_get_first_value")] public static extern GFlagsValue* FlagsGetFirstValue(GFlagsClass* flags_class, guint value);
	[LinkName("g_flags_get_value_by_name")] public static extern GFlagsValue* FlagsGetValueByName(GFlagsClass* flags_class, gchar* name);
	[LinkName("g_flags_get_value_by_nick")] public static extern GFlagsValue* FlagsGetValueByNick(GFlagsClass* flags_class, gchar* nick);
	[LinkName("g_enum_to_string")] public static extern gchar* EnumToString(GType g_enum_type, gint value);
	[LinkName("g_flags_to_string")] public static extern gchar* FlagsToString(GType flags_type, guint value);
	[LinkName("g_value_set_enum")] public static extern void ValueSetEnum(GValue* value, gint v_enum);
	[LinkName("g_value_get_enum")] public static extern gint ValueGetEnum(GValue* value);
	[LinkName("g_value_set_flags")] public static extern void ValueSetFlags(GValue* value, guint v_flags);
	[LinkName("g_value_get_flags")] public static extern guint ValueGetFlags(GValue* value);
	[LinkName("g_enum_register_static")] public static extern GType EnumRegisterStatic(gchar* name, GEnumValue* const_static_values);
	[LinkName("g_flags_register_static")] public static extern GType FlagsRegisterStatic(gchar* name, GFlagsValue* const_static_values);
	[LinkName("g_enum_complete_type_info")] public static extern void EnumCompleteTypeInfo(GType g_enum_type, GTypeInfo* info, GEnumValue* const_values);
	[LinkName("g_flags_complete_type_info")] public static extern void FlagsCompleteTypeInfo(GType g_flags_type, GTypeInfo* info, GFlagsValue* const_values);
	[LinkName("g_unicode_type_get_type")] public static extern GType UnicodeTypeGetType();
	[LinkName("g_unicode_break_type_get_type")] public static extern GType UnicodeBreakTypeGetType();
	[LinkName("g_unicode_script_get_type")] public static extern GType UnicodeScriptGetType();
	[LinkName("g_normalize_mode_get_type")] public static extern GType NormalizeModeGetType();
}
























/** GParamSpecChar:
 *   @parent _instance: private #GParamSpec portion
 *   @minimum : minimum value for the property specified
 *   @maximum : maximum value for the property specified
 *   @default _value: default value for the property specified
 *  
 *  A #GParamSpec derived structure that contains the meta data for character properties.
 */
[CRepr] struct GParamSpecChar
{
	public GParamSpec parent_instance;
	public gint8 minimum;
	public gint8 maximum;
	public gint8 default_value;
}

/** GParamSpecUChar:
 *   @parent _instance: private #GParamSpec portion
 *   @minimum : minimum value for the property specified
 *   @maximum : maximum value for the property specified
 *   @default _value: default value for the property specified
 *  
 *  A #GParamSpec derived structure that contains the meta data for unsigned character properties.
 */
[CRepr] struct GParamSpecUChar
{
	public GParamSpec parent_instance;
	public guint8 minimum;
	public guint8 maximum;
	public guint8 default_value;
}

/** GParamSpecBoolean:
 *   @parent _instance: private #GParamSpec portion
 *   @default _value: default value for the property specified
 *  
 *  A #GParamSpec derived structure that contains the meta data for boolean properties.
 */
[CRepr] struct GParamSpecBoolean
{
	public GParamSpec parent_instance;
	public gboolean default_value;
}

/** GParamSpecInt:
 *   @parent _instance: private #GParamSpec portion
 *   @minimum : minimum value for the property specified
 *   @maximum : maximum value for the property specified
 *   @default _value: default value for the property specified
 *  
 *  A #GParamSpec derived structure that contains the meta data for integer properties.
 */
[CRepr] struct GParamSpecInt
{
	public GParamSpec parent_instance;
	public gint minimum;
	public gint maximum;
	public gint default_value;
}

/** GParamSpecUInt:
 *   @parent _instance: private #GParamSpec portion
 *   @minimum : minimum value for the property specified
 *   @maximum : maximum value for the property specified
 *   @default _value: default value for the property specified
 *  
 *  A #GParamSpec derived structure that contains the meta data for unsigned integer properties.
 */
[CRepr] struct GParamSpecUInt
{
	public GParamSpec parent_instance;
	public guint minimum;
	public guint maximum;
	public guint default_value;
}

/** GParamSpecLong:
 *   @parent _instance: private #GParamSpec portion
 *   @minimum : minimum value for the property specified
 *   @maximum : maximum value for the property specified
 *   @default _value: default value for the property specified
 *  
 *  A #GParamSpec derived structure that contains the meta data for long integer properties.
 */
[CRepr] struct GParamSpecLong
{
	public GParamSpec parent_instance;
	public glong minimum;
	public glong maximum;
	public glong default_value;
}

/** GParamSpecULong:
 *   @parent _instance: private #GParamSpec portion
 *   @minimum : minimum value for the property specified
 *   @maximum : maximum value for the property specified
 *   @default _value: default value for the property specified
 *  
 *  A #GParamSpec derived structure that contains the meta data for unsigned long integer properties.
 */
[CRepr] struct GParamSpecULong
{
	public GParamSpec parent_instance;
	public gulong minimum;
	public gulong maximum;
	public gulong default_value;
}

/** GParamSpecInt64:
 *   @parent _instance: private #GParamSpec portion
 *   @minimum : minimum value for the property specified
 *   @maximum : maximum value for the property specified
 *   @default _value: default value for the property specified
 *  
 *  A #GParamSpec derived structure that contains the meta data for 64bit integer properties.
 */
[CRepr] struct GParamSpecInt64
{
	public GParamSpec parent_instance;
	public gint64 minimum;
	public gint64 maximum;
	public gint64 default_value;
}

/** GParamSpecUInt64:
 *   @parent _instance: private #GParamSpec portion
 *   @minimum : minimum value for the property specified
 *   @maximum : maximum value for the property specified
 *   @default _value: default value for the property specified
 *  
 *  A #GParamSpec derived structure that contains the meta data for unsigned 64bit integer properties.
 */
[CRepr] struct GParamSpecUInt64
{
	public GParamSpec parent_instance;
	public guint64 minimum;
	public guint64 maximum;
	public guint64 default_value;
}

/** GParamSpecUnichar:
 *   @parent _instance: private #GParamSpec portion
 *   @default _value: default value for the property specified
 *  
 *  A #GParamSpec derived structure that contains the meta data for unichar (unsigned integer) properties.
 */
[CRepr] struct GParamSpecUnichar
{
	public GParamSpec parent_instance;
	public gunichar default_value;
}

/** GParamSpecEnum:
 *   @parent _instance: private #GParamSpec portion
 *  
 *  `_class: the #GEnumClass for the enum`
 *  
 *   @default _value: default value for the property specified
 *  
 *  A #GParamSpec derived structure that contains the meta data for enum
 *  properties.
 */
[CRepr] struct GParamSpecEnum
{
	public GParamSpec parent_instance;
	public GEnumClass* enum_class;
	public gint default_value;
}

/** GParamSpecFlags:
 *   @parent _instance: private #GParamSpec portion
 *   @flags _class: the #GFlagsClass for the flags
 *   @default _value: default value for the property specified
 *  
 *  A #GParamSpec derived structure that contains the meta data for flags
 *  properties.
 */
[CRepr] struct GParamSpecFlags
{
	public GParamSpec parent_instance;
	public GFlagsClass* flags_class;
	public guint default_value;
}

/** GParamSpecFloat:
 *   @parent _instance: private #GParamSpec portion
 *   @minimum : minimum value for the property specified
 *   @maximum : maximum value for the property specified
 *   @default _value: default value for the property specified
 *   @epsilon : values closer than @epsilon will be considered identical
 *  by g_param_values_cmp(); the default value is 1e-30.
 *  
 *  A #GParamSpec derived structure that contains the meta data for float properties.
 */
[CRepr] struct GParamSpecFloat
{
	public GParamSpec parent_instance;
	public gfloat minimum;
	public gfloat maximum;
	public gfloat default_value;
	public gfloat epsilon;
}

/** GParamSpecDouble:
 *   @parent _instance: private #GParamSpec portion
 *   @minimum : minimum value for the property specified
 *   @maximum : maximum value for the property specified
 *   @default _value: default value for the property specified
 *   @epsilon : values closer than @epsilon will be considered identical
 *  by g_param_values_cmp(); the default value is 1e-90.
 *  
 *  A #GParamSpec derived structure that contains the meta data for double properties.
 */
[CRepr] struct GParamSpecDouble
{
	public GParamSpec parent_instance;
	public gdouble minimum;
	public gdouble maximum;
	public gdouble default_value;
	public gdouble epsilon;
}

/** GParamSpecString:
 *   @parent _instance: private #GParamSpec portion
 *   @default _value: default value for the property specified
 *   @cset _first: a string containing the allowed values for the first byte
 *   @cset _nth: a string containing the allowed values for the subsequent bytes
 *   @substitutor : the replacement byte for bytes which don't match @cset _first or @cset _nth.
 *   @null _fold_if_empty: replace empty string by %NULL
 *   @ensure _non_null: replace %NULL strings by an empty string
 *  
 *  A #GParamSpec derived structure that contains the meta data for string
 *  properties.
 */
[CRepr] struct GParamSpecString
{
	public GParamSpec parent_instance;
	public gchar* default_value;
	public gchar* cset_first;
	public gchar* cset_nth;
	public gchar substitutor;
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 0), "null_fold_if_empty")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 1), "ensure_non_null")]
	private uint32 __bitfield_2913226;
}

/** GParamSpecParam:
 *   @parent _instance: private #GParamSpec portion
 *  
 *  A #GParamSpec derived structure that contains the meta data for %G_TYPE_PARAM
 *  properties.
 */
[CRepr] struct GParamSpecParam
{
	public GParamSpec parent_instance;
}

/** GParamSpecBoxed:
 *   @parent _instance: private #GParamSpec portion
 *  
 *  A #GParamSpec derived structure that contains the meta data for boxed properties.
 */
[CRepr] struct GParamSpecBoxed
{
	public GParamSpec parent_instance;
}

/** GParamSpecPointer:
 *   @parent _instance: private #GParamSpec portion
 *  
 *  A #GParamSpec derived structure that contains the meta data for pointer properties.
 */
[CRepr] struct GParamSpecPointer
{
	public GParamSpec parent_instance;
}

/** GParamSpecValueArray:
 *   @parent _instance: private #GParamSpec portion
 *   @element _spec: a #GParamSpec describing the elements contained in arrays of this property, may be %NULL
 *   @fixed _n_elements: if greater than 0, arrays of this property will always have this many elements
 *  
 *  A #GParamSpec derived structure that contains the meta data for #GValueArray properties.
 */
[CRepr] struct GParamSpecValueArray
{
	public GParamSpec parent_instance;
	public GParamSpec* element_spec;
	public guint fixed_n_elements;
}

/** GParamSpecObject:
 *   @parent _instance: private #GParamSpec portion
 *  
 *  A #GParamSpec derived structure that contains the meta data for object properties.
 */
[CRepr] struct GParamSpecObject
{
	public GParamSpec parent_instance;
}

/** GParamSpecOverride:
 *  
 *  A #GParamSpec derived structure that redirects operations to
 *  other types of #GParamSpec.
 *  
 *  All operations other than getting or setting the value are redirected,
 *  including accessing the nick and blurb, validating a value, and so
 *  forth.
 *  
 *  See g_param_spec_get_redirect_target() for retrieving the overridden
 *  property. #GParamSpecOverride is used in implementing
 *  g_object_class_override_property(), and will not be directly useful
 *  unless you are implementing a new base type similar to GObject.
 *  
 *  Since: 2.4
 */
[CRepr] struct GParamSpecOverride
{
	public GParamSpec parent_instance;
	public GParamSpec* overridden;
}

/** GParamSpecGType:
 *   @parent _instance: private #GParamSpec portion
 *  
 *  `_a_type: a #GType whose subtypes can occur as values`
 *  
 *  
 *  A #GParamSpec derived structure that contains the meta data for #GType properties.
 *  
 *  Since: 2.10
 */
[CRepr] struct GParamSpecGType
{
	public GParamSpec parent_instance;
	public GType is_a_type;
}

/** GParamSpecVariant:
 *   @parent _instance: private #GParamSpec portion
 *   @type : a #GVariantType, or %NULL
 *   @default _value: a #GVariant, or %NULL
 *  
 *  A #GParamSpec derived structure that contains the meta data for #GVariant properties.
 *  
 *  When comparing values with g_param_values_cmp(), scalar values with the same
 *  type will be compared with g_variant_compare(). Other non-%NULL variants will
 *  be checked for equality with g_variant_equal(), and their sort order is
 *  otherwise undefined. %NULL is ordered before non-%NULL variants. Two %NULL
 *  values compare equal.
 *  
 *  Since: 2.26
 */
[CRepr] struct GParamSpecVariant
{
	public GParamSpec parent_instance;
	public GVariantType* type;
	public GVariant* default_value;
	public gpointer[4] padding;
}

extension GObject
{
	[LinkName("g_param_spec_char")] public static extern GParamSpec* ParamSpecChar(gchar* name, gchar* nick, gchar* blurb, gint8 minimum, gint8 maximum, gint8 default_value, GParamFlags flags);
	[LinkName("g_param_spec_uchar")] public static extern GParamSpec* ParamSpecUchar(gchar* name, gchar* nick, gchar* blurb, guint8 minimum, guint8 maximum, guint8 default_value, GParamFlags flags);
	[LinkName("g_param_spec_boolean")] public static extern GParamSpec* ParamSpecBoolean(gchar* name, gchar* nick, gchar* blurb, gboolean default_value, GParamFlags flags);
	[LinkName("g_param_spec_int")] public static extern GParamSpec* ParamSpecInt(gchar* name, gchar* nick, gchar* blurb, gint minimum, gint maximum, gint default_value, GParamFlags flags);
	[LinkName("g_param_spec_uint")] public static extern GParamSpec* ParamSpecUint(gchar* name, gchar* nick, gchar* blurb, guint minimum, guint maximum, guint default_value, GParamFlags flags);
	[LinkName("g_param_spec_long")] public static extern GParamSpec* ParamSpecLong(gchar* name, gchar* nick, gchar* blurb, glong minimum, glong maximum, glong default_value, GParamFlags flags);
	[LinkName("g_param_spec_ulong")] public static extern GParamSpec* ParamSpecUlong(gchar* name, gchar* nick, gchar* blurb, gulong minimum, gulong maximum, gulong default_value, GParamFlags flags);
	[LinkName("g_param_spec_int64")] public static extern GParamSpec* ParamSpecInt64(gchar* name, gchar* nick, gchar* blurb, gint64 minimum, gint64 maximum, gint64 default_value, GParamFlags flags);
	[LinkName("g_param_spec_uint64")] public static extern GParamSpec* ParamSpecUint64(gchar* name, gchar* nick, gchar* blurb, guint64 minimum, guint64 maximum, guint64 default_value, GParamFlags flags);
	[LinkName("g_param_spec_unichar")] public static extern GParamSpec* ParamSpecUnichar(gchar* name, gchar* nick, gchar* blurb, gunichar default_value, GParamFlags flags);
	[LinkName("g_param_spec_enum")] public static extern GParamSpec* ParamSpecEnum(gchar* name, gchar* nick, gchar* blurb, GType enum_type, gint default_value, GParamFlags flags);
	[LinkName("g_param_spec_flags")] public static extern GParamSpec* ParamSpecFlags(gchar* name, gchar* nick, gchar* blurb, GType flags_type, guint default_value, GParamFlags flags);
	[LinkName("g_param_spec_float")] public static extern GParamSpec* ParamSpecFloat(gchar* name, gchar* nick, gchar* blurb, gfloat minimum, gfloat maximum, gfloat default_value, GParamFlags flags);
	[LinkName("g_param_spec_double")] public static extern GParamSpec* ParamSpecDouble(gchar* name, gchar* nick, gchar* blurb, gdouble minimum, gdouble maximum, gdouble default_value, GParamFlags flags);
	[LinkName("g_param_spec_string")] public static extern GParamSpec* ParamSpecString(gchar* name, gchar* nick, gchar* blurb, gchar* default_value, GParamFlags flags);
	[LinkName("g_param_spec_param")] public static extern GParamSpec* ParamSpecParam(gchar* name, gchar* nick, gchar* blurb, GType param_type, GParamFlags flags);
	[LinkName("g_param_spec_boxed")] public static extern GParamSpec* ParamSpecBoxed(gchar* name, gchar* nick, gchar* blurb, GType boxed_type, GParamFlags flags);
	[LinkName("g_param_spec_pointer")] public static extern GParamSpec* ParamSpecPointer(gchar* name, gchar* nick, gchar* blurb, GParamFlags flags);
	[LinkName("g_param_spec_value_array")] public static extern GParamSpec* ParamSpecValueArray(gchar* name, gchar* nick, gchar* blurb, GParamSpec* element_spec, GParamFlags flags);
	[LinkName("g_param_spec_object")] public static extern GParamSpec* ParamSpecObject(gchar* name, gchar* nick, gchar* blurb, GType object_type, GParamFlags flags);
	[LinkName("g_param_spec_override")] public static extern GParamSpec* ParamSpecOverride(gchar* name, GParamSpec* overridden);
	[LinkName("g_param_spec_gtype")] public static extern GParamSpec* ParamSpecGtype(gchar* name, gchar* nick, gchar* blurb, GType is_a_type, GParamFlags flags);
	[LinkName("g_param_spec_variant")] public static extern GParamSpec* ParamSpecVariant(gchar* name, gchar* nick, gchar* blurb, GVariantType* type, GVariant* default_value, GParamFlags flags);
}

static
{
	[CLink] public static extern GType* g_param_spec_types;
}

struct GSignalGroup;

extension GObject
{
	[LinkName("g_signal_group_get_type")] public static extern GType SignalGroupGetType();
	[LinkName("g_signal_group_new")] public static extern GSignalGroup* SignalGroupNew(GType target_type);
	[LinkName("g_signal_group_set_target")] public static extern void SignalGroupSetTarget(GSignalGroup* self, gpointer target);
	[LinkName("g_signal_group_dup_target")] public static extern gpointer SignalGroupDupTarget(GSignalGroup* self);
	[LinkName("g_signal_group_block")] public static extern void SignalGroupBlock(GSignalGroup* self);
	[LinkName("g_signal_group_unblock")] public static extern void SignalGroupUnblock(GSignalGroup* self);
	[LinkName("g_signal_group_connect_closure")] public static extern void SignalGroupConnectClosure(GSignalGroup* self, gchar* detailed_signal, GClosure* closure, gboolean after);
	[LinkName("g_signal_group_connect_object")] public static extern void SignalGroupConnectObject(GSignalGroup* self, gchar* detailed_signal, GCallback c_handler, gpointer object, GConnectFlags flags);
	[LinkName("g_signal_group_connect_data")] public static extern void SignalGroupConnectData(GSignalGroup* self, gchar* detailed_signal, GCallback c_handler, gpointer data, GClosureNotify notify, GConnectFlags flags);
	[LinkName("g_signal_group_connect")] public static extern void SignalGroupConnect(GSignalGroup* self, gchar* detailed_signal, GCallback c_handler, gpointer data);
	[LinkName("g_signal_group_connect_after")] public static extern void SignalGroupConnectAfter(GSignalGroup* self, gchar* detailed_signal, GCallback c_handler, gpointer data);
	[LinkName("g_signal_group_connect_swapped")] public static extern void SignalGroupConnectSwapped(GSignalGroup* self, gchar* detailed_signal, GCallback c_handler, gpointer data);
	[LinkName("g_source_set_closure")] public static extern void SourceSetClosure(GSource* source, GClosure* closure);
	[LinkName("g_source_set_dummy_callback")] public static extern void SourceSetDummyCallback(GSource* source);
}



typealias GTypeModule_autoptr = GTypeModule*;

typealias GTypeModule_listautoptr = GList*;

typealias GTypeModule_slistautoptr = GSList*;

typealias GTypeModule_queueautoptr = GQueue*;

[CRepr] struct GTypeModule
{
	public GObject parent_instance;
	public guint use_count;
	public GSList* type_infos;
	public GSList* interface_infos;
	public gchar* name;
}

/** GTypeModuleClass:
 *   @parent _class: the parent class
 *   @load : loads the module and registers one or more types using
 *  g_type_module_register_type().
 *   @unload : unloads the module
 *  
 *  In order to implement dynamic loading of types based on #GTypeModule,
 *  the @load and @unload functions in #GTypeModuleClass must be implemented.
 */
[CRepr] struct GTypeModuleClass
{
	public GObjectClass parent_class;
	public function gboolean(GTypeModule*) load;
	public function void(GTypeModule*) unload;
	public function void() reserved1;
	public function void() reserved2;
	public function void() reserved3;
	public function void() reserved4;
}

extension GObject
{
	[LinkName("g_type_module_get_type")] public static extern GType TypeModuleGetType();
	[LinkName("g_type_module_use")] public static extern gboolean TypeModuleUse(GTypeModule* module);
	[LinkName("g_type_module_unuse")] public static extern void TypeModuleUnuse(GTypeModule* module);
	[LinkName("g_type_module_set_name")] public static extern void TypeModuleSetName(GTypeModule* module, gchar* name);
	[LinkName("g_type_module_register_type")] public static extern GType TypeModuleRegisterType(GTypeModule* module, GType parent_type, gchar* type_name, GTypeInfo* type_info, GTypeFlags flags);
	[LinkName("g_type_module_add_interface")] public static extern void TypeModuleAddInterface(GTypeModule* module, GType instance_type, GType interface_type, GInterfaceInfo* interface_info);
	[LinkName("g_type_module_register_enum")] public static extern GType TypeModuleRegisterEnum(GTypeModule* module, gchar* name, GEnumValue* const_static_values);
	[LinkName("g_type_module_register_flags")] public static extern GType TypeModuleRegisterFlags(GTypeModule* module, gchar* name, GFlagsValue* const_static_values);
}


/** GTypePluginUse:
 *   @plugin : the #GTypePlugin whose use count should be increased
 *  
 *  The type of the @use _plugin function of #GTypePluginClass, which gets called
 *  to increase the use count of @plugin .
 */
function void GTypePluginUse(GTypePlugin* plugin);

/** GTypePluginUnuse:
 *   @plugin : the #GTypePlugin whose use count should be decreased
 *  
 *  The type of the @unuse _plugin function of #GTypePluginClass.
 */
function void GTypePluginUnuse(GTypePlugin* plugin);

/** GTypePluginCompleteTypeInfo:
 *   @plugin : the #GTypePlugin
 *   @g _type: the #GType whose info is completed
 *   @info : the #GTypeInfo struct to fill in
 *   @value _table: the #GTypeValueTable to fill in
 *  
 *  The type of the @complete _type_info function of #GTypePluginClass.
 */
function void GTypePluginCompleteTypeInfo(GTypePlugin* plugin, GType g_type, GTypeInfo* info, GTypeValueTable* value_table);

/** GTypePluginCompleteInterfaceInfo:
 *   @plugin : the #GTypePlugin
 *   @instance _type: the #GType of an instantiatable type to which the interface
 *  is added
 *  
 *  `_type: the #GType of the interface whose info is completed`
 *  
 *   @info : the #GInterfaceInfo to fill in
 *  
 *  The type of the @complete _interface_info function of #GTypePluginClass.
 */
function void GTypePluginCompleteInterfaceInfo(GTypePlugin* plugin, GType instance_type, GType interface_type, GInterfaceInfo* info);

/** GTypePluginClass:
 *   @use _plugin: Increases the use count of the plugin.
 *   @unuse _plugin: Decreases the use count of the plugin.
 *   @complete _type_info: Fills in the #GTypeInfo and
 *  #GTypeValueTable structs for the type. The structs are initialized
 *  with `memset(s, 0, sizeof (s))` before calling this function.
 *   @complete _interface_info: Fills in missing parts of the #GInterfaceInfo
 *  for the interface. The structs is initialized with
 *  `memset(s, 0, sizeof (s))` before calling this function.
 *  
 *  The #GTypePlugin interface is used by the type system in order to handle
 *  the lifecycle of dynamically loaded types.
 */
[CRepr] struct GTypePluginClass
{
	public GTypeInterface base_iface;
	public GTypePluginUse use_plugin;
	public GTypePluginUnuse unuse_plugin;
	public GTypePluginCompleteTypeInfo complete_type_info;
	public GTypePluginCompleteInterfaceInfo complete_interface_info;
}

extension GObject
{
	[LinkName("g_type_plugin_get_type")] public static extern GType TypePluginGetType();
	[LinkName("g_type_plugin_use")] public static extern void TypePluginUse(GTypePlugin* plugin);
	[LinkName("g_type_plugin_unuse")] public static extern void TypePluginUnuse(GTypePlugin* plugin);
	[LinkName("g_type_plugin_complete_type_info")] public static extern void TypePluginCompleteTypeInfo(GTypePlugin* plugin, GType g_type, GTypeInfo* info, GTypeValueTable* value_table);
	[LinkName("g_type_plugin_complete_interface_info")] public static extern void TypePluginCompleteInterfaceInfo(GTypePlugin* plugin, GType instance_type, GType interface_type, GInterfaceInfo* info);
}


[CRepr] struct GValueArray
{
	public guint n_values;
	public GValue* values;
	public guint n_prealloced;
}

extension GObject
{
	[LinkName("g_value_array_get_type")] public static extern GType ValueArrayGetType();
	[LinkName("g_value_array_get_nth")] public static extern GValue* ValueArrayGetNth(GValueArray* value_array, guint index);
	[LinkName("g_value_array_new")] public static extern GValueArray* ValueArrayNew(guint n_prealloced);
	[LinkName("g_value_array_free")] public static extern void ValueArrayFree(GValueArray* value_array);
	[LinkName("g_value_array_copy")] public static extern GValueArray* ValueArrayCopy(GValueArray* value_array);
	[LinkName("g_value_array_prepend")] public static extern GValueArray* ValueArrayPrepend(GValueArray* value_array, GValue* value);
	[LinkName("g_value_array_append")] public static extern GValueArray* ValueArrayAppend(GValueArray* value_array, GValue* value);
	[LinkName("g_value_array_insert")] public static extern GValueArray* ValueArrayInsert(GValueArray* value_array, guint index, GValue* value);
	[LinkName("g_value_array_remove")] public static extern GValueArray* ValueArrayRemove(GValueArray* value_array, guint index);
	[LinkName("g_value_array_sort")] public static extern GValueArray* ValueArraySort(GValueArray* value_array, GCompareFunc compare_func);
	[LinkName("g_value_array_sort_with_data")] public static extern GValueArray* ValueArraySortWithData(GValueArray* value_array, GCompareDataFunc compare_func, gpointer user_data);
	[LinkName("g_value_set_char")] public static extern void ValueSetChar(GValue* value, gchar v_char);
	[LinkName("g_value_get_char")] public static extern gchar ValueGetChar(GValue* value);
	[LinkName("g_value_set_schar")] public static extern void ValueSetSchar(GValue* value, gint8 v_char);
	[LinkName("g_value_get_schar")] public static extern gint8 ValueGetSchar(GValue* value);
	[LinkName("g_value_set_uchar")] public static extern void ValueSetUchar(GValue* value, guchar v_uchar);
	[LinkName("g_value_get_uchar")] public static extern guchar ValueGetUchar(GValue* value);
	[LinkName("g_value_set_boolean")] public static extern void ValueSetBoolean(GValue* value, gboolean v_boolean);
	[LinkName("g_value_get_boolean")] public static extern gboolean ValueGetBoolean(GValue* value);
	[LinkName("g_value_set_int")] public static extern void ValueSetInt(GValue* value, gint v_int);
	[LinkName("g_value_get_int")] public static extern gint ValueGetInt(GValue* value);
	[LinkName("g_value_set_uint")] public static extern void ValueSetUint(GValue* value, guint v_uint);
	[LinkName("g_value_get_uint")] public static extern guint ValueGetUint(GValue* value);
	[LinkName("g_value_set_long")] public static extern void ValueSetLong(GValue* value, glong v_long);
	[LinkName("g_value_get_long")] public static extern glong ValueGetLong(GValue* value);
	[LinkName("g_value_set_ulong")] public static extern void ValueSetUlong(GValue* value, gulong v_ulong);
	[LinkName("g_value_get_ulong")] public static extern gulong ValueGetUlong(GValue* value);
	[LinkName("g_value_set_int64")] public static extern void ValueSetInt64(GValue* value, gint64 v_int64);
	[LinkName("g_value_get_int64")] public static extern gint64 ValueGetInt64(GValue* value);
	[LinkName("g_value_set_uint64")] public static extern void ValueSetUint64(GValue* value, guint64 v_uint64);
	[LinkName("g_value_get_uint64")] public static extern guint64 ValueGetUint64(GValue* value);
	[LinkName("g_value_set_float")] public static extern void ValueSetFloat(GValue* value, gfloat v_float);
	[LinkName("g_value_get_float")] public static extern gfloat ValueGetFloat(GValue* value);
	[LinkName("g_value_set_double")] public static extern void ValueSetDouble(GValue* value, gdouble v_double);
	[LinkName("g_value_get_double")] public static extern gdouble ValueGetDouble(GValue* value);
	[LinkName("g_value_set_string")] public static extern void ValueSetString(GValue* value, gchar* v_string);
	[LinkName("g_value_set_static_string")] public static extern void ValueSetStaticString(GValue* value, gchar* v_string);
	[LinkName("g_value_set_interned_string")] public static extern void ValueSetInternedString(GValue* value, gchar* v_string);
	[LinkName("g_value_get_string")] public static extern gchar* ValueGetString(GValue* value);
	[LinkName("g_value_dup_string")] public static extern gchar* ValueDupString(GValue* value);
	[LinkName("g_value_steal_string")] public static extern gchar* ValueStealString(GValue* value);
	[LinkName("g_value_set_pointer")] public static extern void ValueSetPointer(GValue* value, gpointer v_pointer);
	[LinkName("g_value_get_pointer")] public static extern gpointer ValueGetPointer(GValue* value);
	[LinkName("g_gtype_get_type")] public static extern GType GtypeGetType();
	[LinkName("g_value_set_gtype")] public static extern void ValueSetGtype(GValue* value, GType v_gtype);
	[LinkName("g_value_get_gtype")] public static extern GType ValueGetGtype(GValue* value);
	[LinkName("g_value_set_variant")] public static extern void ValueSetVariant(GValue* value, GVariant* variant);
	[LinkName("g_value_take_variant")] public static extern void ValueTakeVariant(GValue* value, GVariant* variant);
	[LinkName("g_value_get_variant")] public static extern GVariant* ValueGetVariant(GValue* value);
	[LinkName("g_value_dup_variant")] public static extern GVariant* ValueDupVariant(GValue* value);
	[LinkName("g_pointer_type_register_static")] public static extern GType PointerTypeRegisterStatic(gchar* name);
	[LinkName("g_strdup_value_contents")] public static extern gchar* StrdupValueContents(GValue* value);
	[LinkName("g_value_take_string")] public static extern void ValueTakeString(GValue* value, gchar* v_string);
	[LinkName("g_value_set_string_take_ownership")] public static extern void ValueSetStringTakeOwnership(GValue* value, gchar* v_string);
}

/** gchararray:
 *  
 *  A C representable type name for %G_TYPE_STRING.
 */
typealias gchararray = gchar*;

typealias GClosure_autoptr = GClosure*;

typealias GClosure_listautoptr = GList*;

typealias GClosure_slistautoptr = GSList*;

typealias GClosure_queueautoptr = GQueue*;

typealias GEnumClass_autoptr = GEnumClass*;

typealias GEnumClass_listautoptr = GList*;

typealias GEnumClass_slistautoptr = GSList*;

typealias GEnumClass_queueautoptr = GQueue*;

typealias GFlagsClass_autoptr = GFlagsClass*;

typealias GFlagsClass_listautoptr = GList*;

typealias GFlagsClass_slistautoptr = GSList*;

typealias GFlagsClass_queueautoptr = GQueue*;

typealias GObject_autoptr = GObject*;

typealias GObject_listautoptr = GList*;

typealias GObject_slistautoptr = GSList*;

typealias GObject_queueautoptr = GQueue*;

typealias GInitiallyUnowned_autoptr = GInitiallyUnowned*;

typealias GInitiallyUnowned_listautoptr = GList*;

typealias GInitiallyUnowned_slistautoptr = GSList*;

typealias GInitiallyUnowned_queueautoptr = GQueue*;

typealias GParamSpec_autoptr = GParamSpec*;

typealias GParamSpec_listautoptr = GList*;

typealias GParamSpec_slistautoptr = GSList*;

typealias GParamSpec_queueautoptr = GQueue*;

typealias GTypeClass_autoptr = GTypeClass*;

typealias GTypeClass_listautoptr = GList*;

typealias GTypeClass_slistautoptr = GSList*;

typealias GTypeClass_queueautoptr = GQueue*;
