/* Auto generated by https://github.com/Rune-Magic/C2Beef-Binding-Generator
 * DO NOT EDIT
 */

using System;
using System.Interop;

namespace GLib;

typealias gchar = c_char;

typealias gshort = c_short;

typealias glong = c_long;

typealias gint = c_int;

typealias gboolean = gint;

typealias guchar = c_uchar;

typealias gushort = c_ushort;

typealias gulong = c_ulong;

typealias guint = c_uint;

typealias gfloat = float;

typealias gdouble = double;

typealias gpointer = void*;

typealias gconstpointer = void*;

function gint GCompareFunc(gconstpointer a, gconstpointer b);

function gint GCompareDataFunc(gconstpointer a, gconstpointer b, gpointer user_data);

function gboolean GEqualFunc(gconstpointer a, gconstpointer b);

/** GEqualFuncFull:
 *   @a : a value
 *   @b : a value to compare with
 *   @user _data: user data provided by the caller
 *  
 *  Specifies the type of a function used to test two values for
 *  equality. The function should return %TRUE if both values are equal
 *  and %FALSE otherwise.
 *  
 *  This is a version of #GEqualFunc which provides a @user _data closure from
 *  the caller.
 *  
 *  Returns: %TRUE if @a =  @b ; %FALSE otherwise
 *  Since: 2.74
 */
function gboolean GEqualFuncFull(gconstpointer a, gconstpointer b, gpointer user_data);

function void GDestroyNotify(gpointer data);

function void GFunc(gpointer data, gpointer user_data);

function guint GHashFunc(gconstpointer key);

function void GHFunc(gpointer key, gpointer value, gpointer user_data);

/** GCopyFunc:
 *   @src : (not nullable): A pointer to the data which should be copied
 *  @date : Additional data
 *  
 *  A function of this signature is used to copy the node data
 *  when doing a deep-copy of a tree.
 *  
 *  Returns: (not nullable): A pointer to the copy
 *  
 *  Since: 2.4
 */
function gpointer GCopyFunc(gconstpointer src, gpointer data);

/** GFreeFunc:
 *  @date : a data pointer
 *  
 *  Declares a type of function which takes an arbitrary
 *  data pointer argument and has no return value. It is
 *  not currently used in GLib or GTK.
 */
function void GFreeFunc(gpointer data);

/** GTranslateFunc:
 *   @str : the untranslated string
 *  @date : user data specified when installing the function, e.g.
 *        in g_option_group_set_translate_func()
 *  
 *  The type of functions which are used to translate user-visible
 *  strings, for <option >--help </option > output.
 *  
 *  Returns: a translation of the string for the current locale.
 *  The returned string is owned by GLib and must not be freed.
 */
function gchar* GTranslateFunc(gchar* str, gpointer data);



[Union, CRepr] struct GFloatIEEE754
{
	public gfloat v_float;
	[CRepr]public  struct 
	{
		[Bitfield(.Public, .BitsAt(bits: 23, pos: 0), "mantissa")]
		[Bitfield(.Public, .BitsAt(bits: 8, pos: 23), "biased_exponent")]
		[Bitfield(.Public, .BitsAt(bits: 1, pos: 31), "sign")]
		private uint32 __bitfield_40702;
	} mpn;
}

[Union, CRepr] struct GDoubleIEEE754
{
	public gdouble v_double;
	[CRepr]public  struct 
	{
		[Bitfield(.Public, .BitsAt(bits: 32, pos: 0), "mantissa_low")]
		private uint32 __bitfield_40823;
		[Bitfield(.Public, .BitsAt(bits: 20, pos: 0), "mantissa_high")]
		[Bitfield(.Public, .BitsAt(bits: 11, pos: 20), "biased_exponent")]
		[Bitfield(.Public, .BitsAt(bits: 1, pos: 31), "sign")]
		private uint32 __bitfield_40880;
	} mpn;
}


[CRepr] struct GTimeVal
{
	public glong tv_sec;
	public glong tv_usec;
}

typealias grefcount = gint;

typealias gatomicrefcount = gint;

struct GBytes;




[CRepr] struct GArray
{
	public gchar* data;
	public guint len;
}

[CRepr] struct GByteArray
{
	public guint8* data;
	public guint len;
}

[CRepr] struct GPtrArray
{
	public gpointer* pdata;
	public guint len;
}

extension GLib
{
	[LinkName("g_array_new")] public static extern GArray* ArrayNew(gboolean zero_terminated, gboolean clear, guint element_size);
	[LinkName("g_array_new_take")] public static extern GArray* ArrayNewTake(gpointer data, gsize len, gboolean clear, gsize element_size);
	[LinkName("g_array_new_take_zero_terminated")] public static extern GArray* ArrayNewTakeZeroTerminated(gpointer data, gboolean clear, gsize element_size);
	[LinkName("g_array_steal")] public static extern gpointer ArraySteal(GArray* array, gsize* len);
	[LinkName("g_array_sized_new")] public static extern GArray* ArraySizedNew(gboolean zero_terminated, gboolean clear, guint element_size, guint reserved_size);
	[LinkName("g_array_copy")] public static extern GArray* ArrayCopy(GArray* array);
	[LinkName("g_array_free")] public static extern gchar* ArrayFree(GArray* array, gboolean free_segment);
	[LinkName("g_array_ref")] public static extern GArray* ArrayRef(GArray* array);
	[LinkName("g_array_unref")] public static extern void ArrayUnref(GArray* array);
	[LinkName("g_array_get_element_size")] public static extern guint ArrayGetElementSize(GArray* array);
	[LinkName("g_array_append_vals")] public static extern GArray* ArrayAppendVals(GArray* array, gconstpointer data, guint len);
	[LinkName("g_array_prepend_vals")] public static extern GArray* ArrayPrependVals(GArray* array, gconstpointer data, guint len);
	[LinkName("g_array_insert_vals")] public static extern GArray* ArrayInsertVals(GArray* array, guint index, gconstpointer data, guint len);
	[LinkName("g_array_set_size")] public static extern GArray* ArraySetSize(GArray* array, guint length);
	[LinkName("g_array_remove_index")] public static extern GArray* ArrayRemoveIndex(GArray* array, guint index);
	[LinkName("g_array_remove_index_fast")] public static extern GArray* ArrayRemoveIndexFast(GArray* array, guint index);
	[LinkName("g_array_remove_range")] public static extern GArray* ArrayRemoveRange(GArray* array, guint index, guint length);
	[LinkName("g_array_sort")] public static extern void ArraySort(GArray* array, GCompareFunc compare_func);
	[LinkName("g_array_sort_with_data")] public static extern void ArraySortWithData(GArray* array, GCompareDataFunc compare_func, gpointer user_data);
	[LinkName("g_array_binary_search")] public static extern gboolean ArrayBinarySearch(GArray* array, gconstpointer target, GCompareFunc compare_func, guint* out_match_index);
	[LinkName("g_array_set_clear_func")] public static extern void ArraySetClearFunc(GArray* array, GDestroyNotify clear_func);
	[LinkName("g_ptr_array_new")] public static extern GPtrArray* PtrArrayNew();
	[LinkName("g_ptr_array_new_with_free_func")] public static extern GPtrArray* PtrArrayNewWithFreeFunc(GDestroyNotify element_free_func);
	[LinkName("g_ptr_array_new_take")] public static extern GPtrArray* PtrArrayNewTake(gpointer* data, gsize len, GDestroyNotify element_free_func);
	[LinkName("g_ptr_array_new_from_array")] public static extern GPtrArray* PtrArrayNewFromArray(gpointer* data, gsize len, GCopyFunc copy_func, gpointer copy_func_user_data, GDestroyNotify element_free_func);
	[LinkName("g_ptr_array_steal")] public static extern gpointer* PtrArraySteal(GPtrArray* array, gsize* len);
	[LinkName("g_ptr_array_copy")] public static extern GPtrArray* PtrArrayCopy(GPtrArray* array, GCopyFunc func, gpointer user_data);
	[LinkName("g_ptr_array_sized_new")] public static extern GPtrArray* PtrArraySizedNew(guint reserved_size);
	[LinkName("g_ptr_array_new_full")] public static extern GPtrArray* PtrArrayNewFull(guint reserved_size, GDestroyNotify element_free_func);
	[LinkName("g_ptr_array_new_null_terminated")] public static extern GPtrArray* PtrArrayNewNullTerminated(guint reserved_size, GDestroyNotify element_free_func, gboolean null_terminated);
	[LinkName("g_ptr_array_new_take_null_terminated")] public static extern GPtrArray* PtrArrayNewTakeNullTerminated(gpointer* data, GDestroyNotify element_free_func);
	[LinkName("g_ptr_array_new_from_null_terminated_array")] public static extern GPtrArray* PtrArrayNewFromNullTerminatedArray(gpointer* data, GCopyFunc copy_func, gpointer copy_func_user_data, GDestroyNotify element_free_func);
	[LinkName("g_ptr_array_free")] public static extern gpointer* PtrArrayFree(GPtrArray* array, gboolean free_segment);
	[LinkName("g_ptr_array_ref")] public static extern GPtrArray* PtrArrayRef(GPtrArray* array);
	[LinkName("g_ptr_array_unref")] public static extern void PtrArrayUnref(GPtrArray* array);
	[LinkName("g_ptr_array_set_free_func")] public static extern void PtrArraySetFreeFunc(GPtrArray* array, GDestroyNotify element_free_func);
	[LinkName("g_ptr_array_set_size")] public static extern void PtrArraySetSize(GPtrArray* array, gint length);
	[LinkName("g_ptr_array_remove_index")] public static extern gpointer PtrArrayRemoveIndex(GPtrArray* array, guint index);
	[LinkName("g_ptr_array_remove_index_fast")] public static extern gpointer PtrArrayRemoveIndexFast(GPtrArray* array, guint index);
	[LinkName("g_ptr_array_steal_index")] public static extern gpointer PtrArrayStealIndex(GPtrArray* array, guint index);
	[LinkName("g_ptr_array_steal_index_fast")] public static extern gpointer PtrArrayStealIndexFast(GPtrArray* array, guint index);
	[LinkName("g_ptr_array_remove")] public static extern gboolean PtrArrayRemove(GPtrArray* array, gpointer data);
	[LinkName("g_ptr_array_remove_fast")] public static extern gboolean PtrArrayRemoveFast(GPtrArray* array, gpointer data);
	[LinkName("g_ptr_array_remove_range")] public static extern GPtrArray* PtrArrayRemoveRange(GPtrArray* array, guint index, guint length);
	[LinkName("g_ptr_array_add")] public static extern void PtrArrayAdd(GPtrArray* array, gpointer data);
	[LinkName("g_ptr_array_extend")] public static extern void PtrArrayExtend(GPtrArray* array_to_extend, GPtrArray* array, GCopyFunc func, gpointer user_data);
	[LinkName("g_ptr_array_extend_and_steal")] public static extern void PtrArrayExtendAndSteal(GPtrArray* array_to_extend, GPtrArray* array);
	[LinkName("g_ptr_array_insert")] public static extern void PtrArrayInsert(GPtrArray* array, gint index, gpointer data);
	[LinkName("g_ptr_array_sort")] public static extern void PtrArraySort(GPtrArray* array, GCompareFunc compare_func);
	[LinkName("g_ptr_array_sort_with_data")] public static extern void PtrArraySortWithData(GPtrArray* array, GCompareDataFunc compare_func, gpointer user_data);
	[LinkName("g_ptr_array_sort_values")] public static extern void PtrArraySortValues(GPtrArray* array, GCompareFunc compare_func);
	[LinkName("g_ptr_array_sort_values_with_data")] public static extern void PtrArraySortValuesWithData(GPtrArray* array, GCompareDataFunc compare_func, gpointer user_data);
	[LinkName("g_ptr_array_foreach")] public static extern void PtrArrayForeach(GPtrArray* array, GFunc func, gpointer user_data);
	[LinkName("g_ptr_array_find")] public static extern gboolean PtrArrayFind(GPtrArray* haystack, gconstpointer needle, guint* index);
	[LinkName("g_ptr_array_find_with_equal_func")] public static extern gboolean PtrArrayFindWithEqualFunc(GPtrArray* haystack, gconstpointer needle, GEqualFunc equal_func, guint* index);
	[LinkName("g_ptr_array_is_null_terminated")] public static extern gboolean PtrArrayIsNullTerminated(GPtrArray* array);
	[LinkName("g_byte_array_new")] public static extern GByteArray* ByteArrayNew();
	[LinkName("g_byte_array_new_take")] public static extern GByteArray* ByteArrayNewTake(guint8* data, gsize len);
	[LinkName("g_byte_array_steal")] public static extern guint8* ByteArraySteal(GByteArray* array, gsize* len);
	[LinkName("g_byte_array_sized_new")] public static extern GByteArray* ByteArraySizedNew(guint reserved_size);
	[LinkName("g_byte_array_free")] public static extern guint8* ByteArrayFree(GByteArray* array, gboolean free_segment);
	[LinkName("g_byte_array_free_to_bytes")] public static extern GBytes* ByteArrayFreeToBytes(GByteArray* array);
	[LinkName("g_byte_array_ref")] public static extern GByteArray* ByteArrayRef(GByteArray* array);
	[LinkName("g_byte_array_unref")] public static extern void ByteArrayUnref(GByteArray* array);
	[LinkName("g_byte_array_append")] public static extern GByteArray* ByteArrayAppend(GByteArray* array, guint8* data, guint len);
	[LinkName("g_byte_array_prepend")] public static extern GByteArray* ByteArrayPrepend(GByteArray* array, guint8* data, guint len);
	[LinkName("g_byte_array_set_size")] public static extern GByteArray* ByteArraySetSize(GByteArray* array, guint length);
	[LinkName("g_byte_array_remove_index")] public static extern GByteArray* ByteArrayRemoveIndex(GByteArray* array, guint index);
	[LinkName("g_byte_array_remove_index_fast")] public static extern GByteArray* ByteArrayRemoveIndexFast(GByteArray* array, guint index);
	[LinkName("g_byte_array_remove_range")] public static extern GByteArray* ByteArrayRemoveRange(GByteArray* array, guint index, guint length);
	[LinkName("g_byte_array_sort")] public static extern void ByteArraySort(GByteArray* array, GCompareFunc compare_func);
	[LinkName("g_byte_array_sort_with_data")] public static extern void ByteArraySortWithData(GByteArray* array, GCompareDataFunc compare_func, gpointer user_data);
	[LinkName("g_atomic_int_get")] public static extern gint AtomicIntGet(gint* atomic);
	[LinkName("g_atomic_int_set")] public static extern void AtomicIntSet(gint* atomic, gint newval);
	[LinkName("g_atomic_int_inc")] public static extern void AtomicIntInc(gint* atomic);
	[LinkName("g_atomic_int_dec_and_test")] public static extern gboolean AtomicIntDecAndTest(gint* atomic);
	[LinkName("g_atomic_int_compare_and_exchange")] public static extern gboolean AtomicIntCompareAndExchange(gint* atomic, gint oldval, gint newval);
	[LinkName("g_atomic_int_compare_and_exchange_full")] public static extern gboolean AtomicIntCompareAndExchangeFull(gint* atomic, gint oldval, gint newval, gint* preval);
	[LinkName("g_atomic_int_exchange")] public static extern gint AtomicIntExchange(gint* atomic, gint newval);
	[LinkName("g_atomic_int_add")] public static extern gint AtomicIntAdd(gint* atomic, gint val);
	[LinkName("g_atomic_int_and")] public static extern guint AtomicIntAnd(guint* atomic, guint val);
	[LinkName("g_atomic_int_or")] public static extern guint AtomicIntOr(guint* atomic, guint val);
	[LinkName("g_atomic_int_xor")] public static extern guint AtomicIntXor(guint* atomic, guint val);
	[LinkName("g_atomic_pointer_get")] public static extern gpointer AtomicPointerGet(void* atomic);
	[LinkName("g_atomic_pointer_set")] public static extern void AtomicPointerSet(void* atomic, gpointer newval);
	[LinkName("g_atomic_pointer_compare_and_exchange")] public static extern gboolean AtomicPointerCompareAndExchange(void* atomic, gpointer oldval, gpointer newval);
	[LinkName("g_atomic_pointer_compare_and_exchange_full")] public static extern gboolean AtomicPointerCompareAndExchangeFull(void* atomic, gpointer oldval, gpointer newval, void* preval);
	[LinkName("g_atomic_pointer_exchange")] public static extern gpointer AtomicPointerExchange(void* atomic, gpointer newval);
	[LinkName("g_atomic_pointer_add")] public static extern gintptr AtomicPointerAdd(void* atomic, gssize val);
	[LinkName("g_atomic_pointer_and")] public static extern guintptr AtomicPointerAnd(void* atomic, gsize val);
	[LinkName("g_atomic_pointer_or")] public static extern guintptr AtomicPointerOr(void* atomic, gsize val);
	[LinkName("g_atomic_pointer_xor")] public static extern guintptr AtomicPointerXor(void* atomic, gsize val);
	[LinkName("g_atomic_int_exchange_and_add")] public static extern gint AtomicIntExchangeAndAdd(gint* atomic, gint val);
}

typealias GQuark = guint32;

extension GLib
{
	[LinkName("g_quark_try_string")] public static extern GQuark QuarkTryString(gchar* string);
	[LinkName("g_quark_from_static_string")] public static extern GQuark QuarkFromStaticString(gchar* string);
	[LinkName("g_quark_from_string")] public static extern GQuark QuarkFromString(gchar* string);
	[LinkName("g_quark_to_string")] public static extern gchar* QuarkToString(GQuark quark);
	[LinkName("g_intern_string")] public static extern gchar* InternString(gchar* string);
	[LinkName("g_intern_static_string")] public static extern gchar* InternStaticString(gchar* string);
}


[CRepr] struct GError
{
	public GQuark domain;
	public gint code;
	public gchar* message;
}

/** GErrorInitFunc:
 *   @error : extended error
 *  
 *  Specifies the type of function which is called just after an
 *  extended error instance is created and its fields filled. It should
 *  only initialize the fields in the private data, which can be
 *  received with the generated `*_get_private()` function.
 *  
 *  Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it
 *  already takes care of getting the private data from @error .
 *  
 *  Since: 2.68
 */
function void GErrorInitFunc(GError* error);

/** GErrorCopyFunc:
 *   @src _error: source extended error
 *  @test _error: destination extended error
 *  
 *  Specifies the type of function which is called when an extended
 *  error instance is copied. It is passed the pointer to the
 *  destination error and source error, and should copy only the fields
 *  of the private data from @src _error to@test _error.
 *  
 *  Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it
 *  already takes care of getting the private data from @src _error and
 *  @test _error.
 *  
 *  Since: 2.68
 */
function void GErrorCopyFunc(GError* src_error, GError* dest_error);

/** GErrorClearFunc:
 *   @error : extended error to clear
 *  
 *  Specifies the type of function which is called when an extended
 *  error instance is freed. It is passed the error pointer about to be
 *  freed, and should free the error's private data fields.
 *  
 *  Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it
 *  already takes care of getting the private data from @error .
 *  
 *  Since: 2.68
 */
function void GErrorClearFunc(GError* error);

extension GLib
{
	[LinkName("g_error_domain_register_static")] public static extern GQuark ErrorDomainRegisterStatic(c_char* error_type_name, gsize error_type_private_size, GErrorInitFunc error_type_init, GErrorCopyFunc error_type_copy, GErrorClearFunc error_type_clear);
	[LinkName("g_error_domain_register")] public static extern GQuark ErrorDomainRegister(c_char* error_type_name, gsize error_type_private_size, GErrorInitFunc error_type_init, GErrorCopyFunc error_type_copy, GErrorClearFunc error_type_clear);
	[LinkName("g_error_new")] public static extern GError* ErrorNew(GQuark domain, gint code, gchar* format, ...);
	[LinkName("g_error_new_literal")] public static extern GError* ErrorNewLiteral(GQuark domain, gint code, gchar* message);
	[LinkName("g_error_new_valist")] public static extern GError* ErrorNewValist(GQuark domain, gint code, gchar* format, VarArgs args);
	[LinkName("g_error_free")] public static extern void ErrorFree(GError* error);
	[LinkName("g_error_copy")] public static extern GError* ErrorCopy(GError* error);
	[LinkName("g_error_matches")] public static extern gboolean ErrorMatches(GError* error, GQuark domain, gint code);
	[LinkName("g_set_error")] public static extern void SetError(GError** err, GQuark domain, gint code, gchar* format, ...);
	[LinkName("g_set_error_literal")] public static extern void SetErrorLiteral(GError** err, GQuark domain, gint code, gchar* message);
	[LinkName("g_propagate_error")] public static extern void PropagateError(GError** dest, GError* src);
	[LinkName("g_clear_error")] public static extern void ClearError(GError** err);
	[LinkName("g_prefix_error")] public static extern void PrefixError(GError** err, gchar* format, ...);
	[LinkName("g_prefix_error_literal")] public static extern void PrefixErrorLiteral(GError** err, gchar* prefix);
	[LinkName("g_propagate_prefixed_error")] public static extern void PropagatePrefixedError(GError** dest, GError* src, gchar* format, ...);
	[LinkName("g_get_user_name")] public static extern gchar* GetUserName();
	[LinkName("g_get_real_name")] public static extern gchar* GetRealName();
	[LinkName("g_get_home_dir")] public static extern gchar* GetHomeDir();
	[LinkName("g_get_tmp_dir")] public static extern gchar* GetTmpDir();
	[LinkName("g_get_host_name")] public static extern gchar* GetHostName();
	[LinkName("g_get_prgname")] public static extern gchar* GetPrgname();
	[LinkName("g_set_prgname")] public static extern void SetPrgname(gchar* prgname);
	[LinkName("g_get_application_name")] public static extern gchar* GetApplicationName();
	[LinkName("g_set_application_name")] public static extern void SetApplicationName(gchar* application_name);
	[LinkName("g_get_os_info")] public static extern gchar* GetOsInfo(gchar* key_name);
	[LinkName("g_reload_user_special_dirs_cache")] public static extern void ReloadUserSpecialDirsCache();
	[LinkName("g_get_user_data_dir")] public static extern gchar* GetUserDataDir();
	[LinkName("g_get_user_config_dir")] public static extern gchar* GetUserConfigDir();
	[LinkName("g_get_user_cache_dir")] public static extern gchar* GetUserCacheDir();
	[LinkName("g_get_user_state_dir")] public static extern gchar* GetUserStateDir();
	[LinkName("g_get_system_data_dirs")] public static extern gchar** GetSystemDataDirs();
	[LinkName("g_win32_get_system_data_dirs_for_module")] public static extern gchar** Win32GetSystemDataDirsForModule(function void() address_of_function);
	[LinkName("g_get_system_config_dirs")] public static extern gchar** GetSystemConfigDirs();
	[LinkName("g_get_user_runtime_dir")] public static extern gchar* GetUserRuntimeDir();
}

/** GUserDirectory:
 *   @G _USER_DIRECTORY_DESKTOP: the user's Desktop directory
 *   @G _USER_DIRECTORY_DOCUMENTS: the user's Documents directory
 *   @G _USER_DIRECTORY_DOWNLOAD: the user's Downloads directory
 *   @G _USER_DIRECTORY_MUSIC: the user's Music directory
 *   @G _USER_DIRECTORY_PICTURES: the user's Pictures directory
 *   @G _USER_DIRECTORY_PUBLIC_SHARE: the user's shared directory
 *   @G _USER_DIRECTORY_TEMPLATES: the user's Templates directory
 *   @G _USER_DIRECTORY_VIDEOS: the user's Movies directory
 *   @G _USER_N_DIRECTORIES: the number of enum values
 *  
 *  These are logical ids for special directories which are defined
 *  depending on the platform used. You should use g_get_user_special_dir()
 *  to retrieve the full path associated to the logical id.
 *  
 *  The #GUserDirectory enumeration can be extended at later date. Not
 *  every platform has a directory for every logical id in this
 *  enumeration.
 *  
 *  Since: 2.14
 */
[AllowDuplicates] enum GUserDirectory : c_int
{
	Desktop = 0,
	Documents = 1,
	Download = 2,
	Music = 3,
	Pictures = 4,
	PublicShare = 5,
	Templates = 6,
	Videos = 7,
	NDirectories = 8,
}

extension GLib
{
	[LinkName("g_get_user_special_dir")] public static extern gchar* GetUserSpecialDir(GUserDirectory directory);
}


[CRepr] struct GDebugKey
{
	public gchar* key;
	public guint value;
}

extension GLib
{
	[LinkName("g_parse_debug_string")] public static extern guint ParseDebugString(gchar* string, GDebugKey* keys, guint nkeys);
	[LinkName("g_snprintf")] public static extern gint Snprintf(gchar* string, gulong n, gchar* format, ...);
	[LinkName("g_vsnprintf")] public static extern gint Vsnprintf(gchar* string, gulong n, gchar* format, VarArgs args);
	[LinkName("g_nullify_pointer")] public static extern void NullifyPointer(gpointer* nullify_location);
}

[AllowDuplicates] enum GFormatSizeFlags : c_int
{
	Default = 0,
	LongFormat = 1 << 0,
	IecUnits = 1 << 1,
	Bits = 1 << 2,
	OnlyValue = 1 << 3,
	OnlyUnit = 1 << 4,
}

extension GLib
{
	[LinkName("g_format_size_full")] public static extern gchar* FormatSizeFull(guint64 size, GFormatSizeFlags flags);
	[LinkName("g_format_size")] public static extern gchar* FormatSize(guint64 size);
	[LinkName("g_format_size_for_display")] public static extern gchar* FormatSizeForDisplay(goffset size);
}

/** GVoidFunc:
 *  
 *  Declares a type of function which takes no arguments
 *  and has no return value. It is used to specify the type
 *  function passed to g_atexit().
 */
function void GVoidFunc();

extension GLib
{
	[LinkName("g_atexit")] public static extern void Atexit(GVoidFunc func);
}

static
{
	[LinkName("atexit")] public static extern c_int Atexit(function void());
}

extension GLib
{
	[LinkName("g_find_program_in_path")] public static extern gchar* FindProgramInPath(gchar* program);
	[LinkName("g_bit_nth_lsf")] public static extern gint BitNthLsf(gulong mask, gint nth_bit);
	[LinkName("g_bit_nth_msf")] public static extern gint BitNthMsf(gulong mask, gint nth_bit);
	[LinkName("g_bit_storage")] public static extern guint BitStorage(gulong number);
	[LinkName("g_abort")] public static extern void Abort();
	[LinkName("g_thread_error_quark")] public static extern GQuark ThreadErrorQuark();
}

[AllowDuplicates] enum GThreadError : c_int
{
	Again = 0,
}

function gpointer GThreadFunc(gpointer data);








[Union, CRepr] struct GMutex
{
	public gpointer p;
	public guint[2] i;
}

[CRepr] struct GRWLock
{
	public gpointer p;
	public guint[2] i;
}

[CRepr] struct GCond
{
	public gpointer p;
	public guint[2] i;
}

[CRepr] struct GRecMutex
{
	public gpointer p;
	public guint[2] i;
}

[CRepr] struct GPrivate
{
	public gpointer p;
	public GDestroyNotify notify;
	public gpointer[2] future;
}

[AllowDuplicates] enum GOnceStatus : c_int
{
	Notcalled = 0,
	Progress = 1,
	Ready = 2,
}

[CRepr] struct GOnce
{
	public GOnceStatus status;
	public gpointer retval;
}

extension GLib
{
	[LinkName("g_thread_ref")] public static extern GThread* ThreadRef(GThread* thread);
	[LinkName("g_thread_unref")] public static extern void ThreadUnref(GThread* thread);
	[LinkName("g_thread_new")] public static extern GThread* ThreadNew(gchar* name, GThreadFunc func, gpointer data);
	[LinkName("g_thread_try_new")] public static extern GThread* ThreadTryNew(gchar* name, GThreadFunc func, gpointer data, GError** error);
	[LinkName("g_thread_self")] public static extern GThread* ThreadSelf();
	[LinkName("g_thread_exit")] public static extern void ThreadExit(gpointer retval);
	[LinkName("g_thread_join")] public static extern gpointer ThreadJoin(GThread* thread);
	[LinkName("g_thread_yield")] public static extern void ThreadYield();
	[LinkName("g_thread_get_name")] public static extern c_char* ThreadGetName(GThread* thread);
	[LinkName("g_mutex_init")] public static extern void MutexInit(GMutex* mutex);
	[LinkName("g_mutex_clear")] public static extern void MutexClear(GMutex* mutex);
	[LinkName("g_mutex_lock")] public static extern void MutexLock(GMutex* mutex);
	[LinkName("g_mutex_trylock")] public static extern gboolean MutexTrylock(GMutex* mutex);
	[LinkName("g_mutex_unlock")] public static extern void MutexUnlock(GMutex* mutex);
	[LinkName("g_rw_lock_init")] public static extern void RwLockInit(GRWLock* rw_lock);
	[LinkName("g_rw_lock_clear")] public static extern void RwLockClear(GRWLock* rw_lock);
	[LinkName("g_rw_lock_writer_lock")] public static extern void RwLockWriterLock(GRWLock* rw_lock);
	[LinkName("g_rw_lock_writer_trylock")] public static extern gboolean RwLockWriterTrylock(GRWLock* rw_lock);
	[LinkName("g_rw_lock_writer_unlock")] public static extern void RwLockWriterUnlock(GRWLock* rw_lock);
	[LinkName("g_rw_lock_reader_lock")] public static extern void RwLockReaderLock(GRWLock* rw_lock);
	[LinkName("g_rw_lock_reader_trylock")] public static extern gboolean RwLockReaderTrylock(GRWLock* rw_lock);
	[LinkName("g_rw_lock_reader_unlock")] public static extern void RwLockReaderUnlock(GRWLock* rw_lock);
	[LinkName("g_rec_mutex_init")] public static extern void RecMutexInit(GRecMutex* rec_mutex);
	[LinkName("g_rec_mutex_clear")] public static extern void RecMutexClear(GRecMutex* rec_mutex);
	[LinkName("g_rec_mutex_lock")] public static extern void RecMutexLock(GRecMutex* rec_mutex);
	[LinkName("g_rec_mutex_trylock")] public static extern gboolean RecMutexTrylock(GRecMutex* rec_mutex);
	[LinkName("g_rec_mutex_unlock")] public static extern void RecMutexUnlock(GRecMutex* rec_mutex);
	[LinkName("g_cond_init")] public static extern void CondInit(GCond* cond);
	[LinkName("g_cond_clear")] public static extern void CondClear(GCond* cond);
	[LinkName("g_cond_wait")] public static extern void CondWait(GCond* cond, GMutex* mutex);
	[LinkName("g_cond_signal")] public static extern void CondSignal(GCond* cond);
	[LinkName("g_cond_broadcast")] public static extern void CondBroadcast(GCond* cond);
	[LinkName("g_cond_wait_until")] public static extern gboolean CondWaitUntil(GCond* cond, GMutex* mutex, gint64 end_time);
	[LinkName("g_private_get")] public static extern gpointer PrivateGet(GPrivate* key);
	[LinkName("g_private_set")] public static extern void PrivateSet(GPrivate* key, gpointer value);
	[LinkName("g_private_replace")] public static extern void PrivateReplace(GPrivate* key, gpointer value);
	[LinkName("g_once_impl")] public static extern gpointer OnceImpl(GOnce* once, GThreadFunc func, gpointer arg);
	[LinkName("g_once_init_enter")] public static extern gboolean OnceInitEnter(void* location);
	[LinkName("g_once_init_leave")] public static extern void OnceInitLeave(void* location, gsize result);
	[LinkName("g_once_init_enter_pointer")] public static extern gboolean OnceInitEnterPointer(void* location);
	[LinkName("g_once_init_leave_pointer")] public static extern void OnceInitLeavePointer(void* location, gpointer result);
	[LinkName("g_get_num_processors")] public static extern guint GetNumProcessors();
}

/** GMutexLocker:
 *  
 *  Opaque type. See g_mutex_locker_new() for details.
 *  Since: 2.44
 */
typealias GMutexLocker = void;

/** GRecMutexLocker:
 *  
 *  Opaque type. See g_rec_mutex_locker_new() for details.
 *  Since: 2.60
 */
typealias GRecMutexLocker = void;

/** GRWLockWriterLocker:
 *  
 *  Opaque type. See g_rw_lock_writer_locker_new() for details.
 *  Since: 2.62
 */
typealias GRWLockWriterLocker = void;

/** GRWLockReaderLocker:
 *  
 *  Opaque type. See g_rw_lock_reader_locker_new() for details.
 *  Since: 2.62
 */
typealias GRWLockReaderLocker = void;

struct GAsyncQueue;

extension GLib
{
	[LinkName("g_async_queue_new")] public static extern GAsyncQueue* AsyncQueueNew();
	[LinkName("g_async_queue_new_full")] public static extern GAsyncQueue* AsyncQueueNewFull(GDestroyNotify item_free_func);
	[LinkName("g_async_queue_lock")] public static extern void AsyncQueueLock(GAsyncQueue* queue);
	[LinkName("g_async_queue_unlock")] public static extern void AsyncQueueUnlock(GAsyncQueue* queue);
	[LinkName("g_async_queue_ref")] public static extern GAsyncQueue* AsyncQueueRef(GAsyncQueue* queue);
	[LinkName("g_async_queue_unref")] public static extern void AsyncQueueUnref(GAsyncQueue* queue);
	[LinkName("g_async_queue_ref_unlocked")] public static extern void AsyncQueueRefUnlocked(GAsyncQueue* queue);
	[LinkName("g_async_queue_unref_and_unlock")] public static extern void AsyncQueueUnrefAndUnlock(GAsyncQueue* queue);
	[LinkName("g_async_queue_push")] public static extern void AsyncQueuePush(GAsyncQueue* queue, gpointer data);
	[LinkName("g_async_queue_push_unlocked")] public static extern void AsyncQueuePushUnlocked(GAsyncQueue* queue, gpointer data);
	[LinkName("g_async_queue_push_sorted")] public static extern void AsyncQueuePushSorted(GAsyncQueue* queue, gpointer data, GCompareDataFunc func, gpointer user_data);
	[LinkName("g_async_queue_push_sorted_unlocked")] public static extern void AsyncQueuePushSortedUnlocked(GAsyncQueue* queue, gpointer data, GCompareDataFunc func, gpointer user_data);
	[LinkName("g_async_queue_pop")] public static extern gpointer AsyncQueuePop(GAsyncQueue* queue);
	[LinkName("g_async_queue_pop_unlocked")] public static extern gpointer AsyncQueuePopUnlocked(GAsyncQueue* queue);
	[LinkName("g_async_queue_try_pop")] public static extern gpointer AsyncQueueTryPop(GAsyncQueue* queue);
	[LinkName("g_async_queue_try_pop_unlocked")] public static extern gpointer AsyncQueueTryPopUnlocked(GAsyncQueue* queue);
	[LinkName("g_async_queue_timeout_pop")] public static extern gpointer AsyncQueueTimeoutPop(GAsyncQueue* queue, guint64 timeout);
	[LinkName("g_async_queue_timeout_pop_unlocked")] public static extern gpointer AsyncQueueTimeoutPopUnlocked(GAsyncQueue* queue, guint64 timeout);
	[LinkName("g_async_queue_length")] public static extern gint AsyncQueueLength(GAsyncQueue* queue);
	[LinkName("g_async_queue_length_unlocked")] public static extern gint AsyncQueueLengthUnlocked(GAsyncQueue* queue);
	[LinkName("g_async_queue_sort")] public static extern void AsyncQueueSort(GAsyncQueue* queue, GCompareDataFunc func, gpointer user_data);
	[LinkName("g_async_queue_sort_unlocked")] public static extern void AsyncQueueSortUnlocked(GAsyncQueue* queue, GCompareDataFunc func, gpointer user_data);
	[LinkName("g_async_queue_remove")] public static extern gboolean AsyncQueueRemove(GAsyncQueue* queue, gpointer item);
	[LinkName("g_async_queue_remove_unlocked")] public static extern gboolean AsyncQueueRemoveUnlocked(GAsyncQueue* queue, gpointer item);
	[LinkName("g_async_queue_push_front")] public static extern void AsyncQueuePushFront(GAsyncQueue* queue, gpointer item);
	[LinkName("g_async_queue_push_front_unlocked")] public static extern void AsyncQueuePushFrontUnlocked(GAsyncQueue* queue, gpointer item);
	[LinkName("g_async_queue_timed_pop")] public static extern gpointer AsyncQueueTimedPop(GAsyncQueue* queue, GTimeVal* end_time);
	[LinkName("g_async_queue_timed_pop_unlocked")] public static extern gpointer AsyncQueueTimedPopUnlocked(GAsyncQueue* queue, GTimeVal* end_time);
	[LinkName("g_on_error_query")] public static extern void OnErrorQuery(gchar* prg_name);
	[LinkName("g_on_error_stack_trace")] public static extern void OnErrorStackTrace(gchar* prg_name);
	[LinkName("g_base64_encode_step")] public static extern gsize Base64EncodeStep(guchar* @in, gsize len, gboolean break_lines, gchar* @out, gint* state, gint* save);
	[LinkName("g_base64_encode_close")] public static extern gsize Base64EncodeClose(gboolean break_lines, gchar* @out, gint* state, gint* save);
	[LinkName("g_base64_encode")] public static extern gchar* Base64Encode(guchar* data, gsize len);
	[LinkName("g_base64_decode_step")] public static extern gsize Base64DecodeStep(gchar* @in, gsize len, guchar* @out, gint* state, guint* save);
	[LinkName("g_base64_decode")] public static extern guchar* Base64Decode(gchar* text, gsize* out_len);
	[LinkName("g_base64_decode_inplace")] public static extern guchar* Base64DecodeInplace(gchar* text, gsize* out_len);
	[LinkName("g_bit_lock")] public static extern void BitLock(gint* address, gint lock_bit);
	[LinkName("g_bit_trylock")] public static extern gboolean BitTrylock(gint* address, gint lock_bit);
	[LinkName("g_bit_unlock")] public static extern void BitUnlock(gint* address, gint lock_bit);
	[LinkName("g_pointer_bit_lock")] public static extern void PointerBitLock(void* address, gint lock_bit);
	[LinkName("g_pointer_bit_lock_and_get")] public static extern void PointerBitLockAndGet(gpointer address, guint lock_bit, guintptr* out_ptr);
	[LinkName("g_pointer_bit_trylock")] public static extern gboolean PointerBitTrylock(void* address, gint lock_bit);
	[LinkName("g_pointer_bit_unlock")] public static extern void PointerBitUnlock(void* address, gint lock_bit);
	[LinkName("g_pointer_bit_lock_mask_ptr")] public static extern gpointer PointerBitLockMaskPtr(gpointer ptr, guint lock_bit, gboolean set, guintptr preserve_mask, gpointer preserve_ptr);
	[LinkName("g_pointer_bit_unlock_and_set")] public static extern void PointerBitUnlockAndSet(void* address, guint lock_bit, gpointer ptr, guintptr preserve_mask);
}

struct GTimeZone;

/** GTimeType:
 *   @G _TIME_TYPE_STANDARD: the time is in local standard time
 *   @G _TIME_TYPE_DAYLIGHT: the time is in local daylight time
 *   @G _TIME_TYPE_UNIVERSAL: the time is in UTC
 *  
 *  Disambiguates a given time in two ways.
 *  
 *  First, specifies if the given time is in universal or local time.
 *  
 *  Second, if the time is in local time, specifies if it is local
 *  standard time or local daylight time.  This is important for the case
 *  where the same local time occurs twice (during daylight savings time
 *  transitions, for example).
 */
[AllowDuplicates] enum GTimeType : c_int
{
	Standard = 0,
	Daylight = 1,
	Universal = 2,
}

extension GLib
{
	[LinkName("g_time_zone_new")] public static extern GTimeZone* TimeZoneNew(gchar* identifier);
	[LinkName("g_time_zone_new_identifier")] public static extern GTimeZone* TimeZoneNewIdentifier(gchar* identifier);
	[LinkName("g_time_zone_new_utc")] public static extern GTimeZone* TimeZoneNewUtc();
	[LinkName("g_time_zone_new_local")] public static extern GTimeZone* TimeZoneNewLocal();
	[LinkName("g_time_zone_new_offset")] public static extern GTimeZone* TimeZoneNewOffset(gint32 seconds);
	[LinkName("g_time_zone_ref")] public static extern GTimeZone* TimeZoneRef(GTimeZone* tz);
	[LinkName("g_time_zone_unref")] public static extern void TimeZoneUnref(GTimeZone* tz);
	[LinkName("g_time_zone_find_interval")] public static extern gint TimeZoneFindInterval(GTimeZone* tz, GTimeType type, gint64 time);
	[LinkName("g_time_zone_adjust_time")] public static extern gint TimeZoneAdjustTime(GTimeZone* tz, GTimeType type, gint64* time);
	[LinkName("g_time_zone_get_abbreviation")] public static extern gchar* TimeZoneGetAbbreviation(GTimeZone* tz, gint interval);
	[LinkName("g_time_zone_get_offset")] public static extern gint32 TimeZoneGetOffset(GTimeZone* tz, gint interval);
	[LinkName("g_time_zone_is_dst")] public static extern gboolean TimeZoneIsDst(GTimeZone* tz, gint interval);
	[LinkName("g_time_zone_get_identifier")] public static extern gchar* TimeZoneGetIdentifier(GTimeZone* tz);
}

/** GTimeSpan:
 *  
 *  A value representing an interval of time, in microseconds.
 *  
 *  Since: 2.26
 */
typealias GTimeSpan = gint64;

struct GDateTime;

extension GLib
{
	[LinkName("g_date_time_unref")] public static extern void DateTimeUnref(GDateTime* datetime);
	[LinkName("g_date_time_ref")] public static extern GDateTime* DateTimeRef(GDateTime* datetime);
	[LinkName("g_date_time_new_now")] public static extern GDateTime* DateTimeNewNow(GTimeZone* tz);
	[LinkName("g_date_time_new_now_local")] public static extern GDateTime* DateTimeNewNowLocal();
	[LinkName("g_date_time_new_now_utc")] public static extern GDateTime* DateTimeNewNowUtc();
	[LinkName("g_date_time_new_from_unix_local")] public static extern GDateTime* DateTimeNewFromUnixLocal(gint64 t);
	[LinkName("g_date_time_new_from_unix_utc")] public static extern GDateTime* DateTimeNewFromUnixUtc(gint64 t);
	[LinkName("g_date_time_new_from_unix_local_usec")] public static extern GDateTime* DateTimeNewFromUnixLocalUsec(gint64 usecs);
	[LinkName("g_date_time_new_from_unix_utc_usec")] public static extern GDateTime* DateTimeNewFromUnixUtcUsec(gint64 usecs);
	[LinkName("g_date_time_new_from_timeval_local")] public static extern GDateTime* DateTimeNewFromTimevalLocal(GTimeVal* tv);
	[LinkName("g_date_time_new_from_timeval_utc")] public static extern GDateTime* DateTimeNewFromTimevalUtc(GTimeVal* tv);
	[LinkName("g_date_time_new_from_iso8601")] public static extern GDateTime* DateTimeNewFromIso8601(gchar* text, GTimeZone* default_tz);
	[LinkName("g_date_time_new")] public static extern GDateTime* DateTimeNew(GTimeZone* tz, gint year, gint month, gint day, gint hour, gint minute, gdouble seconds);
	[LinkName("g_date_time_new_local")] public static extern GDateTime* DateTimeNewLocal(gint year, gint month, gint day, gint hour, gint minute, gdouble seconds);
	[LinkName("g_date_time_new_utc")] public static extern GDateTime* DateTimeNewUtc(gint year, gint month, gint day, gint hour, gint minute, gdouble seconds);
	[LinkName("g_date_time_add")] public static extern GDateTime* DateTimeAdd(GDateTime* datetime, GTimeSpan timespan);
	[LinkName("g_date_time_add_years")] public static extern GDateTime* DateTimeAddYears(GDateTime* datetime, gint years);
	[LinkName("g_date_time_add_months")] public static extern GDateTime* DateTimeAddMonths(GDateTime* datetime, gint months);
	[LinkName("g_date_time_add_weeks")] public static extern GDateTime* DateTimeAddWeeks(GDateTime* datetime, gint weeks);
	[LinkName("g_date_time_add_days")] public static extern GDateTime* DateTimeAddDays(GDateTime* datetime, gint days);
	[LinkName("g_date_time_add_hours")] public static extern GDateTime* DateTimeAddHours(GDateTime* datetime, gint hours);
	[LinkName("g_date_time_add_minutes")] public static extern GDateTime* DateTimeAddMinutes(GDateTime* datetime, gint minutes);
	[LinkName("g_date_time_add_seconds")] public static extern GDateTime* DateTimeAddSeconds(GDateTime* datetime, gdouble seconds);
	[LinkName("g_date_time_add_full")] public static extern GDateTime* DateTimeAddFull(GDateTime* datetime, gint years, gint months, gint days, gint hours, gint minutes, gdouble seconds);
	[LinkName("g_date_time_compare")] public static extern gint DateTimeCompare(gconstpointer dt1, gconstpointer dt2);
	[LinkName("g_date_time_difference")] public static extern GTimeSpan DateTimeDifference(GDateTime* end, GDateTime* begin);
	[LinkName("g_date_time_hash")] public static extern guint DateTimeHash(gconstpointer datetime);
	[LinkName("g_date_time_equal")] public static extern gboolean DateTimeEqual(gconstpointer dt1, gconstpointer dt2);
	[LinkName("g_date_time_get_ymd")] public static extern void DateTimeGetYmd(GDateTime* datetime, gint* year, gint* month, gint* day);
	[LinkName("g_date_time_get_year")] public static extern gint DateTimeGetYear(GDateTime* datetime);
	[LinkName("g_date_time_get_month")] public static extern gint DateTimeGetMonth(GDateTime* datetime);
	[LinkName("g_date_time_get_day_of_month")] public static extern gint DateTimeGetDayOfMonth(GDateTime* datetime);
	[LinkName("g_date_time_get_week_numbering_year")] public static extern gint DateTimeGetWeekNumberingYear(GDateTime* datetime);
	[LinkName("g_date_time_get_week_of_year")] public static extern gint DateTimeGetWeekOfYear(GDateTime* datetime);
	[LinkName("g_date_time_get_day_of_week")] public static extern gint DateTimeGetDayOfWeek(GDateTime* datetime);
	[LinkName("g_date_time_get_day_of_year")] public static extern gint DateTimeGetDayOfYear(GDateTime* datetime);
	[LinkName("g_date_time_get_hour")] public static extern gint DateTimeGetHour(GDateTime* datetime);
	[LinkName("g_date_time_get_minute")] public static extern gint DateTimeGetMinute(GDateTime* datetime);
	[LinkName("g_date_time_get_second")] public static extern gint DateTimeGetSecond(GDateTime* datetime);
	[LinkName("g_date_time_get_microsecond")] public static extern gint DateTimeGetMicrosecond(GDateTime* datetime);
	[LinkName("g_date_time_get_seconds")] public static extern gdouble DateTimeGetSeconds(GDateTime* datetime);
	[LinkName("g_date_time_to_unix")] public static extern gint64 DateTimeToUnix(GDateTime* datetime);
	[LinkName("g_date_time_to_unix_usec")] public static extern gint64 DateTimeToUnixUsec(GDateTime* datetime);
	[LinkName("g_date_time_to_timeval")] public static extern gboolean DateTimeToTimeval(GDateTime* datetime, GTimeVal* tv);
	[LinkName("g_date_time_get_utc_offset")] public static extern GTimeSpan DateTimeGetUtcOffset(GDateTime* datetime);
	[LinkName("g_date_time_get_timezone")] public static extern GTimeZone* DateTimeGetTimezone(GDateTime* datetime);
	[LinkName("g_date_time_get_timezone_abbreviation")] public static extern gchar* DateTimeGetTimezoneAbbreviation(GDateTime* datetime);
	[LinkName("g_date_time_is_daylight_savings")] public static extern gboolean DateTimeIsDaylightSavings(GDateTime* datetime);
	[LinkName("g_date_time_to_timezone")] public static extern GDateTime* DateTimeToTimezone(GDateTime* datetime, GTimeZone* tz);
	[LinkName("g_date_time_to_local")] public static extern GDateTime* DateTimeToLocal(GDateTime* datetime);
	[LinkName("g_date_time_to_utc")] public static extern GDateTime* DateTimeToUtc(GDateTime* datetime);
	[LinkName("g_date_time_format")] public static extern gchar* DateTimeFormat(GDateTime* datetime, gchar* format);
	[LinkName("g_date_time_format_iso8601")] public static extern gchar* DateTimeFormatIso8601(GDateTime* datetime);
}

/** GBookmarkFileError:
 *   @G _BOOKMARK_FILE_ERROR_INVALID_URI: URI was ill-formed
 *   @G _BOOKMARK_FILE_ERROR_INVALID_VALUE: a requested field was not found
 *   @G _BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: a requested application did
 *  not register a bookmark
 *   @G _BOOKMARK_FILE_ERROR_URI_NOT_FOUND: a requested URI was not found
 *   @G _BOOKMARK_FILE_ERROR_READ: document was ill formed
 *   @G _BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: the text being parsed was
 *  in an unknown encoding
 *   @G _BOOKMARK_FILE_ERROR_WRITE: an error occurred while writing
 *   @G _BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: requested file was not found
 *  
 *  Error codes returned by bookmark file parsing.
 */
[AllowDuplicates] enum GBookmarkFileError : c_int
{
	InvalidUri = 0,
	InvalidValue = 1,
	AppNotRegistered = 2,
	UriNotFound = 3,
	Read = 4,
	UnknownEncoding = 5,
	Write = 6,
	FileNotFound = 7,
}

extension GLib
{
	[LinkName("g_bookmark_file_error_quark")] public static extern GQuark BookmarkFileErrorQuark();
}

struct GBookmarkFile;

extension GLib
{
	[LinkName("g_bookmark_file_new")] public static extern GBookmarkFile* BookmarkFileNew();
	[LinkName("g_bookmark_file_free")] public static extern void BookmarkFileFree(GBookmarkFile* bookmark);
	[LinkName("g_bookmark_file_copy")] public static extern GBookmarkFile* BookmarkFileCopy(GBookmarkFile* bookmark);
	[LinkName("g_bookmark_file_load_from_file")] public static extern gboolean BookmarkFileLoadFromFile(GBookmarkFile* bookmark, gchar* filename, GError** error);
	[LinkName("g_bookmark_file_load_from_data")] public static extern gboolean BookmarkFileLoadFromData(GBookmarkFile* bookmark, gchar* data, gsize length, GError** error);
	[LinkName("g_bookmark_file_load_from_data_dirs")] public static extern gboolean BookmarkFileLoadFromDataDirs(GBookmarkFile* bookmark, gchar* file, gchar** full_path, GError** error);
	[LinkName("g_bookmark_file_to_data")] public static extern gchar* BookmarkFileToData(GBookmarkFile* bookmark, gsize* length, GError** error);
	[LinkName("g_bookmark_file_to_file")] public static extern gboolean BookmarkFileToFile(GBookmarkFile* bookmark, gchar* filename, GError** error);
	[LinkName("g_bookmark_file_set_title")] public static extern void BookmarkFileSetTitle(GBookmarkFile* bookmark, gchar* uri, gchar* title);
	[LinkName("g_bookmark_file_get_title")] public static extern gchar* BookmarkFileGetTitle(GBookmarkFile* bookmark, gchar* uri, GError** error);
	[LinkName("g_bookmark_file_set_description")] public static extern void BookmarkFileSetDescription(GBookmarkFile* bookmark, gchar* uri, gchar* description);
	[LinkName("g_bookmark_file_get_description")] public static extern gchar* BookmarkFileGetDescription(GBookmarkFile* bookmark, gchar* uri, GError** error);
	[LinkName("g_bookmark_file_set_mime_type")] public static extern void BookmarkFileSetMimeType(GBookmarkFile* bookmark, gchar* uri, gchar* mime_type);
	[LinkName("g_bookmark_file_get_mime_type")] public static extern gchar* BookmarkFileGetMimeType(GBookmarkFile* bookmark, gchar* uri, GError** error);
	[LinkName("g_bookmark_file_set_groups")] public static extern void BookmarkFileSetGroups(GBookmarkFile* bookmark, gchar* uri, gchar** groups, gsize length);
	[LinkName("g_bookmark_file_add_group")] public static extern void BookmarkFileAddGroup(GBookmarkFile* bookmark, gchar* uri, gchar* group);
	[LinkName("g_bookmark_file_has_group")] public static extern gboolean BookmarkFileHasGroup(GBookmarkFile* bookmark, gchar* uri, gchar* group, GError** error);
	[LinkName("g_bookmark_file_get_groups")] public static extern gchar** BookmarkFileGetGroups(GBookmarkFile* bookmark, gchar* uri, gsize* length, GError** error);
	[LinkName("g_bookmark_file_add_application")] public static extern void BookmarkFileAddApplication(GBookmarkFile* bookmark, gchar* uri, gchar* name, gchar* exec);
	[LinkName("g_bookmark_file_has_application")] public static extern gboolean BookmarkFileHasApplication(GBookmarkFile* bookmark, gchar* uri, gchar* name, GError** error);
	[LinkName("g_bookmark_file_get_applications")] public static extern gchar** BookmarkFileGetApplications(GBookmarkFile* bookmark, gchar* uri, gsize* length, GError** error);
	[LinkName("g_bookmark_file_set_app_info")] public static extern gboolean BookmarkFileSetAppInfo(GBookmarkFile* bookmark, gchar* uri, gchar* name, gchar* exec, gint count, time_t stamp, GError** error);
	[LinkName("g_bookmark_file_set_application_info")] public static extern gboolean BookmarkFileSetApplicationInfo(GBookmarkFile* bookmark, c_char* uri, c_char* name, c_char* exec, c_int count, GDateTime* stamp, GError** error);
	[LinkName("g_bookmark_file_get_app_info")] public static extern gboolean BookmarkFileGetAppInfo(GBookmarkFile* bookmark, gchar* uri, gchar* name, gchar** exec, guint* count, time_t* stamp, GError** error);
	[LinkName("g_bookmark_file_get_application_info")] public static extern gboolean BookmarkFileGetApplicationInfo(GBookmarkFile* bookmark, c_char* uri, c_char* name, c_char** exec, c_uint* count, GDateTime** stamp, GError** error);
	[LinkName("g_bookmark_file_set_is_private")] public static extern void BookmarkFileSetIsPrivate(GBookmarkFile* bookmark, gchar* uri, gboolean is_private);
	[LinkName("g_bookmark_file_get_is_private")] public static extern gboolean BookmarkFileGetIsPrivate(GBookmarkFile* bookmark, gchar* uri, GError** error);
	[LinkName("g_bookmark_file_set_icon")] public static extern void BookmarkFileSetIcon(GBookmarkFile* bookmark, gchar* uri, gchar* href, gchar* mime_type);
	[LinkName("g_bookmark_file_get_icon")] public static extern gboolean BookmarkFileGetIcon(GBookmarkFile* bookmark, gchar* uri, gchar** href, gchar** mime_type, GError** error);
	[LinkName("g_bookmark_file_set_added")] public static extern void BookmarkFileSetAdded(GBookmarkFile* bookmark, gchar* uri, time_t added);
	[LinkName("g_bookmark_file_set_added_date_time")] public static extern void BookmarkFileSetAddedDateTime(GBookmarkFile* bookmark, c_char* uri, GDateTime* added);
	[LinkName("g_bookmark_file_get_added")] public static extern time_t BookmarkFileGetAdded(GBookmarkFile* bookmark, gchar* uri, GError** error);
	[LinkName("g_bookmark_file_get_added_date_time")] public static extern GDateTime* BookmarkFileGetAddedDateTime(GBookmarkFile* bookmark, c_char* uri, GError** error);
	[LinkName("g_bookmark_file_set_modified")] public static extern void BookmarkFileSetModified(GBookmarkFile* bookmark, gchar* uri, time_t modified);
	[LinkName("g_bookmark_file_set_modified_date_time")] public static extern void BookmarkFileSetModifiedDateTime(GBookmarkFile* bookmark, c_char* uri, GDateTime* modified);
	[LinkName("g_bookmark_file_get_modified")] public static extern time_t BookmarkFileGetModified(GBookmarkFile* bookmark, gchar* uri, GError** error);
	[LinkName("g_bookmark_file_get_modified_date_time")] public static extern GDateTime* BookmarkFileGetModifiedDateTime(GBookmarkFile* bookmark, c_char* uri, GError** error);
	[LinkName("g_bookmark_file_set_visited")] public static extern void BookmarkFileSetVisited(GBookmarkFile* bookmark, gchar* uri, time_t visited);
	[LinkName("g_bookmark_file_set_visited_date_time")] public static extern void BookmarkFileSetVisitedDateTime(GBookmarkFile* bookmark, c_char* uri, GDateTime* visited);
	[LinkName("g_bookmark_file_get_visited")] public static extern time_t BookmarkFileGetVisited(GBookmarkFile* bookmark, gchar* uri, GError** error);
	[LinkName("g_bookmark_file_get_visited_date_time")] public static extern GDateTime* BookmarkFileGetVisitedDateTime(GBookmarkFile* bookmark, c_char* uri, GError** error);
	[LinkName("g_bookmark_file_has_item")] public static extern gboolean BookmarkFileHasItem(GBookmarkFile* bookmark, gchar* uri);
	[LinkName("g_bookmark_file_get_size")] public static extern gint BookmarkFileGetSize(GBookmarkFile* bookmark);
	[LinkName("g_bookmark_file_get_uris")] public static extern gchar** BookmarkFileGetUris(GBookmarkFile* bookmark, gsize* length);
	[LinkName("g_bookmark_file_remove_group")] public static extern gboolean BookmarkFileRemoveGroup(GBookmarkFile* bookmark, gchar* uri, gchar* group, GError** error);
	[LinkName("g_bookmark_file_remove_application")] public static extern gboolean BookmarkFileRemoveApplication(GBookmarkFile* bookmark, gchar* uri, gchar* name, GError** error);
	[LinkName("g_bookmark_file_remove_item")] public static extern gboolean BookmarkFileRemoveItem(GBookmarkFile* bookmark, gchar* uri, GError** error);
	[LinkName("g_bookmark_file_move_item")] public static extern gboolean BookmarkFileMoveItem(GBookmarkFile* bookmark, gchar* old_uri, gchar* new_uri, GError** error);
	[LinkName("g_bytes_new")] public static extern GBytes* BytesNew(gconstpointer data, gsize size);
	[LinkName("g_bytes_new_take")] public static extern GBytes* BytesNewTake(gpointer data, gsize size);
	[LinkName("g_bytes_new_static")] public static extern GBytes* BytesNewStatic(gconstpointer data, gsize size);
	[LinkName("g_bytes_new_with_free_func")] public static extern GBytes* BytesNewWithFreeFunc(gconstpointer data, gsize size, GDestroyNotify free_func, gpointer user_data);
	[LinkName("g_bytes_new_from_bytes")] public static extern GBytes* BytesNewFromBytes(GBytes* bytes, gsize offset, gsize length);
	[LinkName("g_bytes_get_data")] public static extern gconstpointer BytesGetData(GBytes* bytes, gsize* size);
	[LinkName("g_bytes_get_size")] public static extern gsize BytesGetSize(GBytes* bytes);
	[LinkName("g_bytes_ref")] public static extern GBytes* BytesRef(GBytes* bytes);
	[LinkName("g_bytes_unref")] public static extern void BytesUnref(GBytes* bytes);
	[LinkName("g_bytes_unref_to_data")] public static extern gpointer BytesUnrefToData(GBytes* bytes, gsize* size);
	[LinkName("g_bytes_unref_to_array")] public static extern GByteArray* BytesUnrefToArray(GBytes* bytes);
	[LinkName("g_bytes_hash")] public static extern guint BytesHash(gconstpointer bytes);
	[LinkName("g_bytes_equal")] public static extern gboolean BytesEqual(gconstpointer bytes1, gconstpointer bytes2);
	[LinkName("g_bytes_compare")] public static extern gint BytesCompare(gconstpointer bytes1, gconstpointer bytes2);
	[LinkName("g_bytes_get_region")] public static extern gconstpointer BytesGetRegion(GBytes* bytes, gsize element_size, gsize offset, gsize n_elements);
	[LinkName("g_get_charset")] public static extern gboolean GetCharset(c_char** charset);
	[LinkName("g_get_codeset")] public static extern gchar* GetCodeset();
	[LinkName("g_get_console_charset")] public static extern gboolean GetConsoleCharset(c_char** charset);
	[LinkName("g_get_language_names")] public static extern gchar** GetLanguageNames();
	[LinkName("g_get_language_names_with_category")] public static extern gchar** GetLanguageNamesWithCategory(gchar* category_name);
	[LinkName("g_get_locale_variants")] public static extern gchar** GetLocaleVariants(gchar* locale);
}

/** GChecksumType:
 *   @G _CHECKSUM_MD5: Use the MD5 hashing algorithm
 *   @G _CHECKSUM_SHA1: Use the SHA-1 hashing algorithm
 *   @G _CHECKSUM_SHA256: Use the SHA-256 hashing algorithm
 *   @G _CHECKSUM_SHA384: Use the SHA-384 hashing algorithm (Since: 2.51)
 *   @G _CHECKSUM_SHA512: Use the SHA-512 hashing algorithm (Since: 2.36)
 *  
 *  The hashing algorithm to be used by #GChecksum when performing the
 *  digest of some data.
 *  
 *  Note that the #GChecksumType enumeration may be extended at a later
 *  date to include new hashing algorithm types.
 *  
 *  Since: 2.16
 */
[AllowDuplicates] enum GChecksumType : c_int
{
	Md5 = 0,
	Sha1 = 1,
	Sha256 = 2,
	Sha512 = 3,
	Sha384 = 4,
}

struct GChecksum;

extension GLib
{
	[LinkName("g_checksum_type_get_length")] public static extern gssize ChecksumTypeGetLength(GChecksumType checksum_type);
	[LinkName("g_checksum_new")] public static extern GChecksum* ChecksumNew(GChecksumType checksum_type);
	[LinkName("g_checksum_reset")] public static extern void ChecksumReset(GChecksum* checksum);
	[LinkName("g_checksum_copy")] public static extern GChecksum* ChecksumCopy(GChecksum* checksum);
	[LinkName("g_checksum_free")] public static extern void ChecksumFree(GChecksum* checksum);
	[LinkName("g_checksum_update")] public static extern void ChecksumUpdate(GChecksum* checksum, guchar* data, gssize length);
	[LinkName("g_checksum_get_string")] public static extern gchar* ChecksumGetString(GChecksum* checksum);
	[LinkName("g_checksum_get_digest")] public static extern void ChecksumGetDigest(GChecksum* checksum, guint8* buffer, gsize* digest_len);
	[LinkName("g_compute_checksum_for_data")] public static extern gchar* ComputeChecksumForData(GChecksumType checksum_type, guchar* data, gsize length);
	[LinkName("g_compute_checksum_for_string")] public static extern gchar* ComputeChecksumForString(GChecksumType checksum_type, gchar* str, gssize length);
	[LinkName("g_compute_checksum_for_bytes")] public static extern gchar* ComputeChecksumForBytes(GChecksumType checksum_type, GBytes* data);
}

/** GConvertError:
 *   @G _CONVERT_ERROR_NO_CONVERSION: Conversion between the requested character
 *  sets is not supported.
 *   @G _CONVERT_ERROR_ILLEGAL_SEQUENCE: Invalid byte sequence in conversion input;
 *  or the character sequence could not be represented in the target
 *  character set.
 *   @G _CONVERT_ERROR_FAILED: Conversion failed for some reason.
 *   @G _CONVERT_ERROR_PARTIAL_INPUT: Partial character sequence at end of input.
 *   @G _CONVERT_ERROR_BAD_URI: URI is invalid.
 *   @G _CONVERT_ERROR_NOT_ABSOLUTE_PATH: Pathname is not an absolute path.
 *   @G _CONVERT_ERROR_NO_MEMORY: No memory available. Since: 2.40
 *   @G _CONVERT_ERROR_EMBEDDED_NUL: An embedded NUL character is present in
 *  conversion output where a NUL-terminated string is expected.
 *  Since: 2.56
 *  
 *  Error codes returned by character set conversion routines.
 */
[AllowDuplicates] enum GConvertError : c_int
{
	NoConversion = 0,
	IllegalSequence = 1,
	Failed = 2,
	PartialInput = 3,
	BadUri = 4,
	NotAbsolutePath = 5,
	NoMemory = 6,
	EmbeddedNul = 7,
}

extension GLib
{
	[LinkName("g_convert_error_quark")] public static extern GQuark ConvertErrorQuark();
}

/** GIConv: (skip)
 *  
 *  The GIConv struct wraps an iconv() conversion descriptor. It contains
 *  private data and should only be accessed using the following functions.
 */
class GIConv { private this() {} }

extension GLib
{
	[LinkName("g_iconv_open")] public static extern GIConv IconvOpen(gchar* to_codeset, gchar* from_codeset);
	[LinkName("g_iconv")] public static extern gsize Iconv(GIConv converter, gchar** inbuf, gsize* inbytes_left, gchar** outbuf, gsize* outbytes_left);
	[LinkName("g_iconv_close")] public static extern gint IconvClose(GIConv converter);
	[LinkName("g_convert")] public static extern gchar* Convert(gchar* str, gssize len, gchar* to_codeset, gchar* from_codeset, gsize* bytes_read, gsize* bytes_written, GError** error);
	[LinkName("g_convert_with_iconv")] public static extern gchar* ConvertWithIconv(gchar* str, gssize len, GIConv converter, gsize* bytes_read, gsize* bytes_written, GError** error);
	[LinkName("g_convert_with_fallback")] public static extern gchar* ConvertWithFallback(gchar* str, gssize len, gchar* to_codeset, gchar* from_codeset, gchar* fallback, gsize* bytes_read, gsize* bytes_written, GError** error);
	[LinkName("g_locale_to_utf8")] public static extern gchar* LocaleToUtf8(gchar* opsysstring, gssize len, gsize* bytes_read, gsize* bytes_written, GError** error);
	[LinkName("g_locale_from_utf8")] public static extern gchar* LocaleFromUtf8(gchar* utf8string, gssize len, gsize* bytes_read, gsize* bytes_written, GError** error);
	[LinkName("g_filename_to_utf8")] public static extern gchar* FilenameToUtf8(gchar* opsysstring, gssize len, gsize* bytes_read, gsize* bytes_written, GError** error);
	[LinkName("g_filename_from_utf8")] public static extern gchar* FilenameFromUtf8(gchar* utf8string, gssize len, gsize* bytes_read, gsize* bytes_written, GError** error);
	[LinkName("g_filename_from_uri")] public static extern gchar* FilenameFromUri(gchar* uri, gchar** hostname, GError** error);
	[LinkName("g_filename_to_uri")] public static extern gchar* FilenameToUri(gchar* filename, gchar* hostname, GError** error);
	[LinkName("g_filename_display_name")] public static extern gchar* FilenameDisplayName(gchar* filename);
	[LinkName("g_get_filename_charsets")] public static extern gboolean GetFilenameCharsets(gchar*** filename_charsets);
	[LinkName("g_filename_display_basename")] public static extern gchar* FilenameDisplayBasename(gchar* filename);
	[LinkName("g_uri_list_extract_uris")] public static extern gchar** UriListExtractUris(gchar* uri_list);
}

struct GData;

function void GDataForeachFunc(GQuark key_id, gpointer data, gpointer user_data);

extension GLib
{
	[LinkName("g_datalist_init")] public static extern void DatalistInit(GData** datalist);
	[LinkName("g_datalist_clear")] public static extern void DatalistClear(GData** datalist);
	[LinkName("g_datalist_id_get_data")] public static extern gpointer DatalistIdGetData(GData** datalist, GQuark key_id);
	[LinkName("g_datalist_id_set_data_full")] public static extern void DatalistIdSetDataFull(GData** datalist, GQuark key_id, gpointer data, GDestroyNotify destroy_func);
	[LinkName("g_datalist_id_remove_multiple")] public static extern void DatalistIdRemoveMultiple(GData** datalist, GQuark* keys, gsize n_keys);
}

function gpointer GDuplicateFunc(gpointer data, gpointer user_data);

extension GLib
{
	[LinkName("g_datalist_id_dup_data")] public static extern gpointer DatalistIdDupData(GData** datalist, GQuark key_id, GDuplicateFunc dup_func, gpointer user_data);
	[LinkName("g_datalist_id_replace_data")] public static extern gboolean DatalistIdReplaceData(GData** datalist, GQuark key_id, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify* old_destroy);
	[LinkName("g_datalist_id_remove_no_notify")] public static extern gpointer DatalistIdRemoveNoNotify(GData** datalist, GQuark key_id);
	[LinkName("g_datalist_foreach")] public static extern void DatalistForeach(GData** datalist, GDataForeachFunc func, gpointer user_data);
	[LinkName("g_datalist_set_flags")] public static extern void DatalistSetFlags(GData** datalist, guint flags);
	[LinkName("g_datalist_unset_flags")] public static extern void DatalistUnsetFlags(GData** datalist, guint flags);
	[LinkName("g_datalist_get_flags")] public static extern guint DatalistGetFlags(GData** datalist);
	[LinkName("g_dataset_destroy")] public static extern void DatasetDestroy(gconstpointer dataset_location);
	[LinkName("g_dataset_id_get_data")] public static extern gpointer DatasetIdGetData(gconstpointer dataset_location, GQuark key_id);
	[LinkName("g_datalist_get_data")] public static extern gpointer DatalistGetData(GData** datalist, gchar* key);
	[LinkName("g_dataset_id_set_data_full")] public static extern void DatasetIdSetDataFull(gconstpointer dataset_location, GQuark key_id, gpointer data, GDestroyNotify destroy_func);
	[LinkName("g_dataset_id_remove_no_notify")] public static extern gpointer DatasetIdRemoveNoNotify(gconstpointer dataset_location, GQuark key_id);
	[LinkName("g_dataset_foreach")] public static extern void DatasetForeach(gconstpointer dataset_location, GDataForeachFunc func, gpointer user_data);
}

typealias GTime = gint32;

typealias GDateYear = guint16;

typealias GDateDay = guint8;


[AllowDuplicates] enum GDateDMY : c_int
{
	Ay = 0,
	Month = 1,
	Year = 2,
}

[AllowDuplicates] enum GDateWeekday : c_int
{
	BadWeekday = 0,
	Monday = 1,
	Tuesday = 2,
	Dnesday = 3,
	Thursday = 4,
	Friday = 5,
	Saturday = 6,
	Sunday = 7,
}

[AllowDuplicates] enum GDateMonth : c_int
{
	BadMonth = 0,
	January = 1,
	February = 2,
	Arch = 3,
	April = 4,
	Ay = 5,
	June = 6,
	July = 7,
	August = 8,
	September = 9,
	October = 10,
	November = 11,
	December = 12,
}

[CRepr] struct GDate
{
	[Bitfield(.Public, .BitsAt(bits: 32, pos: 0), "julian_days")]
	private uint32 __bitfield_1260876;
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 0), "julian")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 1), "dmy")]
	[Bitfield(.Public, .BitsAt(bits: 6, pos: 2), "day")]
	[Bitfield(.Public, .BitsAt(bits: 4, pos: 8), "month")]
	[Bitfield(.Public, .BitsAt(bits: 16, pos: 12), "year")]
	private uint32 __bitfield_1261035;
}

extension GLib
{
	[LinkName("g_date_new")] public static extern GDate* DateNew();
	[LinkName("g_date_new_dmy")] public static extern GDate* DateNewDmy(GDateDay day, GDateMonth month, GDateYear year);
	[LinkName("g_date_new_julian")] public static extern GDate* DateNewJulian(guint32 julian_day);
	[LinkName("g_date_free")] public static extern void DateFree(GDate* date);
	[LinkName("g_date_copy")] public static extern GDate* DateCopy(GDate* date);
	[LinkName("g_date_valid")] public static extern gboolean DateValid(GDate* date);
	[LinkName("g_date_valid_day")] public static extern gboolean DateValidDay(GDateDay day);
	[LinkName("g_date_valid_month")] public static extern gboolean DateValidMonth(GDateMonth month);
	[LinkName("g_date_valid_year")] public static extern gboolean DateValidYear(GDateYear year);
	[LinkName("g_date_valid_weekday")] public static extern gboolean DateValidWeekday(GDateWeekday weekday);
	[LinkName("g_date_valid_julian")] public static extern gboolean DateValidJulian(guint32 julian_date);
	[LinkName("g_date_valid_dmy")] public static extern gboolean DateValidDmy(GDateDay day, GDateMonth month, GDateYear year);
	[LinkName("g_date_get_weekday")] public static extern GDateWeekday DateGetWeekday(GDate* date);
	[LinkName("g_date_get_month")] public static extern GDateMonth DateGetMonth(GDate* date);
	[LinkName("g_date_get_year")] public static extern GDateYear DateGetYear(GDate* date);
	[LinkName("g_date_get_day")] public static extern GDateDay DateGetDay(GDate* date);
	[LinkName("g_date_get_julian")] public static extern guint32 DateGetJulian(GDate* date);
	[LinkName("g_date_get_day_of_year")] public static extern guint DateGetDayOfYear(GDate* date);
	[LinkName("g_date_get_monday_week_of_year")] public static extern guint DateGetMondayWeekOfYear(GDate* date);
	[LinkName("g_date_get_sunday_week_of_year")] public static extern guint DateGetSundayWeekOfYear(GDate* date);
	[LinkName("g_date_get_iso8601_week_of_year")] public static extern guint DateGetIso8601WeekOfYear(GDate* date);
	[LinkName("g_date_clear")] public static extern void DateClear(GDate* date, guint n_dates);
	[LinkName("g_date_set_parse")] public static extern void DateSetParse(GDate* date, gchar* str);
	[LinkName("g_date_set_time_t")] public static extern void DateSetTimeT(GDate* date, time_t timet);
	[LinkName("g_date_set_time_val")] public static extern void DateSetTimeVal(GDate* date, GTimeVal* timeval);
	[LinkName("g_date_set_time")] public static extern void DateSetTime(GDate* date, GTime time);
	[LinkName("g_date_set_month")] public static extern void DateSetMonth(GDate* date, GDateMonth month);
	[LinkName("g_date_set_day")] public static extern void DateSetDay(GDate* date, GDateDay day);
	[LinkName("g_date_set_year")] public static extern void DateSetYear(GDate* date, GDateYear year);
	[LinkName("g_date_set_dmy")] public static extern void DateSetDmy(GDate* date, GDateDay day, GDateMonth month, GDateYear y);
	[LinkName("g_date_set_julian")] public static extern void DateSetJulian(GDate* date, guint32 julian_date);
	[LinkName("g_date_is_first_of_month")] public static extern gboolean DateIsFirstOfMonth(GDate* date);
	[LinkName("g_date_is_last_of_month")] public static extern gboolean DateIsLastOfMonth(GDate* date);
	[LinkName("g_date_add_days")] public static extern void DateAddDays(GDate* date, guint n_days);
	[LinkName("g_date_subtract_days")] public static extern void DateSubtractDays(GDate* date, guint n_days);
	[LinkName("g_date_add_months")] public static extern void DateAddMonths(GDate* date, guint n_months);
	[LinkName("g_date_subtract_months")] public static extern void DateSubtractMonths(GDate* date, guint n_months);
	[LinkName("g_date_add_years")] public static extern void DateAddYears(GDate* date, guint n_years);
	[LinkName("g_date_subtract_years")] public static extern void DateSubtractYears(GDate* date, guint n_years);
	[LinkName("g_date_is_leap_year")] public static extern gboolean DateIsLeapYear(GDateYear year);
	[LinkName("g_date_get_days_in_month")] public static extern guint8 DateGetDaysInMonth(GDateMonth month, GDateYear year);
	[LinkName("g_date_get_monday_weeks_in_year")] public static extern guint8 DateGetMondayWeeksInYear(GDateYear year);
	[LinkName("g_date_get_sunday_weeks_in_year")] public static extern guint8 DateGetSundayWeeksInYear(GDateYear year);
	[LinkName("g_date_days_between")] public static extern gint DateDaysBetween(GDate* date1, GDate* date2);
	[LinkName("g_date_compare")] public static extern gint DateCompare(GDate* lhs, GDate* rhs);
	[LinkName("g_date_to_struct_tm")] public static extern void DateToStructTm(GDate* date, tm* tm);
	[LinkName("g_date_clamp")] public static extern void DateClamp(GDate* date, GDate* min_date, GDate* max_date);
	[LinkName("g_date_order")] public static extern void DateOrder(GDate* date1, GDate* date2);
	[LinkName("g_date_strftime")] public static extern gsize DateStrftime(gchar* s, gsize slen, gchar* format, GDate* date);
}

struct GDir;

extension GLib
{
	[LinkName("g_dir_open")] public static extern GDir* DirOpen(gchar* path, guint flags, GError** error);
	[LinkName("g_dir_read_name")] public static extern gchar* DirReadName(GDir* dir);
	[LinkName("g_dir_rewind")] public static extern void DirRewind(GDir* dir);
	[LinkName("g_dir_close")] public static extern void DirClose(GDir* dir);
	[LinkName("g_dir_ref")] public static extern GDir* DirRef(GDir* dir);
	[LinkName("g_dir_unref")] public static extern void DirUnref(GDir* dir);
	[LinkName("g_getenv")] public static extern gchar* Getenv(gchar* variable);
	[LinkName("g_setenv")] public static extern gboolean Setenv(gchar* variable, gchar* value, gboolean overwrite);
	[LinkName("g_unsetenv")] public static extern void Unsetenv(gchar* variable);
	[LinkName("g_listenv")] public static extern gchar** Listenv();
	[LinkName("g_get_environ")] public static extern gchar** GetEnviron();
	[LinkName("g_environ_getenv")] public static extern gchar* EnvironGetenv(gchar** envp, gchar* variable);
	[LinkName("g_environ_setenv")] public static extern gchar** EnvironSetenv(gchar** envp, gchar* variable, gchar* value, gboolean overwrite);
	[LinkName("g_environ_unsetenv")] public static extern gchar** EnvironUnsetenv(gchar** envp, gchar* variable);
}

[AllowDuplicates] enum GFileError : c_int
{
	Exist = 0,
	Isdir = 1,
	Acces = 2,
	Nametoolong = 3,
	Noent = 4,
	Notdir = 5,
	Nxio = 6,
	Nodev = 7,
	Rofs = 8,
	Txtbsy = 9,
	Fault = 10,
	Loop = 11,
	Nospc = 12,
	Nomem = 13,
	Mfile = 14,
	Nfile = 15,
	Badf = 16,
	Inval = 17,
	Pipe = 18,
	Again = 19,
	Intr = 20,
	Io = 21,
	Perm = 22,
	Nosys = 23,
	Failed = 24,
}

[AllowDuplicates] enum GFileTest : c_int
{
	IsRegular = 1 << 0,
	IsSymlink = 1 << 1,
	IsDir = 1 << 2,
	IsExecutable = 1 << 3,
	Exists = 1 << 4,
}

/** GFileSetContentsFlags:
 *   @G _FILE_SET_CONTENTS_NONE: No guarantees about file consistency or durability.
 *  The most dangerous setting, which is slightly faster than other settings.
 *   @G _FILE_SET_CONTENTS_CONSISTENT: Guarantee file consistency: after a crash,
 *  either the old version of the file or the new version of the file will be
 *  available, but not a mixture. On Unix systems this equates to an `fsync()`
 *  on the file and use of an atomic `rename()` of the new version of the file
 *  over the old.
 *   @G _FILE_SET_CONTENTS_DURABLE: Guarantee file durability: after a crash, the
 *  new version of the file will be available. On Unix systems this equates to
 *  an `fsync()` on the file (if %G_FILE_SET_CONTENTS_CONSISTENT is unset), or
 *  the effects of %G_FILE_SET_CONTENTS_CONSISTENT plus an `fsync()` on the
 *  directory containing the file after calling `rename()`.
 *   @G _FILE_SET_CONTENTS_ONLY_EXISTING: Only apply consistency and durability
 *  guarantees if the file already exists. This may speed up file operations
 *  if the file doesnt currently exist, but may result in a corrupted version
 *  of the new file if the system crashes while writing it.
 *  
 *  Flags to pass to g_file_set_contents_full() to affect its safety and
 *  performance.
 *  
 *  Since: 2.66
 */
[AllowDuplicates] enum GFileSetContentsFlags : c_int
{
	None = 0,
	Consistent = 1 << 0,
	Durable = 1 << 1,
	OnlyExisting = 1 << 2,
}

extension GLib
{
	[LinkName("g_file_error_quark")] public static extern GQuark FileErrorQuark();
	[LinkName("g_file_error_from_errno")] public static extern GFileError FileErrorFromErrno(gint err_no);
	[LinkName("g_file_test")] public static extern gboolean FileTest(gchar* filename, GFileTest test);
	[LinkName("g_file_get_contents")] public static extern gboolean FileGetContents(gchar* filename, gchar** contents, gsize* length, GError** error);
	[LinkName("g_file_set_contents")] public static extern gboolean FileSetContents(gchar* filename, gchar* contents, gssize length, GError** error);
	[LinkName("g_file_set_contents_full")] public static extern gboolean FileSetContentsFull(gchar* filename, gchar* contents, gssize length, GFileSetContentsFlags flags, c_int mode, GError** error);
	[LinkName("g_file_read_link")] public static extern gchar* FileReadLink(gchar* filename, GError** error);
	[LinkName("g_mkdtemp")] public static extern gchar* Mkdtemp(gchar* tmpl);
	[LinkName("g_mkdtemp_full")] public static extern gchar* MkdtempFull(gchar* tmpl, gint mode);
	[LinkName("g_mkstemp")] public static extern gint Mkstemp(gchar* tmpl);
	[LinkName("g_mkstemp_full")] public static extern gint MkstempFull(gchar* tmpl, gint flags, gint mode);
	[LinkName("g_file_open_tmp")] public static extern gint FileOpenTmp(gchar* tmpl, gchar** name_used, GError** error);
	[LinkName("g_dir_make_tmp")] public static extern gchar* DirMakeTmp(gchar* tmpl, GError** error);
	[LinkName("g_build_path")] public static extern gchar* BuildPath(gchar* separator, gchar* first_element, ...);
	[LinkName("g_build_pathv")] public static extern gchar* BuildPathv(gchar* separator, gchar** args);
	[LinkName("g_build_filename")] public static extern gchar* BuildFilename(gchar* first_element, ...);
	[LinkName("g_build_filenamev")] public static extern gchar* BuildFilenamev(gchar** args);
	[LinkName("g_build_filename_valist")] public static extern gchar* BuildFilenameValist(gchar* first_element, VarArgs* args);
	[LinkName("g_mkdir_with_parents")] public static extern gint MkdirWithParents(gchar* pathname, gint mode);
	[LinkName("g_path_is_absolute")] public static extern gboolean PathIsAbsolute(gchar* file_name);
	[LinkName("g_path_skip_root")] public static extern gchar* PathSkipRoot(gchar* file_name);
	[LinkName("g_basename")] public static extern gchar* Basename(gchar* file_name);
	[LinkName("g_get_current_dir")] public static extern gchar* GetCurrentDir();
	[LinkName("g_path_get_basename")] public static extern gchar* PathGetBasename(gchar* file_name);
	[LinkName("g_path_get_dirname")] public static extern gchar* PathGetDirname(gchar* file_name);
	[LinkName("g_canonicalize_filename")] public static extern gchar* CanonicalizeFilename(gchar* filename, gchar* relative_to);
	[LinkName("g_strip_context")] public static extern gchar* StripContext(gchar* msgid, gchar* msgval);
	[LinkName("g_dgettext")] public static extern gchar* Dgettext(gchar* domain, gchar* msgid);
	[LinkName("g_dcgettext")] public static extern gchar* Dcgettext(gchar* domain, gchar* msgid, gint category);
	[LinkName("g_dngettext")] public static extern gchar* Dngettext(gchar* domain, gchar* msgid, gchar* msgid_plural, gulong n);
	[LinkName("g_dpgettext")] public static extern gchar* Dpgettext(gchar* domain, gchar* msgctxtid, gsize msgidoffset);
	[LinkName("g_dpgettext2")] public static extern gchar* Dpgettext2(gchar* domain, gchar* context, gchar* msgid);
}


extension GLib
{
	[LinkName("g_free")] public static extern void Free(gpointer mem);
	[LinkName("g_free_sized")] public static extern void FreeSized(gpointer mem, c_size size);
	[LinkName("g_clear_pointer")] public static extern void ClearPointer(gpointer* pp, GDestroyNotify destroy);
	[LinkName("g_malloc")] public static extern gpointer Malloc(gsize n_bytes);
	[LinkName("g_malloc0")] public static extern gpointer Malloc0(gsize n_bytes);
	[LinkName("g_realloc")] public static extern gpointer Realloc(gpointer mem, gsize n_bytes);
	[LinkName("g_try_malloc")] public static extern gpointer TryMalloc(gsize n_bytes);
	[LinkName("g_try_malloc0")] public static extern gpointer TryMalloc0(gsize n_bytes);
	[LinkName("g_try_realloc")] public static extern gpointer TryRealloc(gpointer mem, gsize n_bytes);
	[LinkName("g_malloc_n")] public static extern gpointer MallocN(gsize n_blocks, gsize n_block_bytes);
	[LinkName("g_malloc0_n")] public static extern gpointer Malloc0N(gsize n_blocks, gsize n_block_bytes);
	[LinkName("g_realloc_n")] public static extern gpointer ReallocN(gpointer mem, gsize n_blocks, gsize n_block_bytes);
	[LinkName("g_try_malloc_n")] public static extern gpointer TryMallocN(gsize n_blocks, gsize n_block_bytes);
	[LinkName("g_try_malloc0_n")] public static extern gpointer TryMalloc0N(gsize n_blocks, gsize n_block_bytes);
	[LinkName("g_try_realloc_n")] public static extern gpointer TryReallocN(gpointer mem, gsize n_blocks, gsize n_block_bytes);
	[LinkName("g_aligned_alloc")] public static extern gpointer AlignedAlloc(gsize n_blocks, gsize n_block_bytes, gsize alignment);
	[LinkName("g_aligned_alloc0")] public static extern gpointer AlignedAlloc0(gsize n_blocks, gsize n_block_bytes, gsize alignment);
	[LinkName("g_aligned_free")] public static extern void AlignedFree(gpointer mem);
	[LinkName("g_aligned_free_sized")] public static extern void AlignedFreeSized(gpointer mem, c_size alignment, c_size size);
}

[CRepr] struct GMemVTable
{
	public function gpointer(gsize) malloc;
	public function gpointer(gpointer, gsize) realloc;
	public function void(gpointer) free;
	public function gpointer(gsize, gsize) calloc;
	public function gpointer(gsize) try_malloc;
	public function gpointer(gpointer, gsize) try_realloc;
}

extension GLib
{
	[LinkName("g_mem_set_vtable")] public static extern void MemSetVtable(GMemVTable* vtable);
	[LinkName("g_mem_is_system_malloc")] public static extern gboolean MemIsSystemMalloc();
}

static
{
	[CLink] public static extern gboolean g_mem_gc_friendly;
	[CLink] public static extern GMemVTable* glib_mem_profiler_table;
}

extension GLib
{
	[LinkName("g_mem_profile")] public static extern void MemProfile();
}


[AllowDuplicates] enum GTraverseFlags : c_int
{
	Leaves = 1 << 0,
	NonLeaves = 1 << 1,
	All = Leaves | NonLeaves,
	Mask = 0x03,
	Leafs = Leaves,
	NonLeafs = NonLeaves,
}

[AllowDuplicates] enum GTraverseType : c_int
{
	InOrder = 0,
	PreOrder = 1,
	PostOrder = 2,
	LevelOrder = 3,
}

function gboolean GNodeTraverseFunc(GNode* node, gpointer data);

function void GNodeForeachFunc(GNode* node, gpointer data);

[CRepr] struct GNode
{
	public gpointer data;
	public GNode* next;
	public GNode* prev;
	public GNode* parent;
	public GNode* children;
}

extension GLib
{
	[LinkName("g_node_new")] public static extern GNode* NodeNew(gpointer data);
	[LinkName("g_node_destroy")] public static extern void NodeDestroy(GNode* root);
	[LinkName("g_node_unlink")] public static extern void NodeUnlink(GNode* node);
	[LinkName("g_node_copy_deep")] public static extern GNode* NodeCopyDeep(GNode* node, GCopyFunc copy_func, gpointer data);
	[LinkName("g_node_copy")] public static extern GNode* NodeCopy(GNode* node);
	[LinkName("g_node_insert")] public static extern GNode* NodeInsert(GNode* parent, gint position, GNode* node);
	[LinkName("g_node_insert_before")] public static extern GNode* NodeInsertBefore(GNode* parent, GNode* sibling, GNode* node);
	[LinkName("g_node_insert_after")] public static extern GNode* NodeInsertAfter(GNode* parent, GNode* sibling, GNode* node);
	[LinkName("g_node_prepend")] public static extern GNode* NodePrepend(GNode* parent, GNode* node);
	[LinkName("g_node_n_nodes")] public static extern guint NodeNNodes(GNode* root, GTraverseFlags flags);
	[LinkName("g_node_get_root")] public static extern GNode* NodeGetRoot(GNode* node);
	[LinkName("g_node_is_ancestor")] public static extern gboolean NodeIsAncestor(GNode* node, GNode* descendant);
	[LinkName("g_node_depth")] public static extern guint NodeDepth(GNode* node);
	[LinkName("g_node_find")] public static extern GNode* NodeFind(GNode* root, GTraverseType order, GTraverseFlags flags, gpointer data);
	[LinkName("g_node_traverse")] public static extern void NodeTraverse(GNode* root, GTraverseType order, GTraverseFlags flags, gint max_depth, GNodeTraverseFunc func, gpointer data);
	[LinkName("g_node_max_height")] public static extern guint NodeMaxHeight(GNode* root);
	[LinkName("g_node_children_foreach")] public static extern void NodeChildrenForeach(GNode* node, GTraverseFlags flags, GNodeForeachFunc func, gpointer data);
	[LinkName("g_node_reverse_children")] public static extern void NodeReverseChildren(GNode* node);
	[LinkName("g_node_n_children")] public static extern guint NodeNChildren(GNode* node);
	[LinkName("g_node_nth_child")] public static extern GNode* NodeNthChild(GNode* node, guint n);
	[LinkName("g_node_last_child")] public static extern GNode* NodeLastChild(GNode* node);
	[LinkName("g_node_find_child")] public static extern GNode* NodeFindChild(GNode* node, GTraverseFlags flags, gpointer data);
	[LinkName("g_node_child_position")] public static extern gint NodeChildPosition(GNode* node, GNode* child);
	[LinkName("g_node_child_index")] public static extern gint NodeChildIndex(GNode* node, gpointer data);
	[LinkName("g_node_first_sibling")] public static extern GNode* NodeFirstSibling(GNode* node);
	[LinkName("g_node_last_sibling")] public static extern GNode* NodeLastSibling(GNode* node);
}


[CRepr] struct GList
{
	public gpointer data;
	public GList* next;
	public GList* prev;
}

extension GLib
{
	[LinkName("g_list_alloc")] public static extern GList* ListAlloc();
	[LinkName("g_list_free")] public static extern void ListFree(GList* list);
	[LinkName("g_list_free_1")] public static extern void ListFree1(GList* list);
	[LinkName("g_list_free_full")] public static extern void ListFreeFull(GList* list, GDestroyNotify free_func);
	[LinkName("g_list_append")] public static extern GList* ListAppend(GList* list, gpointer data);
	[LinkName("g_list_prepend")] public static extern GList* ListPrepend(GList* list, gpointer data);
	[LinkName("g_list_insert")] public static extern GList* ListInsert(GList* list, gpointer data, gint position);
	[LinkName("g_list_insert_sorted")] public static extern GList* ListInsertSorted(GList* list, gpointer data, GCompareFunc func);
	[LinkName("g_list_insert_sorted_with_data")] public static extern GList* ListInsertSortedWithData(GList* list, gpointer data, GCompareDataFunc func, gpointer user_data);
	[LinkName("g_list_insert_before")] public static extern GList* ListInsertBefore(GList* list, GList* sibling, gpointer data);
	[LinkName("g_list_insert_before_link")] public static extern GList* ListInsertBeforeLink(GList* list, GList* sibling, GList* link);
	[LinkName("g_list_concat")] public static extern GList* ListConcat(GList* list1, GList* list2);
	[LinkName("g_list_remove")] public static extern GList* ListRemove(GList* list, gconstpointer data);
	[LinkName("g_list_remove_all")] public static extern GList* ListRemoveAll(GList* list, gconstpointer data);
	[LinkName("g_list_remove_link")] public static extern GList* ListRemoveLink(GList* list, GList* llink);
	[LinkName("g_list_delete_link")] public static extern GList* ListDeleteLink(GList* list, GList* link);
	[LinkName("g_list_reverse")] public static extern GList* ListReverse(GList* list);
	[LinkName("g_list_copy")] public static extern GList* ListCopy(GList* list);
	[LinkName("g_list_copy_deep")] public static extern GList* ListCopyDeep(GList* list, GCopyFunc func, gpointer user_data);
	[LinkName("g_list_nth")] public static extern GList* ListNth(GList* list, guint n);
	[LinkName("g_list_nth_prev")] public static extern GList* ListNthPrev(GList* list, guint n);
	[LinkName("g_list_find")] public static extern GList* ListFind(GList* list, gconstpointer data);
	[LinkName("g_list_find_custom")] public static extern GList* ListFindCustom(GList* list, gconstpointer data, GCompareFunc func);
	[LinkName("g_list_position")] public static extern gint ListPosition(GList* list, GList* llink);
	[LinkName("g_list_index")] public static extern gint ListIndex(GList* list, gconstpointer data);
	[LinkName("g_list_last")] public static extern GList* ListLast(GList* list);
	[LinkName("g_list_first")] public static extern GList* ListFirst(GList* list);
	[LinkName("g_list_length")] public static extern guint ListLength(GList* list);
	[LinkName("g_list_foreach")] public static extern void ListForeach(GList* list, GFunc func, gpointer user_data);
	[LinkName("g_list_sort")] public static extern GList* ListSort(GList* list, GCompareFunc compare_func);
	[LinkName("g_list_sort_with_data")] public static extern GList* ListSortWithData(GList* list, GCompareDataFunc compare_func, gpointer user_data);
	[LinkName("g_list_nth_data")] public static extern gpointer ListNthData(GList* list, guint n);
	[LinkName("g_clear_list")] public static extern void ClearList(GList** list_ptr, GDestroyNotify destroy);
}

struct GHashTable;

function gboolean GHRFunc(gpointer key, gpointer value, gpointer user_data);


[CRepr] struct GHashTableIter
{
	public gpointer dummy1;
	public gpointer dummy2;
	public gpointer dummy3;
	public c_int dummy4;
	public gboolean dummy5;
	public gpointer dummy6;
}

extension GLib
{
	[LinkName("g_hash_table_new")] public static extern GHashTable* HashTableNew(GHashFunc hash_func, GEqualFunc key_equal_func);
	[LinkName("g_hash_table_new_full")] public static extern GHashTable* HashTableNewFull(GHashFunc hash_func, GEqualFunc key_equal_func, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func);
	[LinkName("g_hash_table_new_similar")] public static extern GHashTable* HashTableNewSimilar(GHashTable* other_hash_table);
	[LinkName("g_hash_table_destroy")] public static extern void HashTableDestroy(GHashTable* hash_table);
	[LinkName("g_hash_table_insert")] public static extern gboolean HashTableInsert(GHashTable* hash_table, gpointer key, gpointer value);
	[LinkName("g_hash_table_replace")] public static extern gboolean HashTableReplace(GHashTable* hash_table, gpointer key, gpointer value);
	[LinkName("g_hash_table_add")] public static extern gboolean HashTableAdd(GHashTable* hash_table, gpointer key);
	[LinkName("g_hash_table_remove")] public static extern gboolean HashTableRemove(GHashTable* hash_table, gconstpointer key);
	[LinkName("g_hash_table_remove_all")] public static extern void HashTableRemoveAll(GHashTable* hash_table);
	[LinkName("g_hash_table_steal")] public static extern gboolean HashTableSteal(GHashTable* hash_table, gconstpointer key);
	[LinkName("g_hash_table_steal_extended")] public static extern gboolean HashTableStealExtended(GHashTable* hash_table, gconstpointer lookup_key, gpointer* stolen_key, gpointer* stolen_value);
	[LinkName("g_hash_table_steal_all")] public static extern void HashTableStealAll(GHashTable* hash_table);
	[LinkName("g_hash_table_steal_all_keys")] public static extern GPtrArray* HashTableStealAllKeys(GHashTable* hash_table);
	[LinkName("g_hash_table_steal_all_values")] public static extern GPtrArray* HashTableStealAllValues(GHashTable* hash_table);
	[LinkName("g_hash_table_lookup")] public static extern gpointer HashTableLookup(GHashTable* hash_table, gconstpointer key);
	[LinkName("g_hash_table_contains")] public static extern gboolean HashTableContains(GHashTable* hash_table, gconstpointer key);
	[LinkName("g_hash_table_lookup_extended")] public static extern gboolean HashTableLookupExtended(GHashTable* hash_table, gconstpointer lookup_key, gpointer* orig_key, gpointer* value);
	[LinkName("g_hash_table_foreach")] public static extern void HashTableForeach(GHashTable* hash_table, GHFunc func, gpointer user_data);
	[LinkName("g_hash_table_find")] public static extern gpointer HashTableFind(GHashTable* hash_table, GHRFunc predicate, gpointer user_data);
	[LinkName("g_hash_table_foreach_remove")] public static extern guint HashTableForeachRemove(GHashTable* hash_table, GHRFunc func, gpointer user_data);
	[LinkName("g_hash_table_foreach_steal")] public static extern guint HashTableForeachSteal(GHashTable* hash_table, GHRFunc func, gpointer user_data);
	[LinkName("g_hash_table_size")] public static extern guint HashTableSize(GHashTable* hash_table);
	[LinkName("g_hash_table_get_keys")] public static extern GList* HashTableGetKeys(GHashTable* hash_table);
	[LinkName("g_hash_table_get_values")] public static extern GList* HashTableGetValues(GHashTable* hash_table);
	[LinkName("g_hash_table_get_keys_as_array")] public static extern gpointer* HashTableGetKeysAsArray(GHashTable* hash_table, guint* length);
	[LinkName("g_hash_table_get_keys_as_ptr_array")] public static extern GPtrArray* HashTableGetKeysAsPtrArray(GHashTable* hash_table);
	[LinkName("g_hash_table_get_values_as_ptr_array")] public static extern GPtrArray* HashTableGetValuesAsPtrArray(GHashTable* hash_table);
	[LinkName("g_hash_table_iter_init")] public static extern void HashTableIterInit(GHashTableIter* iter, GHashTable* hash_table);
	[LinkName("g_hash_table_iter_next")] public static extern gboolean HashTableIterNext(GHashTableIter* iter, gpointer* key, gpointer* value);
	[LinkName("g_hash_table_iter_get_hash_table")] public static extern GHashTable* HashTableIterGetHashTable(GHashTableIter* iter);
	[LinkName("g_hash_table_iter_remove")] public static extern void HashTableIterRemove(GHashTableIter* iter);
	[LinkName("g_hash_table_iter_replace")] public static extern void HashTableIterReplace(GHashTableIter* iter, gpointer value);
	[LinkName("g_hash_table_iter_steal")] public static extern void HashTableIterSteal(GHashTableIter* iter);
	[LinkName("g_hash_table_ref")] public static extern GHashTable* HashTableRef(GHashTable* hash_table);
	[LinkName("g_hash_table_unref")] public static extern void HashTableUnref(GHashTable* hash_table);
	[LinkName("g_str_equal")] public static extern gboolean StrEqual(gconstpointer v1, gconstpointer v2);
	[LinkName("g_str_hash")] public static extern guint StrHash(gconstpointer v);
	[LinkName("g_int_equal")] public static extern gboolean IntEqual(gconstpointer v1, gconstpointer v2);
	[LinkName("g_int_hash")] public static extern guint IntHash(gconstpointer v);
	[LinkName("g_int64_equal")] public static extern gboolean Int64Equal(gconstpointer v1, gconstpointer v2);
	[LinkName("g_int64_hash")] public static extern guint Int64Hash(gconstpointer v);
	[LinkName("g_double_equal")] public static extern gboolean DoubleEqual(gconstpointer v1, gconstpointer v2);
	[LinkName("g_double_hash")] public static extern guint DoubleHash(gconstpointer v);
	[LinkName("g_direct_hash")] public static extern guint DirectHash(gconstpointer v);
	[LinkName("g_direct_equal")] public static extern gboolean DirectEqual(gconstpointer v1, gconstpointer v2);
}

struct GHmac;

extension GLib
{
	[LinkName("g_hmac_new")] public static extern GHmac* HmacNew(GChecksumType digest_type, guchar* key, gsize key_len);
	[LinkName("g_hmac_copy")] public static extern GHmac* HmacCopy(GHmac* hmac);
	[LinkName("g_hmac_ref")] public static extern GHmac* HmacRef(GHmac* hmac);
	[LinkName("g_hmac_unref")] public static extern void HmacUnref(GHmac* hmac);
	[LinkName("g_hmac_update")] public static extern void HmacUpdate(GHmac* hmac, guchar* data, gssize length);
	[LinkName("g_hmac_get_string")] public static extern gchar* HmacGetString(GHmac* hmac);
	[LinkName("g_hmac_get_digest")] public static extern void HmacGetDigest(GHmac* hmac, guint8* buffer, gsize* digest_len);
	[LinkName("g_compute_hmac_for_data")] public static extern gchar* ComputeHmacForData(GChecksumType digest_type, guchar* key, gsize key_len, guchar* data, gsize length);
	[LinkName("g_compute_hmac_for_string")] public static extern gchar* ComputeHmacForString(GChecksumType digest_type, guchar* key, gsize key_len, gchar* str, gssize length);
	[LinkName("g_compute_hmac_for_bytes")] public static extern gchar* ComputeHmacForBytes(GChecksumType digest_type, GBytes* key, GBytes* data);
}



function gint GHookCompareFunc(GHook* new_hook, GHook* sibling);

function gboolean GHookFindFunc(GHook* hook, gpointer data);

function void GHookMarshaller(GHook* hook, gpointer marshal_data);

function gboolean GHookCheckMarshaller(GHook* hook, gpointer marshal_data);

function void GHookFunc(gpointer data);

function gboolean GHookCheckFunc(gpointer data);

function void GHookFinalizeFunc(GHookList* hook_list, GHook* hook);

[AllowDuplicates] enum GHookFlagMask : c_int
{
	Active = 1 << 0,
	InCall = 1 << 1,
	K = 0x0f,
}

[CRepr] struct GHookList
{
	public gulong seq_id;
	[Bitfield(.Public, .BitsAt(bits: 16, pos: 0), "hook_size")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 16), "is_setup")]
	private uint32 __bitfield_1354334;
	public GHook* hooks;
	public gpointer dummy3;
	public GHookFinalizeFunc finalize_hook;
	public gpointer[2] dummy;
}

[CRepr] struct GHook
{
	public gpointer data;
	public GHook* next;
	public GHook* prev;
	public guint ref_count;
	public gulong hook_id;
	public guint flags;
	public gpointer func;
	public GDestroyNotify destroy;
}

extension GLib
{
	[LinkName("g_hook_list_init")] public static extern void HookListInit(GHookList* hook_list, guint hook_size);
	[LinkName("g_hook_list_clear")] public static extern void HookListClear(GHookList* hook_list);
	[LinkName("g_hook_alloc")] public static extern GHook* HookAlloc(GHookList* hook_list);
	[LinkName("g_hook_free")] public static extern void HookFree(GHookList* hook_list, GHook* hook);
	[LinkName("g_hook_ref")] public static extern GHook* HookRef(GHookList* hook_list, GHook* hook);
	[LinkName("g_hook_unref")] public static extern void HookUnref(GHookList* hook_list, GHook* hook);
	[LinkName("g_hook_destroy")] public static extern gboolean HookDestroy(GHookList* hook_list, gulong hook_id);
	[LinkName("g_hook_destroy_link")] public static extern void HookDestroyLink(GHookList* hook_list, GHook* hook);
	[LinkName("g_hook_prepend")] public static extern void HookPrepend(GHookList* hook_list, GHook* hook);
	[LinkName("g_hook_insert_before")] public static extern void HookInsertBefore(GHookList* hook_list, GHook* sibling, GHook* hook);
	[LinkName("g_hook_insert_sorted")] public static extern void HookInsertSorted(GHookList* hook_list, GHook* hook, GHookCompareFunc func);
	[LinkName("g_hook_get")] public static extern GHook* HookGet(GHookList* hook_list, gulong hook_id);
	[LinkName("g_hook_find")] public static extern GHook* HookFind(GHookList* hook_list, gboolean need_valids, GHookFindFunc func, gpointer data);
	[LinkName("g_hook_find_data")] public static extern GHook* HookFindData(GHookList* hook_list, gboolean need_valids, gpointer data);
	[LinkName("g_hook_find_func")] public static extern GHook* HookFindFunc(GHookList* hook_list, gboolean need_valids, gpointer func);
	[LinkName("g_hook_find_func_data")] public static extern GHook* HookFindFuncData(GHookList* hook_list, gboolean need_valids, gpointer func, gpointer data);
	[LinkName("g_hook_first_valid")] public static extern GHook* HookFirstValid(GHookList* hook_list, gboolean may_be_in_call);
	[LinkName("g_hook_next_valid")] public static extern GHook* HookNextValid(GHookList* hook_list, GHook* hook, gboolean may_be_in_call);
	[LinkName("g_hook_compare_ids")] public static extern gint HookCompareIds(GHook* new_hook, GHook* sibling);
	[LinkName("g_hook_list_invoke")] public static extern void HookListInvoke(GHookList* hook_list, gboolean may_recurse);
	[LinkName("g_hook_list_invoke_check")] public static extern void HookListInvokeCheck(GHookList* hook_list, gboolean may_recurse);
	[LinkName("g_hook_list_marshal")] public static extern void HookListMarshal(GHookList* hook_list, gboolean may_recurse, GHookMarshaller marshaller, gpointer marshal_data);
	[LinkName("g_hook_list_marshal_check")] public static extern void HookListMarshalCheck(GHookList* hook_list, gboolean may_recurse, GHookCheckMarshaller marshaller, gpointer marshal_data);
	[LinkName("g_hostname_is_non_ascii")] public static extern gboolean HostnameIsNonAscii(gchar* hostname);
	[LinkName("g_hostname_is_ascii_encoded")] public static extern gboolean HostnameIsAsciiEncoded(gchar* hostname);
	[LinkName("g_hostname_is_ip_address")] public static extern gboolean HostnameIsIpAddress(gchar* hostname);
	[LinkName("g_hostname_to_ascii")] public static extern gchar* HostnameToAscii(gchar* hostname);
	[LinkName("g_hostname_to_unicode")] public static extern gchar* HostnameToUnicode(gchar* hostname);
}


/** GPollFunc:
 *   @ufds : an array of #GPollFD elements
 *   @nfsd : the number of elements in @ufds
 *   @timeout _: the maximum time to wait for an event of the file descriptors.
 *  A negative value indicates an infinite timeout.
 *  
 *  Specifies the type of function passed to g_main_context_set_poll_func().
 *  The semantics of the function should match those of the poll() system call.
 *  
 *  Returns: the number of #GPollFD elements which have events or errors
 *  reported, or -1 if an error occurred.
 */
function gint GPollFunc(GPollFD* ufds, guint nfsd, gint timeout_);

/** GPollFD:
 *   @fd : the file descriptor to poll (or a HANDLE on Win32)
 *   @events : a bitwise combination from #GIOCondition, specifying which
 *  events should be polled for. Typically for reading from a file
 *  descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and
 *  for writing you would use %G_IO_OUT | %G_IO_ERR.
 *   @revents : a bitwise combination of flags from #GIOCondition, returned
 *  from the poll() function to indicate which events occurred.
 *  
 *  Represents a file descriptor, which events to poll for, and which events
 *  occurred.
 */
[CRepr] struct GPollFD
{
	public gint64 fd;
	public gushort events;
	public gushort revents;
}

extension GLib
{
	/** G_POLLFD_FORMAT:
	 *  
	 *  A format specifier that can be used in printf()-style format strings
	 *  when printing the @fd member of a #GPollFD.
	 */
	[LinkName("g_poll")] public static extern gint Poll(GPollFD* fds, guint nfds, gint timeout);

}


[CRepr] struct GSList
{
	public gpointer data;
	public GSList* next;
}

extension GLib
{
	[LinkName("g_slist_alloc")] public static extern GSList* SlistAlloc();
	[LinkName("g_slist_free")] public static extern void SlistFree(GSList* list);
	[LinkName("g_slist_free_1")] public static extern void SlistFree1(GSList* list);
	[LinkName("g_slist_free_full")] public static extern void SlistFreeFull(GSList* list, GDestroyNotify free_func);
	[LinkName("g_slist_append")] public static extern GSList* SlistAppend(GSList* list, gpointer data);
	[LinkName("g_slist_prepend")] public static extern GSList* SlistPrepend(GSList* list, gpointer data);
	[LinkName("g_slist_insert")] public static extern GSList* SlistInsert(GSList* list, gpointer data, gint position);
	[LinkName("g_slist_insert_sorted")] public static extern GSList* SlistInsertSorted(GSList* list, gpointer data, GCompareFunc func);
	[LinkName("g_slist_insert_sorted_with_data")] public static extern GSList* SlistInsertSortedWithData(GSList* list, gpointer data, GCompareDataFunc func, gpointer user_data);
	[LinkName("g_slist_insert_before")] public static extern GSList* SlistInsertBefore(GSList* slist, GSList* sibling, gpointer data);
	[LinkName("g_slist_concat")] public static extern GSList* SlistConcat(GSList* list1, GSList* list2);
	[LinkName("g_slist_remove")] public static extern GSList* SlistRemove(GSList* list, gconstpointer data);
	[LinkName("g_slist_remove_all")] public static extern GSList* SlistRemoveAll(GSList* list, gconstpointer data);
	[LinkName("g_slist_remove_link")] public static extern GSList* SlistRemoveLink(GSList* list, GSList* link);
	[LinkName("g_slist_delete_link")] public static extern GSList* SlistDeleteLink(GSList* list, GSList* link);
	[LinkName("g_slist_reverse")] public static extern GSList* SlistReverse(GSList* list);
	[LinkName("g_slist_copy")] public static extern GSList* SlistCopy(GSList* list);
	[LinkName("g_slist_copy_deep")] public static extern GSList* SlistCopyDeep(GSList* list, GCopyFunc func, gpointer user_data);
	[LinkName("g_slist_nth")] public static extern GSList* SlistNth(GSList* list, guint n);
	[LinkName("g_slist_find")] public static extern GSList* SlistFind(GSList* list, gconstpointer data);
	[LinkName("g_slist_find_custom")] public static extern GSList* SlistFindCustom(GSList* list, gconstpointer data, GCompareFunc func);
	[LinkName("g_slist_position")] public static extern gint SlistPosition(GSList* list, GSList* llink);
	[LinkName("g_slist_index")] public static extern gint SlistIndex(GSList* list, gconstpointer data);
	[LinkName("g_slist_last")] public static extern GSList* SlistLast(GSList* list);
	[LinkName("g_slist_length")] public static extern guint SlistLength(GSList* list);
	[LinkName("g_slist_foreach")] public static extern void SlistForeach(GSList* list, GFunc func, gpointer user_data);
	[LinkName("g_slist_sort")] public static extern GSList* SlistSort(GSList* list, GCompareFunc compare_func);
	[LinkName("g_slist_sort_with_data")] public static extern GSList* SlistSortWithData(GSList* list, GCompareDataFunc compare_func, gpointer user_data);
	[LinkName("g_slist_nth_data")] public static extern gpointer SlistNthData(GSList* list, guint n);
	[LinkName("g_clear_slist")] public static extern void ClearSlist(GSList** slist_ptr, GDestroyNotify destroy);
}

[AllowDuplicates] enum GIOCondition : c_int
{
	In = 1,
	Out = 4,
	Pri = 2,
	Err = 8,
	Hup = 16,
	Nval = 32,
}

/** GMainContextFlags:
 *   @G _MAIN_CONTEXT_FLAGS_NONE: Default behaviour.
 *   @G _MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING: Assume that polling for events will
 *  free the thread to process other jobs. That's useful if you're using
 *  `g_main_context_{prepare,query,check,dispatch}` to integrate GMainContext in
 *  other event loops.
 *  
 *  Flags to pass to [ctor @GLib .MainContext.new_with_flags] which affect the
 *  behaviour of a [struct @GLib .MainContext].
 *  
 *  Since: 2.72
 */
[AllowDuplicates] enum GMainContextFlags : c_int
{
	None = 0,
	OwnerlessPolling = 1,
}

struct GMainContext;

struct GMainLoop;


struct GSourcePrivate;



/** GSourceFunc:
 *   @user _data: data passed to the function, set when the source was
 *  created with one of the above functions
 *  
 *  Specifies the type of function passed to [func @GLib .timeout_add],
 *  [func @GLib .timeout_add_full], [func @GLib .idle_add], and
 *  [func @GLib .idle_add_full].
 *  
 *  When calling [method @GLib .Source.set_callback], you may need to cast a
 *  function of a different type to this type. Use [func @GLib .SOURCE_FUNC] to
 *  avoid warnings about incompatible function types.
 *  
 *  Returns: %FALSE if the source should be removed.
 *  [const @GLib .SOURCE_CONTINUE] and [const @GLib .SOURCE_REMOVE] are more
 *  memorable names for the return value.
 */
function gboolean GSourceFunc(gpointer user_data);

/** GSourceOnceFunc:
 *   @user _data: data passed to the function, set when the source was
 *  created
 *  
 *  A source function that is only called once before being removed from the main
 *  context automatically.
 *  
 *  See: [func @GLib .idle_add_once], [func @GLib .timeout_add_once]
 *  
 *  Since: 2.74
 */
function void GSourceOnceFunc(gpointer user_data);

/** GChildWatchFunc:
 *   @pid : the process id of the child process
 *   @wait _status: Status information about the child process, encoded
 *  in a platform-specific manner
 *   @user _data: user data passed to [func @GLib .child_watch_add]
 *  
 *  Prototype of a #GChildWatchSource callback, called when a child
 *  process has exited.
 *  
 *  To interpret @wait _status, see the documentation for
 *  [func @GLib .spawn_check_wait_status]. In particular,
 *  on Unix platforms, note that it is usually not equal
 *  to the integer passed to `exit()` or returned from `main()`.
 */
function void GChildWatchFunc(GPid pid, gint wait_status, gpointer user_data);

/** GSourceDisposeFunc:
 *   @source : #GSource that is currently being disposed
 *  
 *  Dispose function for @source . See [method @GLib .Source.set_dispose_function]
 *  for details.
 *  
 *  Since: 2.64
 */
function void GSourceDisposeFunc(GSource* source);

[CRepr] struct GSource
{
	public gpointer callback_data;
	public GSourceCallbackFuncs* callback_funcs;
	public GSourceFuncs* source_funcs;
	public guint ref_count;
	public GMainContext* context;
	public gint priority;
	public guint flags;
	public guint source_id;
	public GSList* poll_fds;
	public GSource* prev;
	public GSource* next;
	public c_char* name;
	public GSourcePrivate* priv;
}

[CRepr] struct GSourceCallbackFuncs
{
	public function void(gpointer) @ref;
	public function void(gpointer) unref;
	public function void(gpointer, GSource*, GSourceFunc*, gpointer*) get;
}

/** GSourceDummyMarshal:
 *  
 *  This is just a placeholder for #GClosureMarshal,
 *  which cannot be used here for dependency reasons.
 */
function void GSourceDummyMarshal();

/** GSourceFuncsPrepareFunc:
 *   @source : The #GSource
 *   @timeout _: (out) (optional): the maximum timeout (in milliseconds) which should be passed to the poll call
 *  
 *  Checks the source for readiness.
 *  
 *  Called before all the file descriptors are polled. If the
 *  source can determine that it is ready here (without waiting for the
 *  results of the poll call) it should return %TRUE. It can also return
 *  a @timeout _ value which should be the maximum timeout (in milliseconds)
 *  which should be passed to the poll call. The actual timeout used will
 *  be `-1` if all sources returned `-1`, or it will be the minimum of all
 *  the @timeout _ values returned which were greater than or equal to `0`.
 *  If the prepare function returns a timeout and the source also has a
 *  ready time set, then the lower of the two will be used.
 *  
 *  Since 2.36 this may be `NULL`, in which case the effect is as if the
 *  function always returns `FALSE` with a timeout of `-1`.
 *  
 *  Returns: %TRUE if the source is ready, %FALSE otherwise
 *  
 *  Since: 2.82
 */
function gboolean GSourceFuncsPrepareFunc(GSource* source, gint* timeout_);

/** GSourceFuncsCheckFunc:
 *   @source : The #GSource
 *  
 *  Checks if the source is ready to be dispatched.
 *  
 *  Called after all the file descriptors are polled. The source
 *  should return %TRUE if it is ready to be dispatched. Note that some
 *  time may have passed since the previous prepare function was called,
 *  so the source should be checked again here.
 *  
 *  Since 2.36 this may be `NULL`, in which case the effect is
 *  as if the function always returns `FALSE`.
 *  
 *  Returns: %TRUE if ready to be dispatched, %FALSE otherwise
 *  
 *  Since: 2.82
 */
function gboolean GSourceFuncsCheckFunc(GSource* source);

/** GSourceFuncsDispatchFunc:
 *   @source : The #GSource
 *  
 *  `: (nullable): The #GSourceFunc to call`
 *  
 *   @user _data: (nullable): data to pass to
 *  ``
 *  
 *  Dispatches the source callback.
 *  
 *  Called to dispatch the event source, after it has returned
 *  `TRUE` in either its prepare or its check function, or if a ready time
 *  has been reached. The dispatch function receives a callback function and
 *  user data. The callback function may be `NULL` if the source was never
 *  connected to a callback using [method @GLib .Source.set_callback]. The dispatch
 *  function should call the callback function with @user _data and whatever
 *  additional parameters are needed for this type of event source. The
 *  return value of the dispatch function should be [const @GLib .SOURCE_REMOVE]
 *  if the source should be removed or [const @GLib .SOURCE_CONTINUE] to keep it.
 *  
 *  Returns: [const @GLib .SOURCE_REMOVE] if the source should be removed,
 *  [const @GLib .SOURCE_CONTINUE] otherwise.
 *  
 *  Since: 2.82
 */
function gboolean GSourceFuncsDispatchFunc(GSource* source, GSourceFunc callback, gpointer user_data);

/** GSourceFuncsFinalizeFunc:
 *   @source : The #GSource
 *  
 *  Finalizes the source.
 *  
 *  Called when the source is finalized. At this point, the source
 *  will have been destroyed, had its callback cleared, and have been removed
 *  from its [type @GLib .MainContext], but it will still have its final reference
 *  count, so methods can be called on it from within this function.
 *  
 *  Since: 2.82
 */
function void GSourceFuncsFinalizeFunc(GSource* source);

[CRepr] struct GSourceFuncs
{
	public GSourceFuncsPrepareFunc prepare;
	public GSourceFuncsCheckFunc check;
	public GSourceFuncsDispatchFunc dispatch;
	public GSourceFuncsFinalizeFunc finalize;
	public GSourceFunc closure_callback;
	public GSourceDummyMarshal closure_marshal;
}

extension GLib
{
	[LinkName("g_main_context_new")] public static extern GMainContext* MainContextNew();
	[LinkName("g_main_context_new_with_flags")] public static extern GMainContext* MainContextNewWithFlags(GMainContextFlags flags);
	[LinkName("g_main_context_ref")] public static extern GMainContext* MainContextRef(GMainContext* context);
	[LinkName("g_main_context_unref")] public static extern void MainContextUnref(GMainContext* context);
	[LinkName("g_main_context_default")] public static extern GMainContext* MainContextDefault();
	[LinkName("g_main_context_iteration")] public static extern gboolean MainContextIteration(GMainContext* context, gboolean may_block);
	[LinkName("g_main_context_pending")] public static extern gboolean MainContextPending(GMainContext* context);
	[LinkName("g_main_context_find_source_by_id")] public static extern GSource* MainContextFindSourceById(GMainContext* context, guint source_id);
	[LinkName("g_main_context_find_source_by_user_data")] public static extern GSource* MainContextFindSourceByUserData(GMainContext* context, gpointer user_data);
	[LinkName("g_main_context_find_source_by_funcs_user_data")] public static extern GSource* MainContextFindSourceByFuncsUserData(GMainContext* context, GSourceFuncs* funcs, gpointer user_data);
	[LinkName("g_main_context_wakeup")] public static extern void MainContextWakeup(GMainContext* context);
	[LinkName("g_main_context_acquire")] public static extern gboolean MainContextAcquire(GMainContext* context);
	[LinkName("g_main_context_release")] public static extern void MainContextRelease(GMainContext* context);
	[LinkName("g_main_context_is_owner")] public static extern gboolean MainContextIsOwner(GMainContext* context);
	[LinkName("g_main_context_wait")] public static extern gboolean MainContextWait(GMainContext* context, GCond* cond, GMutex* mutex);
	[LinkName("g_main_context_prepare")] public static extern gboolean MainContextPrepare(GMainContext* context, gint* priority);
	[LinkName("g_main_context_query")] public static extern gint MainContextQuery(GMainContext* context, gint max_priority, gint* timeout, GPollFD* fds, gint n_fds);
	[LinkName("g_main_context_check")] public static extern gboolean MainContextCheck(GMainContext* context, gint max_priority, GPollFD* fds, gint n_fds);
	[LinkName("g_main_context_dispatch")] public static extern void MainContextDispatch(GMainContext* context);
	[LinkName("g_main_context_set_poll_func")] public static extern void MainContextSetPollFunc(GMainContext* context, GPollFunc func);
	[LinkName("g_main_context_get_poll_func")] public static extern GPollFunc MainContextGetPollFunc(GMainContext* context);
	[LinkName("g_main_context_add_poll")] public static extern void MainContextAddPoll(GMainContext* context, GPollFD* fd, gint priority);
	[LinkName("g_main_context_remove_poll")] public static extern void MainContextRemovePoll(GMainContext* context, GPollFD* fd);
	[LinkName("g_main_depth")] public static extern gint MainDepth();
	[LinkName("g_main_current_source")] public static extern GSource* MainCurrentSource();
	[LinkName("g_main_context_push_thread_default")] public static extern void MainContextPushThreadDefault(GMainContext* context);
	[LinkName("g_main_context_pop_thread_default")] public static extern void MainContextPopThreadDefault(GMainContext* context);
	[LinkName("g_main_context_get_thread_default")] public static extern GMainContext* MainContextGetThreadDefault();
	[LinkName("g_main_context_ref_thread_default")] public static extern GMainContext* MainContextRefThreadDefault();
}

/** GMainContextPusher:
 *  
 *  Opaque type. See g_main_context_pusher_new() for details.
 *  
 *  Since: 2.64
 */
typealias GMainContextPusher = void;

extension GLib
{
	[LinkName("g_main_loop_new")] public static extern GMainLoop* MainLoopNew(GMainContext* context, gboolean is_running);
	[LinkName("g_main_loop_run")] public static extern void MainLoopRun(GMainLoop* loop);
	[LinkName("g_main_loop_quit")] public static extern void MainLoopQuit(GMainLoop* loop);
	[LinkName("g_main_loop_ref")] public static extern GMainLoop* MainLoopRef(GMainLoop* loop);
	[LinkName("g_main_loop_unref")] public static extern void MainLoopUnref(GMainLoop* loop);
	[LinkName("g_main_loop_is_running")] public static extern gboolean MainLoopIsRunning(GMainLoop* loop);
	[LinkName("g_main_loop_get_context")] public static extern GMainContext* MainLoopGetContext(GMainLoop* loop);
	[LinkName("g_source_new")] public static extern GSource* SourceNew(GSourceFuncs* source_funcs, guint struct_size);
	[LinkName("g_source_set_dispose_function")] public static extern void SourceSetDisposeFunction(GSource* source, GSourceDisposeFunc dispose);
	[LinkName("g_source_ref")] public static extern GSource* SourceRef(GSource* source);
	[LinkName("g_source_unref")] public static extern void SourceUnref(GSource* source);
	[LinkName("g_source_attach")] public static extern guint SourceAttach(GSource* source, GMainContext* context);
	[LinkName("g_source_destroy")] public static extern void SourceDestroy(GSource* source);
	[LinkName("g_source_set_priority")] public static extern void SourceSetPriority(GSource* source, gint priority);
	[LinkName("g_source_get_priority")] public static extern gint SourceGetPriority(GSource* source);
	[LinkName("g_source_set_can_recurse")] public static extern void SourceSetCanRecurse(GSource* source, gboolean can_recurse);
	[LinkName("g_source_get_can_recurse")] public static extern gboolean SourceGetCanRecurse(GSource* source);
	[LinkName("g_source_get_id")] public static extern guint SourceGetId(GSource* source);
	[LinkName("g_source_get_context")] public static extern GMainContext* SourceGetContext(GSource* source);
	[LinkName("g_source_set_callback")] public static extern void SourceSetCallback(GSource* source, GSourceFunc func, gpointer data, GDestroyNotify notify);
	[LinkName("g_source_set_funcs")] public static extern void SourceSetFuncs(GSource* source, GSourceFuncs* funcs);
	[LinkName("g_source_is_destroyed")] public static extern gboolean SourceIsDestroyed(GSource* source);
	[LinkName("g_source_set_name")] public static extern void SourceSetName(GSource* source, c_char* name);
	[LinkName("g_source_set_static_name")] public static extern void SourceSetStaticName(GSource* source, c_char* name);
	[LinkName("g_source_get_name")] public static extern c_char* SourceGetName(GSource* source);
	[LinkName("g_source_set_name_by_id")] public static extern void SourceSetNameById(guint tag, c_char* name);
	[LinkName("g_source_set_ready_time")] public static extern void SourceSetReadyTime(GSource* source, gint64 ready_time);
	[LinkName("g_source_get_ready_time")] public static extern gint64 SourceGetReadyTime(GSource* source);
	[LinkName("g_source_set_callback_indirect")] public static extern void SourceSetCallbackIndirect(GSource* source, gpointer callback_data, GSourceCallbackFuncs* callback_funcs);
	[LinkName("g_source_add_poll")] public static extern void SourceAddPoll(GSource* source, GPollFD* fd);
	[LinkName("g_source_remove_poll")] public static extern void SourceRemovePoll(GSource* source, GPollFD* fd);
	[LinkName("g_source_add_child_source")] public static extern void SourceAddChildSource(GSource* source, GSource* child_source);
	[LinkName("g_source_remove_child_source")] public static extern void SourceRemoveChildSource(GSource* source, GSource* child_source);
	[LinkName("g_source_get_current_time")] public static extern void SourceGetCurrentTime(GSource* source, GTimeVal* timeval);
	[LinkName("g_source_get_time")] public static extern gint64 SourceGetTime(GSource* source);
	[LinkName("g_idle_source_new")] public static extern GSource* IdleSourceNew();
	[LinkName("g_child_watch_source_new")] public static extern GSource* ChildWatchSourceNew(GPid pid);
	[LinkName("g_timeout_source_new")] public static extern GSource* TimeoutSourceNew(guint interval);
	[LinkName("g_timeout_source_new_seconds")] public static extern GSource* TimeoutSourceNewSeconds(guint interval);
	[LinkName("g_get_current_time")] public static extern void GetCurrentTime(GTimeVal* result);
	[LinkName("g_get_monotonic_time")] public static extern gint64 GetMonotonicTime();
	[LinkName("g_get_real_time")] public static extern gint64 GetRealTime();
	[LinkName("g_source_remove")] public static extern gboolean SourceRemove(guint tag);
	[LinkName("g_source_remove_by_user_data")] public static extern gboolean SourceRemoveByUserData(gpointer user_data);
	[LinkName("g_source_remove_by_funcs_user_data")] public static extern gboolean SourceRemoveByFuncsUserData(GSourceFuncs* funcs, gpointer user_data);
}

/** GClearHandleFunc:
 *   @handle _id: the handle ID to clear
 *  
 *  Specifies the type of function passed to [func @GLib .clear_handle_id] The
 *  implementation is expected to free the resource identified by @handle _id;
 *  for instance, if @handle _id is a [struct @GLib .Source] ID,
 *  [func @GLib .Source.remove] can be used.
 *  
 *  Since: 2.56
 */
function void GClearHandleFunc(guint handle_id);

extension GLib
{
	[LinkName("g_clear_handle_id")] public static extern void ClearHandleId(guint* tag_ptr, GClearHandleFunc clear_func);
	[LinkName("g_timeout_add_full")] public static extern guint TimeoutAddFull(gint priority, guint interval, GSourceFunc @function, gpointer data, GDestroyNotify notify);
	[LinkName("g_timeout_add")] public static extern guint TimeoutAdd(guint interval, GSourceFunc @function, gpointer data);
	[LinkName("g_timeout_add_once")] public static extern guint TimeoutAddOnce(guint interval, GSourceOnceFunc @function, gpointer data);
	[LinkName("g_timeout_add_seconds_full")] public static extern guint TimeoutAddSecondsFull(gint priority, guint interval, GSourceFunc @function, gpointer data, GDestroyNotify notify);
	[LinkName("g_timeout_add_seconds")] public static extern guint TimeoutAddSeconds(guint interval, GSourceFunc @function, gpointer data);
	[LinkName("g_timeout_add_seconds_once")] public static extern guint TimeoutAddSecondsOnce(guint interval, GSourceOnceFunc @function, gpointer data);
	[LinkName("g_child_watch_add_full")] public static extern guint ChildWatchAddFull(gint priority, GPid pid, GChildWatchFunc @function, gpointer data, GDestroyNotify notify);
	[LinkName("g_child_watch_add")] public static extern guint ChildWatchAdd(GPid pid, GChildWatchFunc @function, gpointer data);
	[LinkName("g_idle_add")] public static extern guint IdleAdd(GSourceFunc @function, gpointer data);
	[LinkName("g_idle_add_full")] public static extern guint IdleAddFull(gint priority, GSourceFunc @function, gpointer data, GDestroyNotify notify);
	[LinkName("g_idle_add_once")] public static extern guint IdleAddOnce(GSourceOnceFunc @function, gpointer data);
	[LinkName("g_idle_remove_by_data")] public static extern gboolean IdleRemoveByData(gpointer data);
	[LinkName("g_main_context_invoke_full")] public static extern void MainContextInvokeFull(GMainContext* context, gint priority, GSourceFunc @function, gpointer data, GDestroyNotify notify);
	[LinkName("g_main_context_invoke")] public static extern void MainContextInvoke(GMainContext* context, GSourceFunc @function, gpointer data);
}

static
{
	[CLink] public static extern GSourceFuncs g_timeout_funcs;
	[CLink] public static extern GSourceFuncs g_child_watch_funcs;
	[CLink] public static extern GSourceFuncs g_idle_funcs;
}

/** gunichar:
 *  
 *  A type which can hold any UTF-32 or UCS-4 character code,
 *  also known as a Unicode code point.
 *  
 *  If you want to produce the UTF-8 representation of a #gunichar,
 *  use g_ucs4_to_utf8(). See also g_utf8_to_ucs4() for the reverse
 *  process.
 *  
 *  To print/scan values of this type as integer, use
 *  %G_GINT32_MODIFIER and/or %G_GUINT32_FORMAT.
 *  
 *  The notation to express a Unicode code point in running text is
 *  as a hexadecimal number with four to six digits and uppercase
 *  letters, prefixed by the string "U+". Leading zeros are omitted,
 *  unless the code point would have fewer than four hexadecimal digits.
 *  For example, "U+0041 LATIN CAPITAL LETTER A". To print a code point
 *  in the U+-notation, use the format string "U+\%04"G_GINT32_FORMAT"X".
 *  To scan, use the format string "U+\%06"G_GINT32_FORMAT"X".
 *  
 *  |[
 *  gunichar c;
 *  sscanf ("U+0041", "U+%06"G_GINT32_FORMAT"X",&c)
 *  g_print ("Read U+%04"G_GINT32_FORMAT"X", c);
 *  ]|
 */
typealias gunichar = guint32;

/** gunichar2:
 *  
 *  A type which can hold any UTF-16 code
 *  point <footnote id="utf16_surrogate_pairs">UTF-16 also has so called
 *   <firstterm >surrogate pairs </firstterm > to encode characters beyond
 *  the BMP as pairs of 16bit numbers. Surrogate pairs cannot be stored
 *  in a single gunichar2 field, but all GLib functions accepting gunichar2
 *  arrays will correctly interpret surrogate pairs.</footnote >.
 *  
 *  To print/scan values of this type to/from text you need to convert
 *  to/from UTF-8, using g_utf16_to_utf8()/g_utf8_to_utf16().
 *  
 *  To print/scan values of this type as integer, use
 *  %G_GINT16_MODIFIER and/or %G_GUINT16_FORMAT.
 */
typealias gunichar2 = guint16;

/** GUnicodeType:
 *   @G _UNICODE_CONTROL: General category "Other, Control" (Cc)
 *   @G _UNICODE_FORMAT: General category "Other, Format" (Cf)
 *   @G _UNICODE_UNASSIGNED: General category "Other, Not Assigned" (Cn)
 *   @G _UNICODE_PRIVATE_USE: General category "Other, Private Use" (Co)
 *   @G _UNICODE_SURROGATE: General category "Other, Surrogate" (Cs)
 *   @G _UNICODE_LOWERCASE_LETTER: General category "Letter, Lowercase" (Ll)
 *   @G _UNICODE_MODIFIER_LETTER: General category "Letter, Modifier" (Lm)
 *   @G _UNICODE_OTHER_LETTER: General category "Letter, Other" (Lo)
 *   @G _UNICODE_TITLECASE_LETTER: General category "Letter, Titlecase" (Lt)
 *   @G _UNICODE_UPPERCASE_LETTER: General category "Letter, Uppercase" (Lu)
 *   @G _UNICODE_SPACING_MARK: General category "Mark, Spacing" (Mc)
 *   @G _UNICODE_ENCLOSING_MARK: General category "Mark, Enclosing" (Me)
 *   @G _UNICODE_NON_SPACING_MARK: General category "Mark, Nonspacing" (Mn)
 *   @G _UNICODE_DECIMAL_NUMBER: General category "Number, Decimal Digit" (Nd)
 *   @G _UNICODE_LETTER_NUMBER: General category "Number, Letter" (Nl)
 *   @G _UNICODE_OTHER_NUMBER: General category "Number, Other" (No)
 *   @G _UNICODE_CONNECT_PUNCTUATION: General category "Punctuation, Connector" (Pc)
 *   @G _UNICODE_DASH_PUNCTUATION: General category "Punctuation, Dash" (Pd)
 *   @G _UNICODE_CLOSE_PUNCTUATION: General category "Punctuation, Close" (Pe)
 *   @G _UNICODE_FINAL_PUNCTUATION: General category "Punctuation, Final quote" (Pf)
 *   @G _UNICODE_INITIAL_PUNCTUATION: General category "Punctuation, Initial quote" (Pi)
 *   @G _UNICODE_OTHER_PUNCTUATION: General category "Punctuation, Other" (Po)
 *   @G _UNICODE_OPEN_PUNCTUATION: General category "Punctuation, Open" (Ps)
 *   @G _UNICODE_CURRENCY_SYMBOL: General category "Symbol, Currency" (Sc)
 *   @G _UNICODE_MODIFIER_SYMBOL: General category "Symbol, Modifier" (Sk)
 *   @G _UNICODE_MATH_SYMBOL: General category "Symbol, Math" (Sm)
 *   @G _UNICODE_OTHER_SYMBOL: General category "Symbol, Other" (So)
 *   @G _UNICODE_LINE_SEPARATOR: General category "Separator, Line" (Zl)
 *   @G _UNICODE_PARAGRAPH_SEPARATOR: General category "Separator, Paragraph" (Zp)
 *   @G _UNICODE_SPACE_SEPARATOR: General category "Separator, Space" (Zs)
 *  
 *  These are the possible character classifications from the
 *  Unicode specification.
 *  See [Unicode Character Database](http://www.unicode.org/reports/tr44/#General_Category_Values).
 */
[AllowDuplicates] enum GUnicodeType : c_int
{
	Control = 0,
	Format = 1,
	Unassigned = 2,
	PrivateUse = 3,
	Surrogate = 4,
	LowercaseLetter = 5,
	ModifierLetter = 6,
	OtherLetter = 7,
	ItlecaseLetter = 8,
	UppercaseLetter = 9,
	SpacingMark = 10,
	EnclosingMark = 11,
	NonSpacingMark = 12,
	DecimalNumber = 13,
	LetterNumber = 14,
	OtherNumber = 15,
	ConnectPunctuation = 16,
	DashPunctuation = 17,
	ClosePunctuation = 18,
	FinalPunctuation = 19,
	InitialPunctuation = 20,
	OtherPunctuation = 21,
	OpenPunctuation = 22,
	CurrencySymbol = 23,
	ModifierSymbol = 24,
	MathSymbol = 25,
	OtherSymbol = 26,
	LineSeparator = 27,
	ParagraphSeparator = 28,
	SpaceSeparator = 29,
}

/** GUnicodeBreakType:
 *   @G _UNICODE_BREAK_MANDATORY: Mandatory Break (BK)
 *   @G _UNICODE_BREAK_CARRIAGE_RETURN: Carriage Return (CR)
 *   @G _UNICODE_BREAK_LINE_FEED: Line Feed (LF)
 *   @G _UNICODE_BREAK_COMBINING_MARK: Attached Characters and Combining Marks (CM)
 *   @G _UNICODE_BREAK_SURROGATE: Surrogates (SG)
 *   @G _UNICODE_BREAK_ZERO_WIDTH_SPACE: Zero Width Space (ZW)
 *   @G _UNICODE_BREAK_INSEPARABLE: Inseparable (IN)
 *   @G _UNICODE_BREAK_NON_BREAKING_GLUE: Non-breaking ("Glue") (GL)
 *   @G _UNICODE_BREAK_CONTINGENT: Contingent Break Opportunity (CB)
 *   @G _UNICODE_BREAK_SPACE: Space (SP)
 *   @G _UNICODE_BREAK_AFTER: Break Opportunity After (BA)
 *   @G _UNICODE_BREAK_BEFORE: Break Opportunity Before (BB)
 *   @G _UNICODE_BREAK_BEFORE_AND_AFTER: Break Opportunity Before and After (B2)
 *   @G _UNICODE_BREAK_HYPHEN: Hyphen (HY)
 *   @G _UNICODE_BREAK_NON_STARTER: Nonstarter (NS)
 *   @G _UNICODE_BREAK_OPEN_PUNCTUATION: Opening Punctuation (OP)
 *   @G _UNICODE_BREAK_CLOSE_PUNCTUATION: Closing Punctuation (CL)
 *   @G _UNICODE_BREAK_QUOTATION: Ambiguous Quotation (QU)
 *   @G _UNICODE_BREAK_EXCLAMATION: Exclamation/Interrogation (EX)
 *   @G _UNICODE_BREAK_IDEOGRAPHIC: Ideographic (ID)
 *   @G _UNICODE_BREAK_NUMERIC: Numeric (NU)
 *   @G _UNICODE_BREAK_INFIX_SEPARATOR: Infix Separator (Numeric) (IS)
 *   @G _UNICODE_BREAK_SYMBOL: Symbols Allowing Break After (SY)
 *   @G _UNICODE_BREAK_ALPHABETIC: Ordinary Alphabetic and Symbol Characters (AL)
 *   @G _UNICODE_BREAK_PREFIX: Prefix (Numeric) (PR)
 *   @G _UNICODE_BREAK_POSTFIX: Postfix (Numeric) (PO)
 *   @G _UNICODE_BREAK_COMPLEX_CONTEXT: Complex Content Dependent (South East Asian) (SA)
 *   @G _UNICODE_BREAK_AMBIGUOUS: Ambiguous (Alphabetic or Ideographic) (AI)
 *   @G _UNICODE_BREAK_UNKNOWN: Unknown (XX)
 *   @G _UNICODE_BREAK_NEXT_LINE: Next Line (NL)
 *   @G _UNICODE_BREAK_WORD_JOINER: Word Joiner (WJ)
 *   @G _UNICODE_BREAK_HANGUL_L_JAMO: Hangul L Jamo (JL)
 *   @G _UNICODE_BREAK_HANGUL_V_JAMO: Hangul V Jamo (JV)
 *   @G _UNICODE_BREAK_HANGUL_T_JAMO: Hangul T Jamo (JT)
 *   @G _UNICODE_BREAK_HANGUL_LV_SYLLABLE: Hangul LV Syllable (H2)
 *   @G _UNICODE_BREAK_HANGUL_LVT_SYLLABLE: Hangul LVT Syllable (H3)
 *   @G _UNICODE_BREAK_CLOSE_PARANTHESIS: Closing Parenthesis (CP). Since 2.28. Deprecated: 2.70: Use %G_UNICODE_BREAK_CLOSE_PARENTHESIS instead.
 *   @G _UNICODE_BREAK_CLOSE_PARENTHESIS: Closing Parenthesis (CP). Since 2.70
 *   @G _UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: Conditional Japanese Starter (CJ). Since: 2.32
 *   @G _UNICODE_BREAK_HEBREW_LETTER: Hebrew Letter (HL). Since: 2.32
 *   @G _UNICODE_BREAK_REGIONAL_INDICATOR: Regional Indicator (RI). Since: 2.36
 *   @G _UNICODE_BREAK_EMOJI_BASE: Emoji Base (EB). Since: 2.50
 *   @G _UNICODE_BREAK_EMOJI_MODIFIER: Emoji Modifier (EM). Since: 2.50
 *   @G _UNICODE_BREAK_ZERO_WIDTH_JOINER: Zero Width Joiner (ZWJ). Since: 2.50
 *   @G _UNICODE_BREAK_AKSARA: Aksara (AK). Since: 2.80
 *   @G _UNICODE_BREAK_AKSARA_PRE_BASE: Aksara Pre-Base (AP). Since: 2.80
 *   @G _UNICODE_BREAK_AKSARA_START: Aksara Start (AS). Since: 2.80
 *   @G _UNICODE_BREAK_VIRAMA_FINAL: Virama Final (VF). Since: 2.80
 *   @G _UNICODE_BREAK_VIRAMA: Virama (VI). Since: 2.80
 *  
 *  These are the possible line break classifications.
 *  
 *  Since new Unicode versions may add new types here, applications should be ready
 *  to handle unknown values. They may be regarded as %G_UNICODE_BREAK_UNKNOWN.
 *  
 *  See [Unicode Line Breaking Algorithm](https://www.unicode.org/reports/tr14/).
 */
[AllowDuplicates] enum GUnicodeBreakType : c_int
{
	Mandatory = 0,
	CarriageReturn = 1,
	LineFeed = 2,
	CombiningMark = 3,
	Surrogate = 4,
	ZeroWidthSpace = 5,
	Inseparable = 6,
	NonBreakingGlue = 7,
	Contingent = 8,
	Space = 9,
	After = 10,
	Before = 11,
	BeforeAndAfter = 12,
	Hyphen = 13,
	NonStarter = 14,
	OpenPunctuation = 15,
	ClosePunctuation = 16,
	Quotation = 17,
	Exclamation = 18,
	Ideographic = 19,
	Numeric = 20,
	InfixSeparator = 21,
	Symbol = 22,
	Alphabetic = 23,
	Prefix = 24,
	Postfix = 25,
	ComplexContext = 26,
	Ambiguous = 27,
	Unknown = 28,
	NextLine = 29,
	WordJoiner = 30,
	HangulLJamo = 31,
	HangulVJamo = 32,
	HangulTJamo = 33,
	HangulLvSyllable = 34,
	HangulLvtSyllable = 35,
	CloseParanthesis = 36,
	CloseParenthesis = CloseParanthesis,
	ConditionalJapaneseStarter = 37,
	HebrewLetter = 38,
	RegionalIndicator = 39,
	EmojiBase = 40,
	EmojiModifier = 41,
	ZeroWidthJoiner = 42,
	Aksara = 43,
	AksaraPreBase = 44,
	AksaraStart = 45,
	ViramaFinal = 46,
	Virama = 47,
}

/** GUnicodeScript:
 *   @G _UNICODE_SCRIPT_INVALID_CODE:
 *  a value never returned from g_unichar_get_script()
 *   @G _UNICODE_SCRIPT_COMMON:     a character used by multiple different scripts
 *   @G _UNICODE_SCRIPT_INHERITED:  a mark glyph that takes its script from the
 *  base glyph to which it is attached
 *   @G _UNICODE_SCRIPT_ARABIC:     Arabic
 *   @G _UNICODE_SCRIPT_ARMENIAN:   Armenian
 *   @G _UNICODE_SCRIPT_BENGALI:    Bengali
 *   @G _UNICODE_SCRIPT_BOPOMOFO:   Bopomofo
 *   @G _UNICODE_SCRIPT_CHEROKEE:   Cherokee
 *   @G _UNICODE_SCRIPT_COPTIC:     Coptic
 *   @G _UNICODE_SCRIPT_CYRILLIC:   Cyrillic
 *   @G _UNICODE_SCRIPT_DESERET:    Deseret
 *   @G _UNICODE_SCRIPT_DEVANAGARI: Devanagari
 *   @G _UNICODE_SCRIPT_ETHIOPIC:   Ethiopic
 *   @G _UNICODE_SCRIPT_GEORGIAN:   Georgian
 *   @G _UNICODE_SCRIPT_GOTHIC:     Gothic
 *   @G _UNICODE_SCRIPT_GREEK:      Greek
 *   @G _UNICODE_SCRIPT_GUJARATI:   Gujarati
 *   @G _UNICODE_SCRIPT_GURMUKHI:   Gurmukhi
 *   @G _UNICODE_SCRIPT_HAN:        Han
 *   @G _UNICODE_SCRIPT_HANGUL:     Hangul
 *   @G _UNICODE_SCRIPT_HEBREW:     Hebrew
 *   @G _UNICODE_SCRIPT_HIRAGANA:   Hiragana
 *   @G _UNICODE_SCRIPT_KANNADA:    Kannada
 *   @G _UNICODE_SCRIPT_KATAKANA:   Katakana
 *   @G _UNICODE_SCRIPT_KHMER:      Khmer
 *   @G _UNICODE_SCRIPT_LAO:        Lao
 *   @G _UNICODE_SCRIPT_LATIN:      Latin
 *   @G _UNICODE_SCRIPT_MALAYALAM:  Malayalam
 *   @G _UNICODE_SCRIPT_MONGOLIAN:  Mongolian
 *   @G _UNICODE_SCRIPT_MYANMAR:    Myanmar
 *   @G _UNICODE_SCRIPT_OGHAM:      Ogham
 *   @G _UNICODE_SCRIPT_OLD_ITALIC: Old Italic
 *   @G _UNICODE_SCRIPT_ORIYA:      Oriya
 *   @G _UNICODE_SCRIPT_RUNIC:      Runic
 *   @G _UNICODE_SCRIPT_SINHALA:    Sinhala
 *   @G _UNICODE_SCRIPT_SYRIAC:     Syriac
 *   @G _UNICODE_SCRIPT_TAMIL:      Tamil
 *   @G _UNICODE_SCRIPT_TELUGU:     Telugu
 *   @G _UNICODE_SCRIPT_THAANA:     Thaana
 *   @G _UNICODE_SCRIPT_THAI:       Thai
 *   @G _UNICODE_SCRIPT_TIBETAN:    Tibetan
 *   @G _UNICODE_SCRIPT_CANADIAN_ABORIGINAL:
 *  Canadian Aboriginal
 *   @G _UNICODE_SCRIPT_YI:         Yi
 *   @G _UNICODE_SCRIPT_TAGALOG:    Tagalog
 *   @G _UNICODE_SCRIPT_HANUNOO:    Hanunoo
 *   @G _UNICODE_SCRIPT_BUHID:      Buhid
 *   @G _UNICODE_SCRIPT_TAGBANWA:   Tagbanwa
 *   @G _UNICODE_SCRIPT_BRAILLE:    Braille
 *   @G _UNICODE_SCRIPT_CYPRIOT:    Cypriot
 *   @G _UNICODE_SCRIPT_LIMBU:      Limbu
 *   @G _UNICODE_SCRIPT_OSMANYA:    Osmanya
 *   @G _UNICODE_SCRIPT_SHAVIAN:    Shavian
 *   @G _UNICODE_SCRIPT_LINEAR_B:   Linear B
 *   @G _UNICODE_SCRIPT_TAI_LE:     Tai Le
 *   @G _UNICODE_SCRIPT_UGARITIC:   Ugaritic
 *   @G _UNICODE_SCRIPT_NEW_TAI_LUE:
 *  New Tai Lue
 *   @G _UNICODE_SCRIPT_BUGINESE:   Buginese
 *   @G _UNICODE_SCRIPT_GLAGOLITIC: Glagolitic
 *   @G _UNICODE_SCRIPT_TIFINAGH:   Tifinagh
 *   @G _UNICODE_SCRIPT_SYLOTI_NAGRI:
 *  Syloti Nagri
 *   @G _UNICODE_SCRIPT_OLD_PERSIAN:
 *  Old Persian
 *   @G _UNICODE_SCRIPT_KHAROSHTHI: Kharoshthi
 *   @G _UNICODE_SCRIPT_UNKNOWN:    an unassigned code point
 *   @G _UNICODE_SCRIPT_BALINESE:   Balinese
 *   @G _UNICODE_SCRIPT_CUNEIFORM:  Cuneiform
 *   @G _UNICODE_SCRIPT_PHOENICIAN: Phoenician
 *   @G _UNICODE_SCRIPT_PHAGS_PA:   Phags-pa
 *   @G _UNICODE_SCRIPT_NKO:        N'Ko
 *   @G _UNICODE_SCRIPT_KAYAH_LI:   Kayah Li. Since 2.16.3
 *   @G _UNICODE_SCRIPT_LEPCHA:     Lepcha. Since 2.16.3
 *   @G _UNICODE_SCRIPT_REJANG:     Rejang. Since 2.16.3
 *   @G _UNICODE_SCRIPT_SUNDANESE:  Sundanese. Since 2.16.3
 *   @G _UNICODE_SCRIPT_SAURASHTRA: Saurashtra. Since 2.16.3
 *   @G _UNICODE_SCRIPT_CHAM:       Cham. Since 2.16.3
 *   @G _UNICODE_SCRIPT_OL_CHIKI:   Ol Chiki. Since 2.16.3
 *   @G _UNICODE_SCRIPT_VAI:        Vai. Since 2.16.3
 *   @G _UNICODE_SCRIPT_CARIAN:     Carian. Since 2.16.3
 *   @G _UNICODE_SCRIPT_LYCIAN:     Lycian. Since 2.16.3
 *   @G _UNICODE_SCRIPT_LYDIAN:     Lydian. Since 2.16.3
 *   @G _UNICODE_SCRIPT_AVESTAN:    Avestan. Since 2.26
 *   @G _UNICODE_SCRIPT_BAMUM:      Bamum. Since 2.26
 *   @G _UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS:
 *  Egyptian Hieroglpyhs. Since 2.26
 *   @G _UNICODE_SCRIPT_IMPERIAL_ARAMAIC:
 *  Imperial Aramaic. Since 2.26
 *   @G _UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI:
 *  Inscriptional Pahlavi. Since 2.26
 *   @G _UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN:
 *  Inscriptional Parthian. Since 2.26
 *   @G _UNICODE_SCRIPT_JAVANESE:   Javanese. Since 2.26
 *   @G _UNICODE_SCRIPT_KAITHI:     Kaithi. Since 2.26
 *   @G _UNICODE_SCRIPT_LISU:       Lisu. Since 2.26
 *   @G _UNICODE_SCRIPT_MEETEI_MAYEK:
 *  Meetei Mayek. Since 2.26
 *   @G _UNICODE_SCRIPT_OLD_SOUTH_ARABIAN:
 *  Old South Arabian. Since 2.26
 *   @G _UNICODE_SCRIPT_OLD_TURKIC: Old Turkic. Since 2.28
 *   @G _UNICODE_SCRIPT_SAMARITAN:  Samaritan. Since 2.26
 *   @G _UNICODE_SCRIPT_TAI_THAM:   Tai Tham. Since 2.26
 *   @G _UNICODE_SCRIPT_TAI_VIET:   Tai Viet. Since 2.26
 *   @G _UNICODE_SCRIPT_BATAK:      Batak. Since 2.28
 *   @G _UNICODE_SCRIPT_BRAHMI:     Brahmi. Since 2.28
 *   @G _UNICODE_SCRIPT_MANDAIC:    Mandaic. Since 2.28
 *   @G _UNICODE_SCRIPT_CHAKMA:               Chakma. Since: 2.32
 *   @G _UNICODE_SCRIPT_MEROITIC_CURSIVE:     Meroitic Cursive. Since: 2.32
 *   @G _UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: Meroitic Hieroglyphs. Since: 2.32
 *   @G _UNICODE_SCRIPT_MIAO:                 Miao. Since: 2.32
 *   @G _UNICODE_SCRIPT_SHARADA:              Sharada. Since: 2.32
 *   @G _UNICODE_SCRIPT_SORA_SOMPENG:         Sora Sompeng. Since: 2.32
 *   @G _UNICODE_SCRIPT_TAKRI:                Takri. Since: 2.32
 *   @G _UNICODE_SCRIPT_BASSA_VAH:            Bassa. Since: 2.42
 *   @G _UNICODE_SCRIPT_CAUCASIAN_ALBANIAN:   Caucasian Albanian. Since: 2.42
 *   @G _UNICODE_SCRIPT_DUPLOYAN:             Duployan. Since: 2.42
 *   @G _UNICODE_SCRIPT_ELBASAN:              Elbasan. Since: 2.42
 *   @G _UNICODE_SCRIPT_GRANTHA:              Grantha. Since: 2.42
 *   @G _UNICODE_SCRIPT_KHOJKI:               Kjohki. Since: 2.42
 *   @G _UNICODE_SCRIPT_KHUDAWADI:            Khudawadi, Sindhi. Since: 2.42
 *   @G _UNICODE_SCRIPT_LINEAR_A:             Linear A. Since: 2.42
 *   @G _UNICODE_SCRIPT_MAHAJANI:             Mahajani. Since: 2.42
 *   @G _UNICODE_SCRIPT_MANICHAEAN:           Manichaean. Since: 2.42
 *   @G _UNICODE_SCRIPT_MENDE_KIKAKUI:        Mende Kikakui. Since: 2.42
 *   @G _UNICODE_SCRIPT_MODI:                 Modi. Since: 2.42
 *   @G _UNICODE_SCRIPT_MRO:                  Mro. Since: 2.42
 *   @G _UNICODE_SCRIPT_NABATAEAN:            Nabataean. Since: 2.42
 *   @G _UNICODE_SCRIPT_OLD_NORTH_ARABIAN:    Old North Arabian. Since: 2.42
 *   @G _UNICODE_SCRIPT_OLD_PERMIC:           Old Permic. Since: 2.42
 *   @G _UNICODE_SCRIPT_PAHAWH_HMONG:         Pahawh Hmong. Since: 2.42
 *   @G _UNICODE_SCRIPT_PALMYRENE:            Palmyrene. Since: 2.42
 *   @G _UNICODE_SCRIPT_PAU_CIN_HAU:          Pau Cin Hau. Since: 2.42
 *   @G _UNICODE_SCRIPT_PSALTER_PAHLAVI:      Psalter Pahlavi. Since: 2.42
 *   @G _UNICODE_SCRIPT_SIDDHAM:              Siddham. Since: 2.42
 *   @G _UNICODE_SCRIPT_TIRHUTA:              Tirhuta. Since: 2.42
 *   @G _UNICODE_SCRIPT_WARANG_CITI:          Warang Citi. Since: 2.42
 *   @G _UNICODE_SCRIPT_AHOM:                 Ahom. Since: 2.48
 *   @G _UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: Anatolian Hieroglyphs. Since: 2.48
 *   @G _UNICODE_SCRIPT_HATRAN:               Hatran. Since: 2.48
 *   @G _UNICODE_SCRIPT_MULTANI:              Multani. Since: 2.48
 *   @G _UNICODE_SCRIPT_OLD_HUNGARIAN:        Old Hungarian. Since: 2.48
 *   @G _UNICODE_SCRIPT_SIGNWRITING:          Signwriting. Since: 2.48
 *   @G _UNICODE_SCRIPT_ADLAM:                Adlam. Since: 2.50
 *   @G _UNICODE_SCRIPT_BHAIKSUKI:            Bhaiksuki. Since: 2.50
 *   @G _UNICODE_SCRIPT_MARCHEN:              Marchen. Since: 2.50
 *   @G _UNICODE_SCRIPT_NEWA:                 Newa. Since: 2.50
 *   @G _UNICODE_SCRIPT_OSAGE:                Osage. Since: 2.50
 *   @G _UNICODE_SCRIPT_TANGUT:               Tangut. Since: 2.50
 *   @G _UNICODE_SCRIPT_MASARAM_GONDI:        Masaram Gondi. Since: 2.54
 *   @G _UNICODE_SCRIPT_NUSHU:                Nushu. Since: 2.54
 *   @G _UNICODE_SCRIPT_SOYOMBO:              Soyombo. Since: 2.54
 *   @G _UNICODE_SCRIPT_ZANABAZAR_SQUARE:     Zanabazar Square. Since: 2.54
 *   @G _UNICODE_SCRIPT_DOGRA:                Dogra. Since: 2.58
 *   @G _UNICODE_SCRIPT_GUNJALA_GONDI:        Gunjala Gondi. Since: 2.58
 *   @G _UNICODE_SCRIPT_HANIFI_ROHINGYA:      Hanifi Rohingya. Since: 2.58
 *   @G _UNICODE_SCRIPT_MAKASAR:              Makasar. Since: 2.58
 *   @G _UNICODE_SCRIPT_MEDEFAIDRIN:          Medefaidrin. Since: 2.58
 *   @G _UNICODE_SCRIPT_OLD_SOGDIAN:          Old Sogdian. Since: 2.58
 *   @G _UNICODE_SCRIPT_SOGDIAN:              Sogdian. Since: 2.58
 *   @G _UNICODE_SCRIPT_ELYMAIC:              Elym. Since: 2.62
 *   @G _UNICODE_SCRIPT_NANDINAGARI:          Nand. Since: 2.62
 *   @G _UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: Rohg. Since: 2.62
 *   @G _UNICODE_SCRIPT_WANCHO:               Wcho. Since: 2.62
 *   @G _UNICODE_SCRIPT_CHORASMIAN:           Chorasmian. Since: 2.66
 *   @G _UNICODE_SCRIPT_DIVES_AKURU:          Dives Akuru. Since: 2.66
 *   @G _UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT:  Khitan small script. Since: 2.66
 *   @G _UNICODE_SCRIPT_YEZIDI:               Yezidi. Since: 2.66
 *   @G _UNICODE_SCRIPT_CYPRO_MINOAN:         Cypro-Minoan. Since: 2.72
 *   @G _UNICODE_SCRIPT_OLD_UYGHUR:           Old Uyghur. Since: 2.72
 *   @G _UNICODE_SCRIPT_TANGSA:               Tangsa. Since: 2.72
 *   @G _UNICODE_SCRIPT_TOTO:                 Toto. Since: 2.72
 *   @G _UNICODE_SCRIPT_VITHKUQI:             Vithkuqi. Since: 2.72
 *   @G _UNICODE_SCRIPT_MATH:                 Mathematical notation. Since: 2.72
 *   @G _UNICODE_SCRIPT_KAWI:                 Kawi. Since 2.74
 *   @G _UNICODE_SCRIPT_NAG_MUNDARI:          Nag Mundari. Since 2.74
 *   @G _UNICODE_SCRIPT_TODHRI:               Todhri. Since: 2.84
 *   @G _UNICODE_SCRIPT_GARAY:                Garay. Since: 2.84
 *   @G _UNICODE_SCRIPT_TULU_TIGALARI:        Tulu-Tigalari. Since: 2.84
 *   @G _UNICODE_SCRIPT_SUNUWAR:              Sunuwar. Since: 2.84
 *   @G _UNICODE_SCRIPT_GURUNG_KHEMA:         Gurung Khema. Since: 2.84
 *   @G _UNICODE_SCRIPT_KIRAT_RAI:            Kirat Rai. Since: 2.84
 *   @G _UNICODE_SCRIPT_OL_ONAL:              Ol Onal. Since: 2.84
 *  
 *  The #GUnicodeScript enumeration identifies different writing
 *  systems. The values correspond to the names as defined in the
 *  Unicode standard. The enumeration has been added in GLib 2.14,
 *  and is interchangeable with #PangoScript.
 *  
 *  Note that new types may be added in the future. Applications
 *  should be ready to handle unknown values.
 *  See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/).
 */
[AllowDuplicates] enum GUnicodeScript : c_int
{
	InvalidCode =  - 1,
	Common = 0,
	Inherited = 1,
	Arabic = 2,
	Armenian = 3,
	Bengali = 4,
	Bopomofo = 5,
	Cherokee = 6,
	Coptic = 7,
	Cyrillic = 8,
	Deseret = 9,
	Devanagari = 10,
	Ethiopic = 11,
	Georgian = 12,
	Gothic = 13,
	Greek = 14,
	Gujarati = 15,
	Gurmukhi = 16,
	Han = 17,
	Hangul = 18,
	Hebrew = 19,
	Hiragana = 20,
	Kannada = 21,
	Katakana = 22,
	Khmer = 23,
	Lao = 24,
	Latin = 25,
	Malayalam = 26,
	Mongolian = 27,
	Myanmar = 28,
	Ogham = 29,
	OldItalic = 30,
	Oriya = 31,
	Runic = 32,
	Sinhala = 33,
	Syriac = 34,
	Tamil = 35,
	Telugu = 36,
	Thaana = 37,
	Thai = 38,
	Tibetan = 39,
	CanadianAboriginal = 40,
	Yi = 41,
	Tagalog = 42,
	Hanunoo = 43,
	Buhid = 44,
	Tagbanwa = 45,
	Braille = 46,
	Cypriot = 47,
	Limbu = 48,
	Osmanya = 49,
	Shavian = 50,
	LinearB = 51,
	TaiLe = 52,
	Ugaritic = 53,
	NewTaiLue = 54,
	Buginese = 55,
	Glagolitic = 56,
	Tifinagh = 57,
	SylotiNagri = 58,
	OldPersian = 59,
	Kharoshthi = 60,
	Unknown = 61,
	Balinese = 62,
	Cuneiform = 63,
	Phoenician = 64,
	PhagsPa = 65,
	Nko = 66,
	KayahLi = 67,
	Lepcha = 68,
	Rejang = 69,
	Sundanese = 70,
	Saurashtra = 71,
	Cham = 72,
	OlChiki = 73,
	Vai = 74,
	Carian = 75,
	Lycian = 76,
	Lydian = 77,
	Avestan = 78,
	Bamum = 79,
	EgyptianHieroglyphs = 80,
	ImperialAramaic = 81,
	InscriptionalPahlavi = 82,
	InscriptionalParthian = 83,
	Javanese = 84,
	Kaithi = 85,
	Lisu = 86,
	MeeteiMayek = 87,
	OldSouthArabian = 88,
	OldTurkic = 89,
	Samaritan = 90,
	TaiTham = 91,
	TaiViet = 92,
	Batak = 93,
	Brahmi = 94,
	Mandaic = 95,
	Chakma = 96,
	MeroiticCursive = 97,
	MeroiticHieroglyphs = 98,
	Miao = 99,
	Sharada = 100,
	SoraSompeng = 101,
	Takri = 102,
	BassaVah = 103,
	CaucasianAlbanian = 104,
	Duployan = 105,
	Elbasan = 106,
	Grantha = 107,
	Khojki = 108,
	Khudawadi = 109,
	LinearA = 110,
	Mahajani = 111,
	Manichaean = 112,
	MendeKikakui = 113,
	Modi = 114,
	Mro = 115,
	Nabataean = 116,
	OldNorthArabian = 117,
	OldPermic = 118,
	PahawhHmong = 119,
	Palmyrene = 120,
	PauCinHau = 121,
	PsalterPahlavi = 122,
	Siddham = 123,
	Tirhuta = 124,
	WarangCiti = 125,
	Ahom = 126,
	AnatolianHieroglyphs = 127,
	Hatran = 128,
	Multani = 129,
	OldHungarian = 130,
	Signwriting = 131,
	Adlam = 132,
	Bhaiksuki = 133,
	Marchen = 134,
	Newa = 135,
	Osage = 136,
	Tangut = 137,
	MasaramGondi = 138,
	Nushu = 139,
	Soyombo = 140,
	ZanabazarSquare = 141,
	Dogra = 142,
	GunjalaGondi = 143,
	HanifiRohingya = 144,
	Makasar = 145,
	Medefaidrin = 146,
	OldSogdian = 147,
	Sogdian = 148,
	Elymaic = 149,
	Nandinagari = 150,
	NyiakengPuachueHmong = 151,
	Wancho = 152,
	Chorasmian = 153,
	DivesAkuru = 154,
	KhitanSmallScript = 155,
	Yezidi = 156,
	CyproMinoan = 157,
	OldUyghur = 158,
	Tangsa = 159,
	Toto = 160,
	Vithkuqi = 161,
	Math = 162,
	Kawi = 163,
	NagMundari = 164,
	Todhri = 165,
	Garay = 166,
	TuluTigalari = 167,
	Sunuwar = 168,
	GurungKhema = 169,
	KiratRai = 170,
	OlOnal = 171,
}

extension GLib
{
	[LinkName("g_unicode_script_to_iso15924")] public static extern guint32 UnicodeScriptToIso15924(GUnicodeScript script);
	[LinkName("g_unicode_script_from_iso15924")] public static extern GUnicodeScript UnicodeScriptFromIso15924(guint32 iso15924);
	[LinkName("g_unichar_isalnum")] public static extern gboolean UnicharIsalnum(gunichar c);
	[LinkName("g_unichar_isalpha")] public static extern gboolean UnicharIsalpha(gunichar c);
	[LinkName("g_unichar_iscntrl")] public static extern gboolean UnicharIscntrl(gunichar c);
	[LinkName("g_unichar_isdigit")] public static extern gboolean UnicharIsdigit(gunichar c);
	[LinkName("g_unichar_isgraph")] public static extern gboolean UnicharIsgraph(gunichar c);
	[LinkName("g_unichar_islower")] public static extern gboolean UnicharIslower(gunichar c);
	[LinkName("g_unichar_isprint")] public static extern gboolean UnicharIsprint(gunichar c);
	[LinkName("g_unichar_ispunct")] public static extern gboolean UnicharIspunct(gunichar c);
	[LinkName("g_unichar_isspace")] public static extern gboolean UnicharIsspace(gunichar c);
	[LinkName("g_unichar_isupper")] public static extern gboolean UnicharIsupper(gunichar c);
	[LinkName("g_unichar_isxdigit")] public static extern gboolean UnicharIsxdigit(gunichar c);
	[LinkName("g_unichar_istitle")] public static extern gboolean UnicharIstitle(gunichar c);
	[LinkName("g_unichar_isdefined")] public static extern gboolean UnicharIsdefined(gunichar c);
	[LinkName("g_unichar_iswide")] public static extern gboolean UnicharIswide(gunichar c);
	[LinkName("g_unichar_iswide_cjk")] public static extern gboolean UnicharIswideCjk(gunichar c);
	[LinkName("g_unichar_iszerowidth")] public static extern gboolean UnicharIszerowidth(gunichar c);
	[LinkName("g_unichar_ismark")] public static extern gboolean UnicharIsmark(gunichar c);
	[LinkName("g_unichar_toupper")] public static extern gunichar UnicharToupper(gunichar c);
	[LinkName("g_unichar_tolower")] public static extern gunichar UnicharTolower(gunichar c);
	[LinkName("g_unichar_totitle")] public static extern gunichar UnicharTotitle(gunichar c);
	[LinkName("g_unichar_digit_value")] public static extern gint UnicharDigitValue(gunichar c);
	[LinkName("g_unichar_xdigit_value")] public static extern gint UnicharXdigitValue(gunichar c);
	[LinkName("g_unichar_type")] public static extern GUnicodeType UnicharType(gunichar c);
	[LinkName("g_unichar_break_type")] public static extern GUnicodeBreakType UnicharBreakType(gunichar c);
	[LinkName("g_unichar_combining_class")] public static extern gint UnicharCombiningClass(gunichar uc);
	[LinkName("g_unichar_get_mirror_char")] public static extern gboolean UnicharGetMirrorChar(gunichar ch, gunichar* mirrored_ch);
	[LinkName("g_unichar_get_script")] public static extern GUnicodeScript UnicharGetScript(gunichar ch);
	[LinkName("g_unichar_validate")] public static extern gboolean UnicharValidate(gunichar ch);
	[LinkName("g_unichar_compose")] public static extern gboolean UnicharCompose(gunichar a, gunichar b, gunichar* ch);
	[LinkName("g_unichar_decompose")] public static extern gboolean UnicharDecompose(gunichar ch, gunichar* a, gunichar* b);
	[LinkName("g_unichar_fully_decompose")] public static extern gsize UnicharFullyDecompose(gunichar ch, gboolean compat, gunichar* result, gsize result_len);
	[LinkName("g_unicode_canonical_ordering")] public static extern void UnicodeCanonicalOrdering(gunichar* string, gsize len);
	[LinkName("g_unicode_canonical_decomposition")] public static extern gunichar* UnicodeCanonicalDecomposition(gunichar ch, gsize* result_len);
}

static
{
	[CLink] public static extern gchar* g_utf8_skip;
}

extension GLib
{
	[LinkName("g_utf8_get_char")] public static extern gunichar Utf8GetChar(gchar* p);
	[LinkName("g_utf8_get_char_validated")] public static extern gunichar Utf8GetCharValidated(gchar* p, gssize max_len);
	[LinkName("g_utf8_offset_to_pointer")] public static extern gchar* Utf8OffsetToPointer(gchar* str, glong offset);
	[LinkName("g_utf8_pointer_to_offset")] public static extern glong Utf8PointerToOffset(gchar* str, gchar* pos);
	[LinkName("g_utf8_prev_char")] public static extern gchar* Utf8PrevChar(gchar* p);
	[LinkName("g_utf8_find_next_char")] public static extern gchar* Utf8FindNextChar(gchar* p, gchar* end);
	[LinkName("g_utf8_find_prev_char")] public static extern gchar* Utf8FindPrevChar(gchar* str, gchar* p);
	[LinkName("g_utf8_strlen")] public static extern glong Utf8Strlen(gchar* p, gssize max);
	[LinkName("g_utf8_substring")] public static extern gchar* Utf8Substring(gchar* str, glong start_pos, glong end_pos);
	[LinkName("g_utf8_strncpy")] public static extern gchar* Utf8Strncpy(gchar* dest, gchar* src, gsize n);
	[LinkName("g_utf8_truncate_middle")] public static extern gchar* Utf8TruncateMiddle(gchar* string, gsize truncate_length);
	[LinkName("g_utf8_strchr")] public static extern gchar* Utf8Strchr(gchar* p, gssize len, gunichar c);
	[LinkName("g_utf8_strrchr")] public static extern gchar* Utf8Strrchr(gchar* p, gssize len, gunichar c);
	[LinkName("g_utf8_strreverse")] public static extern gchar* Utf8Strreverse(gchar* str, gssize len);
	[LinkName("g_utf8_to_utf16")] public static extern gunichar2* Utf8ToUtf16(gchar* str, glong len, glong* items_read, glong* items_written, GError** error);
	[LinkName("g_utf8_to_ucs4")] public static extern gunichar* Utf8ToUcs4(gchar* str, glong len, glong* items_read, glong* items_written, GError** error);
	[LinkName("g_utf8_to_ucs4_fast")] public static extern gunichar* Utf8ToUcs4Fast(gchar* str, glong len, glong* items_written);
	[LinkName("g_utf16_to_ucs4")] public static extern gunichar* Utf16ToUcs4(gunichar2* str, glong len, glong* items_read, glong* items_written, GError** error);
	[LinkName("g_utf16_to_utf8")] public static extern gchar* Utf16ToUtf8(gunichar2* str, glong len, glong* items_read, glong* items_written, GError** error);
	[LinkName("g_ucs4_to_utf16")] public static extern gunichar2* Ucs4ToUtf16(gunichar* str, glong len, glong* items_read, glong* items_written, GError** error);
	[LinkName("g_ucs4_to_utf8")] public static extern gchar* Ucs4ToUtf8(gunichar* str, glong len, glong* items_read, glong* items_written, GError** error);
	[LinkName("g_unichar_to_utf8")] public static extern gint UnicharToUtf8(gunichar c, gchar* outbuf);
	[LinkName("g_utf8_validate")] public static extern gboolean Utf8Validate(gchar* str, gssize max_len, gchar** end);
	[LinkName("g_utf8_validate_len")] public static extern gboolean Utf8ValidateLen(gchar* str, gsize max_len, gchar** end);
	[LinkName("g_utf8_strup")] public static extern gchar* Utf8Strup(gchar* str, gssize len);
	[LinkName("g_utf8_strdown")] public static extern gchar* Utf8Strdown(gchar* str, gssize len);
	[LinkName("g_utf8_casefold")] public static extern gchar* Utf8Casefold(gchar* str, gssize len);
}

/** GNormalizeMode:
 *   @G _NORMALIZE_DEFAULT: standardize differences that do not affect the
 *  text content, such as the above-mentioned accent representation
 *   @G _NORMALIZE_NFD: another name for %G_NORMALIZE_DEFAULT
 *   @G _NORMALIZE_DEFAULT_COMPOSE: like %G_NORMALIZE_DEFAULT, but with
 *  composed forms rather than a maximally decomposed form
 *   @G _NORMALIZE_NFC: another name for %G_NORMALIZE_DEFAULT_COMPOSE
 *   @G _NORMALIZE_ALL: beyond %G_NORMALIZE_DEFAULT also standardize the
 *  "compatibility" characters in Unicode, such as SUPERSCRIPT THREE
 *  to the standard forms (in this case DIGIT THREE). Formatting
 *  information may be lost but for most text operations such
 *  characters should be considered the same
 *   @G _NORMALIZE_NFKD: another name for %G_NORMALIZE_ALL
 *   @G _NORMALIZE_ALL_COMPOSE: like %G_NORMALIZE_ALL, but with composed
 *  forms rather than a maximally decomposed form
 *   @G _NORMALIZE_NFKC: another name for %G_NORMALIZE_ALL_COMPOSE
 *  
 *  Defines how a Unicode string is transformed in a canonical
 *  form, standardizing such issues as whether a character with
 *  an accent is represented as a base character and combining
 *  accent or as a single precomposed character. Unicode strings
 *  should generally be normalized before comparing them.
 */
[AllowDuplicates] enum GNormalizeMode : c_int
{
	Default = 0,
	Nfd = Default,
	DefaultCompose = 1,
	Nfc = DefaultCompose,
	All = 2,
	Nfkd = All,
	AllCompose = 3,
	Nfkc = AllCompose,
}

extension GLib
{
	[LinkName("g_utf8_normalize")] public static extern gchar* Utf8Normalize(gchar* str, gssize len, GNormalizeMode mode);
	[LinkName("g_utf8_collate")] public static extern gint Utf8Collate(gchar* str1, gchar* str2);
	[LinkName("g_utf8_collate_key")] public static extern gchar* Utf8CollateKey(gchar* str, gssize len);
	[LinkName("g_utf8_collate_key_for_filename")] public static extern gchar* Utf8CollateKeyForFilename(gchar* str, gssize len);
	[LinkName("g_utf8_make_valid")] public static extern gchar* Utf8MakeValid(gchar* str, gssize len);
}

[AllowDuplicates] enum GAsciiType : c_int
{
	Alnum = 1 << 0,
	Alpha = 1 << 1,
	Cntrl = 1 << 2,
	Digit = 1 << 3,
	Graph = 1 << 4,
	Lower = 1 << 5,
	Print = 1 << 6,
	Punct = 1 << 7,
	Space = 1 << 8,
	Upper = 1 << 9,
	Xdigit = 1 << 10,
}

static
{
	[CLink] public static extern guint16* g_ascii_table;
}

extension GLib
{
	[LinkName("g_ascii_tolower")] public static extern gchar AsciiTolower(gchar c);
	[LinkName("g_ascii_toupper")] public static extern gchar AsciiToupper(gchar c);
	[LinkName("g_ascii_digit_value")] public static extern gint AsciiDigitValue(gchar c);
	[LinkName("g_ascii_xdigit_value")] public static extern gint AsciiXdigitValue(gchar c);
	[LinkName("g_strdelimit")] public static extern gchar* Strdelimit(gchar* string, gchar* delimiters, gchar new_delimiter);
	[LinkName("g_strcanon")] public static extern gchar* Strcanon(gchar* string, gchar* valid_chars, gchar substitutor);
	[LinkName("g_strerror")] public static extern gchar* Strerror(gint errnum);
	[LinkName("g_strsignal")] public static extern gchar* Strsignal(gint signum);
	[LinkName("g_strreverse")] public static extern gchar* Strreverse(gchar* string);
	[LinkName("g_strlcpy")] public static extern gsize Strlcpy(gchar* dest, gchar* src, gsize dest_size);
	[LinkName("g_strlcat")] public static extern gsize Strlcat(gchar* dest, gchar* src, gsize dest_size);
	[LinkName("g_strstr_len")] public static extern gchar* StrstrLen(gchar* haystack, gssize haystack_len, gchar* needle);
	[LinkName("g_strrstr")] public static extern gchar* Strrstr(gchar* haystack, gchar* needle);
	[LinkName("g_strrstr_len")] public static extern gchar* StrrstrLen(gchar* haystack, gssize haystack_len, gchar* needle);
	[LinkName("g_str_has_suffix")] public static extern gboolean StrHasSuffix(gchar* str, gchar* suffix);
	[LinkName("g_str_has_prefix")] public static extern gboolean StrHasPrefix(gchar* str, gchar* prefix);
	[LinkName("g_strtod")] public static extern gdouble Strtod(gchar* nptr, gchar** endptr);
	[LinkName("g_ascii_strtod")] public static extern gdouble AsciiStrtod(gchar* nptr, gchar** endptr);
	[LinkName("g_ascii_strtoull")] public static extern guint64 AsciiStrtoull(gchar* nptr, gchar** endptr, guint @base);
	[LinkName("g_ascii_strtoll")] public static extern gint64 AsciiStrtoll(gchar* nptr, gchar** endptr, guint @base);
	[LinkName("g_ascii_dtostr")] public static extern gchar* AsciiDtostr(gchar* buffer, gint buf_len, gdouble d);
	[LinkName("g_ascii_formatd")] public static extern gchar* AsciiFormatd(gchar* buffer, gint buf_len, gchar* format, gdouble d);
	[LinkName("g_strchug")] public static extern gchar* Strchug(gchar* string);
	[LinkName("g_strchomp")] public static extern gchar* Strchomp(gchar* string);
	[LinkName("g_ascii_strcasecmp")] public static extern gint AsciiStrcasecmp(gchar* s1, gchar* s2);
	[LinkName("g_ascii_strncasecmp")] public static extern gint AsciiStrncasecmp(gchar* s1, gchar* s2, gsize n);
	[LinkName("g_ascii_strdown")] public static extern gchar* AsciiStrdown(gchar* str, gssize len);
	[LinkName("g_ascii_strup")] public static extern gchar* AsciiStrup(gchar* str, gssize len);
	[LinkName("g_str_is_ascii")] public static extern gboolean StrIsAscii(gchar* str);
	[LinkName("g_strcasecmp")] public static extern gint Strcasecmp(gchar* s1, gchar* s2);
	[LinkName("g_strncasecmp")] public static extern gint Strncasecmp(gchar* s1, gchar* s2, guint n);
	[LinkName("g_strdown")] public static extern gchar* Strdown(gchar* string);
	[LinkName("g_strup")] public static extern gchar* Strup(gchar* string);
	[LinkName("g_strdup")] public static extern gchar* Strdup(gchar* str);
	[LinkName("g_strdup_printf")] public static extern gchar* StrdupPrintf(gchar* format, ...);
	[LinkName("g_strdup_vprintf")] public static extern gchar* StrdupVprintf(gchar* format, VarArgs args);
	[LinkName("g_strndup")] public static extern gchar* Strndup(gchar* str, gsize n);
	[LinkName("g_strnfill")] public static extern gchar* Strnfill(gsize length, gchar fill_char);
	[LinkName("g_strconcat")] public static extern gchar* Strconcat(gchar* string1, ...);
	[LinkName("g_strjoin")] public static extern gchar* Strjoin(gchar* separator, ...);
	[LinkName("g_strcompress")] public static extern gchar* Strcompress(gchar* source);
	[LinkName("g_strescape")] public static extern gchar* Strescape(gchar* source, gchar* exceptions);
	[LinkName("g_memdup")] public static extern gpointer Memdup(gconstpointer mem, guint byte_size);
	[LinkName("g_memdup2")] public static extern gpointer Memdup2(gconstpointer mem, gsize byte_size);
}

typealias GStrv = gchar**;

extension GLib
{
	[LinkName("g_strsplit")] public static extern gchar** Strsplit(gchar* string, gchar* delimiter, gint max_tokens);
	[LinkName("g_strsplit_set")] public static extern gchar** StrsplitSet(gchar* string, gchar* delimiters, gint max_tokens);
	[LinkName("g_strjoinv")] public static extern gchar* Strjoinv(gchar* separator, gchar** str_array);
	[LinkName("g_strfreev")] public static extern void Strfreev(gchar** str_array);
	[LinkName("g_strdupv")] public static extern gchar** Strdupv(gchar** str_array);
	[LinkName("g_strv_length")] public static extern guint StrvLength(gchar** str_array);
	[LinkName("g_stpcpy")] public static extern gchar* Stpcpy(gchar* dest, c_char* src);
	[LinkName("g_str_to_ascii")] public static extern gchar* StrToAscii(gchar* str, gchar* from_locale);
	[LinkName("g_str_tokenize_and_fold")] public static extern gchar** StrTokenizeAndFold(gchar* string, gchar* translit_locale, gchar*** ascii_alternates);
	[LinkName("g_str_match_string")] public static extern gboolean StrMatchString(gchar* search_term, gchar* potential_hit, gboolean accept_alternates);
	[LinkName("g_strv_contains")] public static extern gboolean StrvContains(gchar** strv, gchar* str);
	[LinkName("g_strv_equal")] public static extern gboolean StrvEqual(gchar** strv1, gchar** strv2);
}

/** GNumberParserError:
 *   @G _NUMBER_PARSER_ERROR_INVALID: string was not a valid number
 *   @G _NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: string was a number, but out of bounds
 *  
 *  Error codes returned by functions converting a string to a number.
 *  
 *  Since: 2.54
 */
[AllowDuplicates] enum GNumberParserError : c_int
{
	Invalid = 0,
	OutOfBounds = 1,
}

extension GLib
{
	[LinkName("g_number_parser_error_quark")] public static extern GQuark NumberParserErrorQuark();
	[LinkName("g_ascii_string_to_signed")] public static extern gboolean AsciiStringToSigned(gchar* str, guint @base, gint64 min, gint64 max, gint64* out_num, GError** error);
	[LinkName("g_ascii_string_to_unsigned")] public static extern gboolean AsciiStringToUnsigned(gchar* str, guint @base, guint64 min, guint64 max, guint64* out_num, GError** error);
}


[CRepr] struct GString
{
	public gchar* str;
	public gsize len;
	public gsize allocated_len;
}

extension GLib
{
	[LinkName("g_string_new")] public static extern GString* StringNew(gchar* init);
	[LinkName("g_string_new_take")] public static extern GString* StringNewTake(gchar* init);
	[LinkName("g_string_new_len")] public static extern GString* StringNewLen(gchar* init, gssize len);
	[LinkName("g_string_sized_new")] public static extern GString* StringSizedNew(gsize dfl_size);
	[LinkName("g_string_free")] public static extern gchar* StringFree(GString* string, gboolean free_segment);
	[LinkName("g_string_free_and_steal")] public static extern gchar* StringFreeAndSteal(GString* string);
	[LinkName("g_string_free_to_bytes")] public static extern GBytes* StringFreeToBytes(GString* string);
	[LinkName("g_string_equal")] public static extern gboolean StringEqual(GString* v, GString* v2);
	[LinkName("g_string_hash")] public static extern guint StringHash(GString* str);
	[LinkName("g_string_assign")] public static extern GString* StringAssign(GString* string, gchar* rval);
	[LinkName("g_string_truncate")] public static extern GString* StringTruncate(GString* string, gsize len);
	[LinkName("g_string_set_size")] public static extern GString* StringSetSize(GString* string, gsize len);
	[LinkName("g_string_insert_len")] public static extern GString* StringInsertLen(GString* string, gssize pos, gchar* val, gssize len);
	[LinkName("g_string_append")] public static extern GString* StringAppend(GString* string, gchar* val);
	[LinkName("g_string_append_len")] public static extern GString* StringAppendLen(GString* string, gchar* val, gssize len);
	[LinkName("g_string_append_c")] public static extern GString* StringAppendC(GString* string, gchar c);
	[LinkName("g_string_append_unichar")] public static extern GString* StringAppendUnichar(GString* string, gunichar wc);
	[LinkName("g_string_prepend")] public static extern GString* StringPrepend(GString* string, gchar* val);
	[LinkName("g_string_prepend_c")] public static extern GString* StringPrependC(GString* string, gchar c);
	[LinkName("g_string_prepend_unichar")] public static extern GString* StringPrependUnichar(GString* string, gunichar wc);
	[LinkName("g_string_prepend_len")] public static extern GString* StringPrependLen(GString* string, gchar* val, gssize len);
	[LinkName("g_string_insert")] public static extern GString* StringInsert(GString* string, gssize pos, gchar* val);
	[LinkName("g_string_insert_c")] public static extern GString* StringInsertC(GString* string, gssize pos, gchar c);
	[LinkName("g_string_insert_unichar")] public static extern GString* StringInsertUnichar(GString* string, gssize pos, gunichar wc);
	[LinkName("g_string_overwrite")] public static extern GString* StringOverwrite(GString* string, gsize pos, gchar* val);
	[LinkName("g_string_overwrite_len")] public static extern GString* StringOverwriteLen(GString* string, gsize pos, gchar* val, gssize len);
	[LinkName("g_string_erase")] public static extern GString* StringErase(GString* string, gssize pos, gssize len);
	[LinkName("g_string_replace")] public static extern guint StringReplace(GString* string, gchar* find, gchar* replace, guint limit);
	[LinkName("g_string_ascii_down")] public static extern GString* StringAsciiDown(GString* string);
	[LinkName("g_string_ascii_up")] public static extern GString* StringAsciiUp(GString* string);
	[LinkName("g_string_vprintf")] public static extern void StringVprintf(GString* string, gchar* format, VarArgs args);
	[LinkName("g_string_printf")] public static extern void StringPrintf(GString* string, gchar* format, ...);
	[LinkName("g_string_append_vprintf")] public static extern void StringAppendVprintf(GString* string, gchar* format, VarArgs args);
	[LinkName("g_string_append_printf")] public static extern void StringAppendPrintf(GString* string, gchar* format, ...);
	[LinkName("g_string_append_uri_escaped")] public static extern GString* StringAppendUriEscaped(GString* string, gchar* unescaped, gchar* reserved_chars_allowed, gboolean allow_utf8);
	[LinkName("g_string_down")] public static extern GString* StringDown(GString* string);
	[LinkName("g_string_up")] public static extern GString* StringUp(GString* string);
}



[AllowDuplicates] enum GIOError : c_int
{
	None = 0,
	Again = 1,
	Inval = 2,
	Unknown = 3,
}

[AllowDuplicates] enum GIOChannelError : c_int
{
	Fbig = 0,
	Inval = 1,
	Io = 2,
	Isdir = 3,
	Nospc = 4,
	Nxio = 5,
	Overflow = 6,
	Pipe = 7,
	Failed = 8,
}

[AllowDuplicates] enum GIOStatus : c_int
{
	Error = 0,
	Normal = 1,
	Eof = 2,
	Again = 3,
}

[AllowDuplicates] enum GSeekType : c_int
{
	Cur = 0,
	Set = 1,
	End = 2,
}

[AllowDuplicates] enum GIOFlags : c_int
{
	None = 0,
	Append = 1 << 0,
	Nonblock = 1 << 1,
	IsReadable = 1 << 2,
	IsWritable = 1 << 3,
	IsWriteable = 1 << 3,
	IsSeekable = 1 << 4,
	Mask = (1 << 5) - 1,
	GetMask = Mask,
	EtMask = Append | Nonblock,
}

[CRepr] struct GIOChannel
{
	public gint ref_count;
	public GIOFuncs* funcs;
	public gchar* encoding;
	public GIConv read_cd;
	public GIConv write_cd;
	public gchar* line_term;
	public guint line_term_len;
	public gsize buf_size;
	public GString* read_buf;
	public GString* encoded_read_buf;
	public GString* write_buf;
	public gchar[6] partial_write_buf;
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 0), "use_buffer")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 1), "do_encode")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 2), "close_on_unref")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 3), "is_readable")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 4), "is_writeable")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 5), "is_seekable")]
	private uint32 __bitfield_1365518;
	public gpointer reserved1;
	public gpointer reserved2;
}

function gboolean GIOFunc(GIOChannel* source, GIOCondition condition, gpointer data);

[CRepr] struct GIOFuncs
{
	public function GIOStatus(GIOChannel*, gchar*, gsize, gsize*, GError**) io_read;
	public function GIOStatus(GIOChannel*, gchar*, gsize, gsize*, GError**) io_write;
	public function GIOStatus(GIOChannel*, gint64, GSeekType, GError**) io_seek;
	public function GIOStatus(GIOChannel*, GError**) io_close;
	public function GSource*(GIOChannel*, GIOCondition) io_create_watch;
	public function void(GIOChannel*) io_free;
	public function GIOStatus(GIOChannel*, GIOFlags, GError**) io_set_flags;
	public function GIOFlags(GIOChannel*) io_get_flags;
}

extension GLib
{
	[LinkName("g_io_channel_init")] public static extern void IoChannelInit(GIOChannel* channel);
	[LinkName("g_io_channel_ref")] public static extern GIOChannel* IoChannelRef(GIOChannel* channel);
	[LinkName("g_io_channel_unref")] public static extern void IoChannelUnref(GIOChannel* channel);
	[LinkName("g_io_channel_read")] public static extern GIOError IoChannelRead(GIOChannel* channel, gchar* buf, gsize count, gsize* bytes_read);
	[LinkName("g_io_channel_write")] public static extern GIOError IoChannelWrite(GIOChannel* channel, gchar* buf, gsize count, gsize* bytes_written);
	[LinkName("g_io_channel_seek")] public static extern GIOError IoChannelSeek(GIOChannel* channel, gint64 offset, GSeekType type);
	[LinkName("g_io_channel_close")] public static extern void IoChannelClose(GIOChannel* channel);
	[LinkName("g_io_channel_shutdown")] public static extern GIOStatus IoChannelShutdown(GIOChannel* channel, gboolean flush, GError** err);
	[LinkName("g_io_add_watch_full")] public static extern guint IoAddWatchFull(GIOChannel* channel, gint priority, GIOCondition condition, GIOFunc func, gpointer user_data, GDestroyNotify notify);
	[LinkName("g_io_create_watch")] public static extern GSource* IoCreateWatch(GIOChannel* channel, GIOCondition condition);
	[LinkName("g_io_add_watch")] public static extern guint IoAddWatch(GIOChannel* channel, GIOCondition condition, GIOFunc func, gpointer user_data);
	[LinkName("g_io_channel_set_buffer_size")] public static extern void IoChannelSetBufferSize(GIOChannel* channel, gsize size);
	[LinkName("g_io_channel_get_buffer_size")] public static extern gsize IoChannelGetBufferSize(GIOChannel* channel);
	[LinkName("g_io_channel_get_buffer_condition")] public static extern GIOCondition IoChannelGetBufferCondition(GIOChannel* channel);
	[LinkName("g_io_channel_set_flags")] public static extern GIOStatus IoChannelSetFlags(GIOChannel* channel, GIOFlags flags, GError** error);
	[LinkName("g_io_channel_get_flags")] public static extern GIOFlags IoChannelGetFlags(GIOChannel* channel);
	[LinkName("g_io_channel_set_line_term")] public static extern void IoChannelSetLineTerm(GIOChannel* channel, gchar* line_term, gint length);
	[LinkName("g_io_channel_get_line_term")] public static extern gchar* IoChannelGetLineTerm(GIOChannel* channel, gint* length);
	[LinkName("g_io_channel_set_buffered")] public static extern void IoChannelSetBuffered(GIOChannel* channel, gboolean buffered);
	[LinkName("g_io_channel_get_buffered")] public static extern gboolean IoChannelGetBuffered(GIOChannel* channel);
	[LinkName("g_io_channel_set_encoding")] public static extern GIOStatus IoChannelSetEncoding(GIOChannel* channel, gchar* encoding, GError** error);
	[LinkName("g_io_channel_get_encoding")] public static extern gchar* IoChannelGetEncoding(GIOChannel* channel);
	[LinkName("g_io_channel_set_close_on_unref")] public static extern void IoChannelSetCloseOnUnref(GIOChannel* channel, gboolean do_close);
	[LinkName("g_io_channel_get_close_on_unref")] public static extern gboolean IoChannelGetCloseOnUnref(GIOChannel* channel);
	[LinkName("g_io_channel_flush")] public static extern GIOStatus IoChannelFlush(GIOChannel* channel, GError** error);
	[LinkName("g_io_channel_read_line")] public static extern GIOStatus IoChannelReadLine(GIOChannel* channel, gchar** str_return, gsize* length, gsize* terminator_pos, GError** error);
	[LinkName("g_io_channel_read_line_string")] public static extern GIOStatus IoChannelReadLineString(GIOChannel* channel, GString* buffer, gsize* terminator_pos, GError** error);
	[LinkName("g_io_channel_read_to_end")] public static extern GIOStatus IoChannelReadToEnd(GIOChannel* channel, gchar** str_return, gsize* length, GError** error);
	[LinkName("g_io_channel_read_chars")] public static extern GIOStatus IoChannelReadChars(GIOChannel* channel, gchar* buf, gsize count, gsize* bytes_read, GError** error);
	[LinkName("g_io_channel_read_unichar")] public static extern GIOStatus IoChannelReadUnichar(GIOChannel* channel, gunichar* thechar, GError** error);
	[LinkName("g_io_channel_write_chars")] public static extern GIOStatus IoChannelWriteChars(GIOChannel* channel, gchar* buf, gssize count, gsize* bytes_written, GError** error);
	[LinkName("g_io_channel_write_unichar")] public static extern GIOStatus IoChannelWriteUnichar(GIOChannel* channel, gunichar thechar, GError** error);
	[LinkName("g_io_channel_seek_position")] public static extern GIOStatus IoChannelSeekPosition(GIOChannel* channel, gint64 offset, GSeekType type, GError** error);
	[LinkName("g_io_channel_new_file")] public static extern GIOChannel* IoChannelNewFile(gchar* filename, gchar* mode, GError** error);
	[LinkName("g_io_channel_error_quark")] public static extern GQuark IoChannelErrorQuark();
	[LinkName("g_io_channel_error_from_errno")] public static extern GIOChannelError IoChannelErrorFromErrno(gint en);
	[LinkName("g_io_channel_unix_new")] public static extern GIOChannel* IoChannelUnixNew(c_int fd);
	[LinkName("g_io_channel_unix_get_fd")] public static extern gint IoChannelUnixGetFd(GIOChannel* channel);
}

static
{
	[CLink] public static extern GSourceFuncs g_io_watch_funcs;
}

extension GLib
{
	[LinkName("g_io_channel_win32_make_pollfd")] public static extern void IoChannelWin32MakePollfd(GIOChannel* channel, GIOCondition condition, GPollFD* fd);
	[LinkName("g_io_channel_win32_poll")] public static extern gint IoChannelWin32Poll(GPollFD* fds, gint n_fds, gint timeout);
	[LinkName("g_io_channel_win32_new_messages")] public static extern GIOChannel* IoChannelWin32NewMessages(gsize hwnd);
	[LinkName("g_io_channel_win32_new_fd")] public static extern GIOChannel* IoChannelWin32NewFd(gint fd);
	[LinkName("g_io_channel_win32_get_fd")] public static extern gint IoChannelWin32GetFd(GIOChannel* channel);
	[LinkName("g_io_channel_win32_new_socket")] public static extern GIOChannel* IoChannelWin32NewSocket(gint socket);
	[LinkName("g_io_channel_win32_new_stream_socket")] public static extern GIOChannel* IoChannelWin32NewStreamSocket(gint socket);
	[LinkName("g_io_channel_win32_set_debug")] public static extern void IoChannelWin32SetDebug(GIOChannel* channel, gboolean flag);
}

[AllowDuplicates] enum GKeyFileError : c_int
{
	UnknownEncoding = 0,
	Parse = 1,
	NotFound = 2,
	KeyNotFound = 3,
	GroupNotFound = 4,
	InvalidValue = 5,
}

extension GLib
{
	[LinkName("g_key_file_error_quark")] public static extern GQuark KeyFileErrorQuark();
}

struct GKeyFile;

[AllowDuplicates] enum GKeyFileFlags : c_int
{
	None = 0,
	KeepComments = 1 << 0,
	KeepTranslations = 1 << 1,
}

extension GLib
{
	[LinkName("g_key_file_new")] public static extern GKeyFile* KeyFileNew();
	[LinkName("g_key_file_ref")] public static extern GKeyFile* KeyFileRef(GKeyFile* key_file);
	[LinkName("g_key_file_unref")] public static extern void KeyFileUnref(GKeyFile* key_file);
	[LinkName("g_key_file_free")] public static extern void KeyFileFree(GKeyFile* key_file);
	[LinkName("g_key_file_set_list_separator")] public static extern void KeyFileSetListSeparator(GKeyFile* key_file, gchar separator);
	[LinkName("g_key_file_load_from_file")] public static extern gboolean KeyFileLoadFromFile(GKeyFile* key_file, gchar* file, GKeyFileFlags flags, GError** error);
	[LinkName("g_key_file_load_from_data")] public static extern gboolean KeyFileLoadFromData(GKeyFile* key_file, gchar* data, gsize length, GKeyFileFlags flags, GError** error);
	[LinkName("g_key_file_load_from_bytes")] public static extern gboolean KeyFileLoadFromBytes(GKeyFile* key_file, GBytes* bytes, GKeyFileFlags flags, GError** error);
	[LinkName("g_key_file_load_from_dirs")] public static extern gboolean KeyFileLoadFromDirs(GKeyFile* key_file, gchar* file, gchar** search_dirs, gchar** full_path, GKeyFileFlags flags, GError** error);
	[LinkName("g_key_file_load_from_data_dirs")] public static extern gboolean KeyFileLoadFromDataDirs(GKeyFile* key_file, gchar* file, gchar** full_path, GKeyFileFlags flags, GError** error);
	[LinkName("g_key_file_to_data")] public static extern gchar* KeyFileToData(GKeyFile* key_file, gsize* length, GError** error);
	[LinkName("g_key_file_save_to_file")] public static extern gboolean KeyFileSaveToFile(GKeyFile* key_file, gchar* filename, GError** error);
	[LinkName("g_key_file_get_start_group")] public static extern gchar* KeyFileGetStartGroup(GKeyFile* key_file);
	[LinkName("g_key_file_get_groups")] public static extern gchar** KeyFileGetGroups(GKeyFile* key_file, gsize* length);
	[LinkName("g_key_file_get_keys")] public static extern gchar** KeyFileGetKeys(GKeyFile* key_file, gchar* group_name, gsize* length, GError** error);
	[LinkName("g_key_file_has_group")] public static extern gboolean KeyFileHasGroup(GKeyFile* key_file, gchar* group_name);
	[LinkName("g_key_file_has_key")] public static extern gboolean KeyFileHasKey(GKeyFile* key_file, gchar* group_name, gchar* key, GError** error);
	[LinkName("g_key_file_get_value")] public static extern gchar* KeyFileGetValue(GKeyFile* key_file, gchar* group_name, gchar* key, GError** error);
	[LinkName("g_key_file_set_value")] public static extern void KeyFileSetValue(GKeyFile* key_file, gchar* group_name, gchar* key, gchar* value);
	[LinkName("g_key_file_get_string")] public static extern gchar* KeyFileGetString(GKeyFile* key_file, gchar* group_name, gchar* key, GError** error);
	[LinkName("g_key_file_set_string")] public static extern void KeyFileSetString(GKeyFile* key_file, gchar* group_name, gchar* key, gchar* string);
	[LinkName("g_key_file_get_locale_string")] public static extern gchar* KeyFileGetLocaleString(GKeyFile* key_file, gchar* group_name, gchar* key, gchar* locale, GError** error);
	[LinkName("g_key_file_get_locale_for_key")] public static extern gchar* KeyFileGetLocaleForKey(GKeyFile* key_file, gchar* group_name, gchar* key, gchar* locale);
	[LinkName("g_key_file_set_locale_string")] public static extern void KeyFileSetLocaleString(GKeyFile* key_file, gchar* group_name, gchar* key, gchar* locale, gchar* string);
	[LinkName("g_key_file_get_boolean")] public static extern gboolean KeyFileGetBoolean(GKeyFile* key_file, gchar* group_name, gchar* key, GError** error);
	[LinkName("g_key_file_set_boolean")] public static extern void KeyFileSetBoolean(GKeyFile* key_file, gchar* group_name, gchar* key, gboolean value);
	[LinkName("g_key_file_get_integer")] public static extern gint KeyFileGetInteger(GKeyFile* key_file, gchar* group_name, gchar* key, GError** error);
	[LinkName("g_key_file_set_integer")] public static extern void KeyFileSetInteger(GKeyFile* key_file, gchar* group_name, gchar* key, gint value);
	[LinkName("g_key_file_get_int64")] public static extern gint64 KeyFileGetInt64(GKeyFile* key_file, gchar* group_name, gchar* key, GError** error);
	[LinkName("g_key_file_set_int64")] public static extern void KeyFileSetInt64(GKeyFile* key_file, gchar* group_name, gchar* key, gint64 value);
	[LinkName("g_key_file_get_uint64")] public static extern guint64 KeyFileGetUint64(GKeyFile* key_file, gchar* group_name, gchar* key, GError** error);
	[LinkName("g_key_file_set_uint64")] public static extern void KeyFileSetUint64(GKeyFile* key_file, gchar* group_name, gchar* key, guint64 value);
	[LinkName("g_key_file_get_double")] public static extern gdouble KeyFileGetDouble(GKeyFile* key_file, gchar* group_name, gchar* key, GError** error);
	[LinkName("g_key_file_set_double")] public static extern void KeyFileSetDouble(GKeyFile* key_file, gchar* group_name, gchar* key, gdouble value);
	[LinkName("g_key_file_get_string_list")] public static extern gchar** KeyFileGetStringList(GKeyFile* key_file, gchar* group_name, gchar* key, gsize* length, GError** error);
	[LinkName("g_key_file_set_string_list")] public static extern void KeyFileSetStringList(GKeyFile* key_file, gchar* group_name, gchar* key, gchar** list, gsize length);
	[LinkName("g_key_file_get_locale_string_list")] public static extern gchar** KeyFileGetLocaleStringList(GKeyFile* key_file, gchar* group_name, gchar* key, gchar* locale, gsize* length, GError** error);
	[LinkName("g_key_file_set_locale_string_list")] public static extern void KeyFileSetLocaleStringList(GKeyFile* key_file, gchar* group_name, gchar* key, gchar* locale, gchar** list, gsize length);
	[LinkName("g_key_file_get_boolean_list")] public static extern gboolean* KeyFileGetBooleanList(GKeyFile* key_file, gchar* group_name, gchar* key, gsize* length, GError** error);
	[LinkName("g_key_file_set_boolean_list")] public static extern void KeyFileSetBooleanList(GKeyFile* key_file, gchar* group_name, gchar* key, gboolean* list, gsize length);
	[LinkName("g_key_file_get_integer_list")] public static extern gint* KeyFileGetIntegerList(GKeyFile* key_file, gchar* group_name, gchar* key, gsize* length, GError** error);
	[LinkName("g_key_file_set_double_list")] public static extern void KeyFileSetDoubleList(GKeyFile* key_file, gchar* group_name, gchar* key, gdouble* list, gsize length);
	[LinkName("g_key_file_get_double_list")] public static extern gdouble* KeyFileGetDoubleList(GKeyFile* key_file, gchar* group_name, gchar* key, gsize* length, GError** error);
	[LinkName("g_key_file_set_integer_list")] public static extern void KeyFileSetIntegerList(GKeyFile* key_file, gchar* group_name, gchar* key, gint* list, gsize length);
	[LinkName("g_key_file_set_comment")] public static extern gboolean KeyFileSetComment(GKeyFile* key_file, gchar* group_name, gchar* key, gchar* comment, GError** error);
	[LinkName("g_key_file_get_comment")] public static extern gchar* KeyFileGetComment(GKeyFile* key_file, gchar* group_name, gchar* key, GError** error);
	[LinkName("g_key_file_remove_comment")] public static extern gboolean KeyFileRemoveComment(GKeyFile* key_file, gchar* group_name, gchar* key, GError** error);
	[LinkName("g_key_file_remove_key")] public static extern gboolean KeyFileRemoveKey(GKeyFile* key_file, gchar* group_name, gchar* key, GError** error);
	[LinkName("g_key_file_remove_group")] public static extern gboolean KeyFileRemoveGroup(GKeyFile* key_file, gchar* group_name, GError** error);
}

struct GMappedFile;

extension GLib
{
	[LinkName("g_mapped_file_new")] public static extern GMappedFile* MappedFileNew(gchar* filename, gboolean writable, GError** error);
	[LinkName("g_mapped_file_new_from_fd")] public static extern GMappedFile* MappedFileNewFromFd(gint fd, gboolean writable, GError** error);
	[LinkName("g_mapped_file_get_length")] public static extern gsize MappedFileGetLength(GMappedFile* file);
	[LinkName("g_mapped_file_get_contents")] public static extern gchar* MappedFileGetContents(GMappedFile* file);
	[LinkName("g_mapped_file_get_bytes")] public static extern GBytes* MappedFileGetBytes(GMappedFile* file);
	[LinkName("g_mapped_file_ref")] public static extern GMappedFile* MappedFileRef(GMappedFile* file);
	[LinkName("g_mapped_file_unref")] public static extern void MappedFileUnref(GMappedFile* file);
	[LinkName("g_mapped_file_free")] public static extern void MappedFileFree(GMappedFile* file);
}

/** GMarkupError:
 *   @G _MARKUP_ERROR_BAD_UTF8: text being parsed was not valid UTF-8
 *   @G _MARKUP_ERROR_EMPTY: document contained nothing, or only whitespace
 *   @G _MARKUP_ERROR_PARSE: document was ill-formed
 *   @G _MARKUP_ERROR_UNKNOWN_ELEMENT: error should be set by #GMarkupParser
 *  functions; element wasn't known
 *   @G _MARKUP_ERROR_UNKNOWN_ATTRIBUTE: error should be set by #GMarkupParser
 *  functions; attribute wasn't known
 *   @G _MARKUP_ERROR_INVALID_CONTENT: error should be set by #GMarkupParser
 *  functions; content was invalid
 *   @G _MARKUP_ERROR_MISSING_ATTRIBUTE: error should be set by #GMarkupParser
 *  functions; a required attribute was missing
 *  
 *  Error codes returned by markup parsing.
 */
[AllowDuplicates] enum GMarkupError : c_int
{
	BadUtf8 = 0,
	Empty = 1,
	Parse = 2,
	UnknownElement = 3,
	UnknownAttribute = 4,
	InvalidContent = 5,
	MissingAttribute = 6,
}

extension GLib
{
	[LinkName("g_markup_error_quark")] public static extern GQuark MarkupErrorQuark();
}

/** GMarkupParseFlags:
 *   @G _MARKUP_DEFAULT_FLAGS: No special behaviour. Since: 2.74
 *   @G _MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: flag you should not use
 *   @G _MARKUP_TREAT_CDATA_AS_TEXT: When this flag is set, CDATA marked
 *  sections are not passed literally to the @passthrough function of
 *  the parser. Instead, the content of the section (without the
 *  `<![CDATA[` and `]]>`) is
 *  passed to the@test function. This flag was added in GLib 2.12
 *         @G _MARKUP_PREFIX_ERROR_POSITION: Normally errors caught by GMarkup
 *        itself have line/column information prefixed to them to let the
 *        caller know the location of the error. When this flag is set the
 *        location information is also prefixed to errors generated by the
 *        #GMarkupParser implementation functions
 *         @G _MARKUP_IGNORE_QUALIFIED: Ignore (don't report) qualified
 *        attributes and tags, along with their contents.  A qualified
 *        attribute or tag is one that contains ':' in its name (ie: is in
 *        another namespace).  Since: 2.40.
 *  
 *  Flags that affect the behaviour of the parser.
 */
[AllowDuplicates] enum GMarkupParseFlags : c_int
{
	DefaultFlags = 0,
	DoNotUseThisUnsupportedFlag = 1 << 0,
	TreatCdataAsText = 1 << 1,
	RefixErrorPosition = 1 << 2,
	IgnoreQualified = 1 << 3,
}

struct GMarkupParseContext;


/** GMarkupParser:
 *   @start _element: Callback to invoke when the opening tag of an element
 *  is seen. The callback's @attribute _names and @attribute _values parameters
 *  are %NULL-terminated.
 *   @end _element: Callback to invoke when the closing tag of an element
 *  is seen. Note that this is also called for empty tags like
 *  `<empty />`.
 *  @test : Callback to invoke when some text is seen (text is always
 *        inside an element). Note that the text of an element may be spread
 *        over multiple calls of this function. If the
 *        %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also
 *        called for the content of CDATA marked sections.
 *         @passthrough : Callback to invoke for comments, processing instructions
 *        and doctype declarations; if you're re-writing the parsed document,
 *        write the passthrough text back out in the same position. If the
 *        %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also
 *        called for CDATA marked sections.
 *         @error : Callback to invoke when an error occurs.
 *  
 *  Any of the fields in #GMarkupParser can be %NULL, in which case they
 *  will be ignored. Except for the @error function, any of these callbacks
 *  can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,
 *  %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT
 *  errors are intended to be set from these callbacks. If you set an error
 *  from a callback, g_markup_parse_context_parse() will report that error
 *  back to its caller.
 */
[CRepr] struct GMarkupParser
{
	public function void(GMarkupParseContext*, gchar*, gchar**, gchar**, gpointer, GError**) start_element;
	public function void(GMarkupParseContext*, gchar*, gpointer, GError**) end_element;
	public function void(GMarkupParseContext*, gchar*, gsize, gpointer, GError**) text;
	public function void(GMarkupParseContext*, gchar*, gsize, gpointer, GError**) passthrough;
	public function void(GMarkupParseContext*, GError*, gpointer) error;
}

extension GLib
{
	[LinkName("g_markup_parse_context_new")] public static extern GMarkupParseContext* MarkupParseContextNew(GMarkupParser* parser, GMarkupParseFlags flags, gpointer user_data, GDestroyNotify user_data_dnotify);
	[LinkName("g_markup_parse_context_ref")] public static extern GMarkupParseContext* MarkupParseContextRef(GMarkupParseContext* context);
	[LinkName("g_markup_parse_context_unref")] public static extern void MarkupParseContextUnref(GMarkupParseContext* context);
	[LinkName("g_markup_parse_context_free")] public static extern void MarkupParseContextFree(GMarkupParseContext* context);
	[LinkName("g_markup_parse_context_parse")] public static extern gboolean MarkupParseContextParse(GMarkupParseContext* context, gchar* text, gssize text_len, GError** error);
	[LinkName("g_markup_parse_context_push")] public static extern void MarkupParseContextPush(GMarkupParseContext* context, GMarkupParser* parser, gpointer user_data);
	[LinkName("g_markup_parse_context_pop")] public static extern gpointer MarkupParseContextPop(GMarkupParseContext* context);
	[LinkName("g_markup_parse_context_end_parse")] public static extern gboolean MarkupParseContextEndParse(GMarkupParseContext* context, GError** error);
	[LinkName("g_markup_parse_context_get_element")] public static extern gchar* MarkupParseContextGetElement(GMarkupParseContext* context);
	[LinkName("g_markup_parse_context_get_element_stack")] public static extern GSList* MarkupParseContextGetElementStack(GMarkupParseContext* context);
	[LinkName("g_markup_parse_context_get_position")] public static extern void MarkupParseContextGetPosition(GMarkupParseContext* context, gint* line_number, gint* char_number);
	[LinkName("g_markup_parse_context_get_user_data")] public static extern gpointer MarkupParseContextGetUserData(GMarkupParseContext* context);
	[LinkName("g_markup_escape_text")] public static extern gchar* MarkupEscapeText(gchar* text, gssize length);
	[LinkName("g_markup_printf_escaped")] public static extern gchar* MarkupPrintfEscaped(c_char* format, ...);
	[LinkName("g_markup_vprintf_escaped")] public static extern gchar* MarkupVprintfEscaped(c_char* format, VarArgs args);
}

[AllowDuplicates] enum GMarkupCollectType : c_int
{
	Invalid = 0,
	String = 1,
	Strdup = 2,
	Boolean = 3,
	Ristate = 4,
	Optional = (1 << 16),
}

extension GLib
{
	[LinkName("g_markup_collect_attributes")] public static extern gboolean MarkupCollectAttributes(gchar* element_name, gchar** attribute_names, gchar** attribute_values, GError** error, GMarkupCollectType first_type, gchar* first_attr, ...);
}

struct GVariantType;

extension GLib
{
	[LinkName("g_variant_type_string_is_valid")] public static extern gboolean VariantTypeStringIsValid(gchar* type_string);
	[LinkName("g_variant_type_string_scan")] public static extern gboolean VariantTypeStringScan(gchar* string, gchar* limit, gchar** endptr);
	[LinkName("g_variant_type_free")] public static extern void VariantTypeFree(GVariantType* type);
	[LinkName("g_variant_type_copy")] public static extern GVariantType* VariantTypeCopy(GVariantType* type);
	[LinkName("g_variant_type_new")] public static extern GVariantType* VariantTypeNew(gchar* type_string);
	[LinkName("g_variant_type_get_string_length")] public static extern gsize VariantTypeGetStringLength(GVariantType* type);
	[LinkName("g_variant_type_peek_string")] public static extern gchar* VariantTypePeekString(GVariantType* type);
	[LinkName("g_variant_type_dup_string")] public static extern gchar* VariantTypeDupString(GVariantType* type);
	[LinkName("g_variant_type_is_definite")] public static extern gboolean VariantTypeIsDefinite(GVariantType* type);
	[LinkName("g_variant_type_is_container")] public static extern gboolean VariantTypeIsContainer(GVariantType* type);
	[LinkName("g_variant_type_is_basic")] public static extern gboolean VariantTypeIsBasic(GVariantType* type);
	[LinkName("g_variant_type_is_maybe")] public static extern gboolean VariantTypeIsMaybe(GVariantType* type);
	[LinkName("g_variant_type_is_array")] public static extern gboolean VariantTypeIsArray(GVariantType* type);
	[LinkName("g_variant_type_is_tuple")] public static extern gboolean VariantTypeIsTuple(GVariantType* type);
	[LinkName("g_variant_type_is_dict_entry")] public static extern gboolean VariantTypeIsDictEntry(GVariantType* type);
	[LinkName("g_variant_type_is_variant")] public static extern gboolean VariantTypeIsVariant(GVariantType* type);
	[LinkName("g_variant_type_hash")] public static extern guint VariantTypeHash(gconstpointer type);
	[LinkName("g_variant_type_equal")] public static extern gboolean VariantTypeEqual(gconstpointer type1, gconstpointer type2);
	[LinkName("g_variant_type_is_subtype_of")] public static extern gboolean VariantTypeIsSubtypeOf(GVariantType* type, GVariantType* supertype);
	[LinkName("g_variant_type_element")] public static extern GVariantType* VariantTypeElement(GVariantType* type);
	[LinkName("g_variant_type_first")] public static extern GVariantType* VariantTypeFirst(GVariantType* type);
	[LinkName("g_variant_type_next")] public static extern GVariantType* VariantTypeNext(GVariantType* type);
	[LinkName("g_variant_type_n_items")] public static extern gsize VariantTypeNItems(GVariantType* type);
	[LinkName("g_variant_type_key")] public static extern GVariantType* VariantTypeKey(GVariantType* type);
	[LinkName("g_variant_type_value")] public static extern GVariantType* VariantTypeValue(GVariantType* type);
	[LinkName("g_variant_type_new_array")] public static extern GVariantType* VariantTypeNewArray(GVariantType* element);
	[LinkName("g_variant_type_new_maybe")] public static extern GVariantType* VariantTypeNewMaybe(GVariantType* element);
	[LinkName("g_variant_type_new_tuple")] public static extern GVariantType* VariantTypeNewTuple(GVariantType** items, gint length);
	[LinkName("g_variant_type_new_dict_entry")] public static extern GVariantType* VariantTypeNewDictEntry(GVariantType* key, GVariantType* value);
	[LinkName("g_variant_type_checked_")] public static extern GVariantType* VariantTypeChecked(gchar* type_string);
	[LinkName("g_variant_type_string_get_depth_")] public static extern gsize VariantTypeStringGetDepth(gchar* type_string);
}

struct GVariant;

[AllowDuplicates] enum GVariantClass : c_int
{
	Boolean = 'b',
	Byte = 'y',
	Int16 = 'n',
	Uint16 = 'q',
	Int32 = 'i',
	Uint32 = 'u',
	Int64 = 'x',
	Uint64 = 't',
	Handle = 'h',
	Double = 'd',
	String = 's',
	ObjectPath = 'o',
	Signature = 'g',
	Variant = 'v',
	Maybe = 'm',
	Array = 'a',
	Tuple = '(',
	DictEntry = '{',
}

extension GLib
{
	[LinkName("g_variant_unref")] public static extern void VariantUnref(GVariant* value);
	[LinkName("g_variant_ref")] public static extern GVariant* VariantRef(GVariant* value);
	[LinkName("g_variant_ref_sink")] public static extern GVariant* VariantRefSink(GVariant* value);
	[LinkName("g_variant_is_floating")] public static extern gboolean VariantIsFloating(GVariant* value);
	[LinkName("g_variant_take_ref")] public static extern GVariant* VariantTakeRef(GVariant* value);
	[LinkName("g_variant_get_type")] public static extern GVariantType* VariantGetType(GVariant* value);
	[LinkName("g_variant_get_type_string")] public static extern gchar* VariantGetTypeString(GVariant* value);
	[LinkName("g_variant_is_of_type")] public static extern gboolean VariantIsOfType(GVariant* value, GVariantType* type);
	[LinkName("g_variant_is_container")] public static extern gboolean VariantIsContainer(GVariant* value);
	[LinkName("g_variant_classify")] public static extern GVariantClass VariantClassify(GVariant* value);
	[LinkName("g_variant_new_boolean")] public static extern GVariant* VariantNewBoolean(gboolean value);
	[LinkName("g_variant_new_byte")] public static extern GVariant* VariantNewByte(guint8 value);
	[LinkName("g_variant_new_int16")] public static extern GVariant* VariantNewInt16(gint16 value);
	[LinkName("g_variant_new_uint16")] public static extern GVariant* VariantNewUint16(guint16 value);
	[LinkName("g_variant_new_int32")] public static extern GVariant* VariantNewInt32(gint32 value);
	[LinkName("g_variant_new_uint32")] public static extern GVariant* VariantNewUint32(guint32 value);
	[LinkName("g_variant_new_int64")] public static extern GVariant* VariantNewInt64(gint64 value);
	[LinkName("g_variant_new_uint64")] public static extern GVariant* VariantNewUint64(guint64 value);
	[LinkName("g_variant_new_handle")] public static extern GVariant* VariantNewHandle(gint32 value);
	[LinkName("g_variant_new_double")] public static extern GVariant* VariantNewDouble(gdouble value);
	[LinkName("g_variant_new_string")] public static extern GVariant* VariantNewString(gchar* string);
	[LinkName("g_variant_new_take_string")] public static extern GVariant* VariantNewTakeString(gchar* string);
	[LinkName("g_variant_new_printf")] public static extern GVariant* VariantNewPrintf(gchar* format_string, ...);
	[LinkName("g_variant_new_object_path")] public static extern GVariant* VariantNewObjectPath(gchar* object_path);
	[LinkName("g_variant_is_object_path")] public static extern gboolean VariantIsObjectPath(gchar* string);
	[LinkName("g_variant_new_signature")] public static extern GVariant* VariantNewSignature(gchar* signature);
	[LinkName("g_variant_is_signature")] public static extern gboolean VariantIsSignature(gchar* string);
	[LinkName("g_variant_new_variant")] public static extern GVariant* VariantNewVariant(GVariant* value);
	[LinkName("g_variant_new_strv")] public static extern GVariant* VariantNewStrv(gchar** strv, gssize length);
	[LinkName("g_variant_new_objv")] public static extern GVariant* VariantNewObjv(gchar** strv, gssize length);
	[LinkName("g_variant_new_bytestring")] public static extern GVariant* VariantNewBytestring(gchar* string);
	[LinkName("g_variant_new_bytestring_array")] public static extern GVariant* VariantNewBytestringArray(gchar** strv, gssize length);
	[LinkName("g_variant_new_fixed_array")] public static extern GVariant* VariantNewFixedArray(GVariantType* element_type, gconstpointer elements, gsize n_elements, gsize element_size);
	[LinkName("g_variant_get_boolean")] public static extern gboolean VariantGetBoolean(GVariant* value);
	[LinkName("g_variant_get_byte")] public static extern guint8 VariantGetByte(GVariant* value);
	[LinkName("g_variant_get_int16")] public static extern gint16 VariantGetInt16(GVariant* value);
	[LinkName("g_variant_get_uint16")] public static extern guint16 VariantGetUint16(GVariant* value);
	[LinkName("g_variant_get_int32")] public static extern gint32 VariantGetInt32(GVariant* value);
	[LinkName("g_variant_get_uint32")] public static extern guint32 VariantGetUint32(GVariant* value);
	[LinkName("g_variant_get_int64")] public static extern gint64 VariantGetInt64(GVariant* value);
	[LinkName("g_variant_get_uint64")] public static extern guint64 VariantGetUint64(GVariant* value);
	[LinkName("g_variant_get_handle")] public static extern gint32 VariantGetHandle(GVariant* value);
	[LinkName("g_variant_get_double")] public static extern gdouble VariantGetDouble(GVariant* value);
	[LinkName("g_variant_get_variant")] public static extern GVariant* VariantGetVariant(GVariant* value);
	[LinkName("g_variant_get_string")] public static extern gchar* VariantGetString(GVariant* value, gsize* length);
	[LinkName("g_variant_dup_string")] public static extern gchar* VariantDupString(GVariant* value, gsize* length);
	[LinkName("g_variant_get_strv")] public static extern gchar** VariantGetStrv(GVariant* value, gsize* length);
	[LinkName("g_variant_dup_strv")] public static extern gchar** VariantDupStrv(GVariant* value, gsize* length);
	[LinkName("g_variant_get_objv")] public static extern gchar** VariantGetObjv(GVariant* value, gsize* length);
	[LinkName("g_variant_dup_objv")] public static extern gchar** VariantDupObjv(GVariant* value, gsize* length);
	[LinkName("g_variant_get_bytestring")] public static extern gchar* VariantGetBytestring(GVariant* value);
	[LinkName("g_variant_dup_bytestring")] public static extern gchar* VariantDupBytestring(GVariant* value, gsize* length);
	[LinkName("g_variant_get_bytestring_array")] public static extern gchar** VariantGetBytestringArray(GVariant* value, gsize* length);
	[LinkName("g_variant_dup_bytestring_array")] public static extern gchar** VariantDupBytestringArray(GVariant* value, gsize* length);
	[LinkName("g_variant_new_maybe")] public static extern GVariant* VariantNewMaybe(GVariantType* child_type, GVariant* child);
	[LinkName("g_variant_new_array")] public static extern GVariant* VariantNewArray(GVariantType* child_type, GVariant** children, gsize n_children);
	[LinkName("g_variant_new_tuple")] public static extern GVariant* VariantNewTuple(GVariant** children, gsize n_children);
	[LinkName("g_variant_new_dict_entry")] public static extern GVariant* VariantNewDictEntry(GVariant* key, GVariant* value);
	[LinkName("g_variant_get_maybe")] public static extern GVariant* VariantGetMaybe(GVariant* value);
	[LinkName("g_variant_n_children")] public static extern gsize VariantNChildren(GVariant* value);
	[LinkName("g_variant_get_child")] public static extern void VariantGetChild(GVariant* value, gsize index, gchar* format_string, ...);
	[LinkName("g_variant_get_child_value")] public static extern GVariant* VariantGetChildValue(GVariant* value, gsize index);
	[LinkName("g_variant_lookup")] public static extern gboolean VariantLookup(GVariant* dictionary, gchar* key, gchar* format_string, ...);
	[LinkName("g_variant_lookup_value")] public static extern GVariant* VariantLookupValue(GVariant* dictionary, gchar* key, GVariantType* expected_type);
	[LinkName("g_variant_get_fixed_array")] public static extern gconstpointer VariantGetFixedArray(GVariant* value, gsize* n_elements, gsize element_size);
	[LinkName("g_variant_get_size")] public static extern gsize VariantGetSize(GVariant* value);
	[LinkName("g_variant_get_data")] public static extern gconstpointer VariantGetData(GVariant* value);
	[LinkName("g_variant_get_data_as_bytes")] public static extern GBytes* VariantGetDataAsBytes(GVariant* value);
	[LinkName("g_variant_store")] public static extern void VariantStore(GVariant* value, gpointer data);
	[LinkName("g_variant_print")] public static extern gchar* VariantPrint(GVariant* value, gboolean type_annotate);
	[LinkName("g_variant_print_string")] public static extern GString* VariantPrintString(GVariant* value, GString* string, gboolean type_annotate);
	[LinkName("g_variant_hash")] public static extern guint VariantHash(gconstpointer value);
	[LinkName("g_variant_equal")] public static extern gboolean VariantEqual(gconstpointer one, gconstpointer two);
	[LinkName("g_variant_get_normal_form")] public static extern GVariant* VariantGetNormalForm(GVariant* value);
	[LinkName("g_variant_is_normal_form")] public static extern gboolean VariantIsNormalForm(GVariant* value);
	[LinkName("g_variant_byteswap")] public static extern GVariant* VariantByteswap(GVariant* value);
	[LinkName("g_variant_new_from_bytes")] public static extern GVariant* VariantNewFromBytes(GVariantType* type, GBytes* bytes, gboolean trusted);
	[LinkName("g_variant_new_from_data")] public static extern GVariant* VariantNewFromData(GVariantType* type, gconstpointer data, gsize size, gboolean trusted, GDestroyNotify notify, gpointer user_data);
}


[CRepr] struct GVariantIter
{
	public guintptr[16] x;
}

extension GLib
{
	[LinkName("g_variant_iter_new")] public static extern GVariantIter* VariantIterNew(GVariant* value);
	[LinkName("g_variant_iter_init")] public static extern gsize VariantIterInit(GVariantIter* iter, GVariant* value);
	[LinkName("g_variant_iter_copy")] public static extern GVariantIter* VariantIterCopy(GVariantIter* iter);
	[LinkName("g_variant_iter_n_children")] public static extern gsize VariantIterNChildren(GVariantIter* iter);
	[LinkName("g_variant_iter_free")] public static extern void VariantIterFree(GVariantIter* iter);
	[LinkName("g_variant_iter_next_value")] public static extern GVariant* VariantIterNextValue(GVariantIter* iter);
	[LinkName("g_variant_iter_next")] public static extern gboolean VariantIterNext(GVariantIter* iter, gchar* format_string, ...);
	[LinkName("g_variant_iter_loop")] public static extern gboolean VariantIterLoop(GVariantIter* iter, gchar* format_string, ...);
}


[CRepr] struct GVariantBuilder
{
	[Union, CRepr]public  struct 
	{
		[CRepr]public  struct 
	{
		public gsize partial_magic;
		public GVariantType* type;
		public guintptr[14] y;
	} s;
		public guintptr[16] x;
	} u;
}

[AllowDuplicates] enum GVariantParseError : c_int
{
	Failed = 0,
	BasicTypeExpected = 1,
	CannotInferType = 2,
	DefiniteTypeExpected = 3,
	InputNotAtEnd = 4,
	InvalidCharacter = 5,
	InvalidFormatString = 6,
	InvalidObjectPath = 7,
	InvalidSignature = 8,
	InvalidTypeString = 9,
	NoCommonType = 10,
	NumberOutOfRange = 11,
	NumberTooBig = 12,
	TypeError = 13,
	UnexpectedToken = 14,
	UnknownKeyword = 15,
	UnterminatedStringConstant = 16,
	ValueExpected = 17,
	Recursion = 18,
}

extension GLib
{
	[LinkName("g_variant_parser_get_error_quark")] public static extern GQuark VariantParserGetErrorQuark();
	[LinkName("g_variant_parse_error_quark")] public static extern GQuark VariantParseErrorQuark();
	[LinkName("g_variant_builder_new")] public static extern GVariantBuilder* VariantBuilderNew(GVariantType* type);
	[LinkName("g_variant_builder_unref")] public static extern void VariantBuilderUnref(GVariantBuilder* builder);
	[LinkName("g_variant_builder_ref")] public static extern GVariantBuilder* VariantBuilderRef(GVariantBuilder* builder);
	[LinkName("g_variant_builder_init")] public static extern void VariantBuilderInit(GVariantBuilder* builder, GVariantType* type);
	[LinkName("g_variant_builder_init_static")] public static extern void VariantBuilderInitStatic(GVariantBuilder* builder, GVariantType* type);
	[LinkName("g_variant_builder_end")] public static extern GVariant* VariantBuilderEnd(GVariantBuilder* builder);
	[LinkName("g_variant_builder_clear")] public static extern void VariantBuilderClear(GVariantBuilder* builder);
	[LinkName("g_variant_builder_open")] public static extern void VariantBuilderOpen(GVariantBuilder* builder, GVariantType* type);
	[LinkName("g_variant_builder_close")] public static extern void VariantBuilderClose(GVariantBuilder* builder);
	[LinkName("g_variant_builder_add_value")] public static extern void VariantBuilderAddValue(GVariantBuilder* builder, GVariant* value);
	[LinkName("g_variant_builder_add")] public static extern void VariantBuilderAdd(GVariantBuilder* builder, gchar* format_string, ...);
	[LinkName("g_variant_builder_add_parsed")] public static extern void VariantBuilderAddParsed(GVariantBuilder* builder, gchar* format, ...);
	[LinkName("g_variant_new")] public static extern GVariant* VariantNew(gchar* format_string, ...);
	[LinkName("g_variant_get")] public static extern void VariantGet(GVariant* value, gchar* format_string, ...);
	[LinkName("g_variant_new_va")] public static extern GVariant* VariantNewVa(gchar* format_string, gchar** endptr, VarArgs* app);
	[LinkName("g_variant_get_va")] public static extern void VariantGetVa(GVariant* value, gchar* format_string, gchar** endptr, VarArgs* app);
	[LinkName("g_variant_check_format_string")] public static extern gboolean VariantCheckFormatString(GVariant* value, gchar* format_string, gboolean copy_only);
	[LinkName("g_variant_parse")] public static extern GVariant* VariantParse(GVariantType* type, gchar* text, gchar* limit, gchar** endptr, GError** error);
	[LinkName("g_variant_new_parsed")] public static extern GVariant* VariantNewParsed(gchar* format, ...);
	[LinkName("g_variant_new_parsed_va")] public static extern GVariant* VariantNewParsedVa(gchar* format, VarArgs* app);
	[LinkName("g_variant_parse_error_print_context")] public static extern gchar* VariantParseErrorPrintContext(GError* error, gchar* source_str);
	[LinkName("g_variant_compare")] public static extern gint VariantCompare(gconstpointer one, gconstpointer two);
}


[CRepr] struct GVariantDict
{
	[Union, CRepr]public  struct 
	{
		[CRepr]public  struct 
	{
		public GVariant* asv;
		public gsize partial_magic;
		public guintptr[14] y;
	} s;
		public guintptr[16] x;
	} u;
}

extension GLib
{
	[LinkName("g_variant_dict_new")] public static extern GVariantDict* VariantDictNew(GVariant* from_asv);
	[LinkName("g_variant_dict_init")] public static extern void VariantDictInit(GVariantDict* dict, GVariant* from_asv);
	[LinkName("g_variant_dict_lookup")] public static extern gboolean VariantDictLookup(GVariantDict* dict, gchar* key, gchar* format_string, ...);
	[LinkName("g_variant_dict_lookup_value")] public static extern GVariant* VariantDictLookupValue(GVariantDict* dict, gchar* key, GVariantType* expected_type);
	[LinkName("g_variant_dict_contains")] public static extern gboolean VariantDictContains(GVariantDict* dict, gchar* key);
	[LinkName("g_variant_dict_insert")] public static extern void VariantDictInsert(GVariantDict* dict, gchar* key, gchar* format_string, ...);
	[LinkName("g_variant_dict_insert_value")] public static extern void VariantDictInsertValue(GVariantDict* dict, gchar* key, GVariant* value);
	[LinkName("g_variant_dict_remove")] public static extern gboolean VariantDictRemove(GVariantDict* dict, gchar* key);
	[LinkName("g_variant_dict_clear")] public static extern void VariantDictClear(GVariantDict* dict);
	[LinkName("g_variant_dict_end")] public static extern GVariant* VariantDictEnd(GVariantDict* dict);
	[LinkName("g_variant_dict_ref")] public static extern GVariantDict* VariantDictRef(GVariantDict* dict);
	[LinkName("g_variant_dict_unref")] public static extern void VariantDictUnref(GVariantDict* dict);
	[LinkName("g_printf_string_upper_bound")] public static extern gsize PrintfStringUpperBound(gchar* format, VarArgs args);
}

[AllowDuplicates] enum GLogLevelFlags : c_int
{
	FlagRecursion = 1 << 0,
	FlagFatal = 1 << 1,
	Error = 1 << 2,
	Critical = 1 << 3,
	Warning = 1 << 4,
	Message = 1 << 5,
	Info = 1 << 6,
	Debug = 1 << 7,
	Mask = ~(FlagRecursion | FlagFatal),
}

function void GLogFunc(gchar* log_domain, GLogLevelFlags log_level, gchar* message, gpointer user_data);

extension GLib
{
	[LinkName("g_log_set_handler")] public static extern guint LogSetHandler(gchar* log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data);
	[LinkName("g_log_set_handler_full")] public static extern guint LogSetHandlerFull(gchar* log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data, GDestroyNotify destroy);
	[LinkName("g_log_remove_handler")] public static extern void LogRemoveHandler(gchar* log_domain, guint handler_id);
	[LinkName("g_log_default_handler")] public static extern void LogDefaultHandler(gchar* log_domain, GLogLevelFlags log_level, gchar* message, gpointer unused_data);
	[LinkName("g_log_set_default_handler")] public static extern GLogFunc LogSetDefaultHandler(GLogFunc log_func, gpointer user_data);
	[LinkName("g_log")] public static extern void Log(gchar* log_domain, GLogLevelFlags log_level, gchar* format, ...);
	[LinkName("g_logv")] public static extern void Logv(gchar* log_domain, GLogLevelFlags log_level, gchar* format, VarArgs args);
	[LinkName("g_log_set_fatal_mask")] public static extern GLogLevelFlags LogSetFatalMask(gchar* log_domain, GLogLevelFlags fatal_mask);
	[LinkName("g_log_set_always_fatal")] public static extern GLogLevelFlags LogSetAlwaysFatal(GLogLevelFlags fatal_mask);
}

/** GLogWriterOutput:
 *   @G _LOG_WRITER_HANDLED: Log writer has handled the log entry.
 *   @G _LOG_WRITER_UNHANDLED: Log writer could not handle the log entry.
 *  
 *  Return values from #GLogWriterFuncs to indicate whether the given log entry
 *  was successfully handled by the writer, or whether there was an error in
 *  handling it (and hence a fallback writer should be used).
 *  
 *  If a #GLogWriterFunc ignores a log entry, it should return
 *  %G_LOG_WRITER_HANDLED.
 *  
 *  Since: 2.50
 */
[AllowDuplicates] enum GLogWriterOutput : c_int
{
	Handled = 1,
	Unhandled = 0,
}


[CRepr] struct GLogField
{
	public gchar* key;
	public gconstpointer value;
	public gssize length;
}

/** GLogWriterFunc:
 *   @log _level: log level of the message
 *   @fields : (array length=n_fields): fields forming the message
 *   @n _fields: number of @fields
 *   @user _data: user data passed to g_log_set_writer_func()
 *  
 *  Writer function for log entries. A log entry is a collection of one or more
 *  #GLogFields, using the standard [field names from journal
 *  specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html).
 *  See g_log_structured() for more information.
 *  
 *  Writer functions must ignore fields which they do not recognise, unless they
 *  can write arbitrary binary output, as field values may be arbitrary binary.
 *  
 *   @log _level is guaranteed to be included in @fields as the `PRIORITY` field,
 *  but is provided separately for convenience of deciding whether or where to
 *  output the log entry.
 *  
 *  Writer functions should return %G_LOG_WRITER_HANDLED if they handled the log
 *  message successfully or if they deliberately ignored it. If there was an
 *  error handling the message (for example, if the writer function is meant to
 *  send messages to a remote logging server and there is a network error), it
 *  should return %G_LOG_WRITER_UNHANDLED. This allows writer functions to be
 *  chained and fall back to simpler handlers in case of failure.
 *  
 *  Returns: %G_LOG_WRITER_HANDLED if the log entry was handled successfully;
 *  %G_LOG_WRITER_UNHANDLED otherwise
 *  
 *  Since: 2.50
 */
function GLogWriterOutput GLogWriterFunc(GLogLevelFlags log_level, GLogField* fields, gsize n_fields, gpointer user_data);

extension GLib
{
	[LinkName("g_log_structured")] public static extern void LogStructured(gchar* log_domain, GLogLevelFlags log_level, ...);
	[LinkName("g_log_structured_array")] public static extern void LogStructuredArray(GLogLevelFlags log_level, GLogField* fields, gsize n_fields);
	[LinkName("g_log_variant")] public static extern void LogVariant(gchar* log_domain, GLogLevelFlags log_level, GVariant* fields);
	[LinkName("g_log_set_writer_func")] public static extern void LogSetWriterFunc(GLogWriterFunc func, gpointer user_data, GDestroyNotify user_data_free);
	[LinkName("g_log_writer_supports_color")] public static extern gboolean LogWriterSupportsColor(gint output_fd);
	[LinkName("g_log_writer_is_journald")] public static extern gboolean LogWriterIsJournald(gint output_fd);
	[LinkName("g_log_writer_format_fields")] public static extern gchar* LogWriterFormatFields(GLogLevelFlags log_level, GLogField* fields, gsize n_fields, gboolean use_color);
	[LinkName("g_log_writer_syslog")] public static extern GLogWriterOutput LogWriterSyslog(GLogLevelFlags log_level, GLogField* fields, gsize n_fields, gpointer user_data);
	[LinkName("g_log_writer_journald")] public static extern GLogWriterOutput LogWriterJournald(GLogLevelFlags log_level, GLogField* fields, gsize n_fields, gpointer user_data);
	[LinkName("g_log_writer_standard_streams")] public static extern GLogWriterOutput LogWriterStandardStreams(GLogLevelFlags log_level, GLogField* fields, gsize n_fields, gpointer user_data);
	[LinkName("g_log_writer_default")] public static extern GLogWriterOutput LogWriterDefault(GLogLevelFlags log_level, GLogField* fields, gsize n_fields, gpointer user_data);
	[LinkName("g_log_writer_default_set_use_stderr")] public static extern void LogWriterDefaultSetUseStderr(gboolean use_stderr);
	[LinkName("g_log_writer_default_would_drop")] public static extern gboolean LogWriterDefaultWouldDrop(GLogLevelFlags log_level, c_char* log_domain);
	[LinkName("g_log_writer_default_set_debug_domains")] public static extern void LogWriterDefaultSetDebugDomains(gchar** domains);
	[LinkName("g_log_get_debug_enabled")] public static extern gboolean LogGetDebugEnabled();
	[LinkName("g_log_set_debug_enabled")] public static extern void LogSetDebugEnabled(gboolean enabled);
}

static
{
	[LinkName("_g_log_fallback_handler")] public static extern void GLogFallbackHandler(gchar* log_domain, GLogLevelFlags log_level, gchar* message, gpointer unused_data);
}

extension GLib
{
	[LinkName("g_return_if_fail_warning")] public static extern void ReturnIfFailWarning(c_char* log_domain, c_char* pretty_function, c_char* expression);
	[LinkName("g_warn_message")] public static extern void WarnMessage(c_char* domain, c_char* file, c_int line, c_char* func, c_char* warnexpr);
	[LinkName("g_assert_warning")] public static extern void AssertWarning(c_char* log_domain, c_char* file, c_int line, c_char* pretty_function, c_char* expression);
	[LinkName("g_log_structured_standard")] public static extern void LogStructuredStandard(gchar* log_domain, GLogLevelFlags log_level, gchar* file, gchar* line, gchar* func, gchar* message_format, ...);
}

/** GPrintFunc:
 *   @string : the message to output
 *  
 *  Specifies the type of the print handler functions.
 *  These are called with the complete formatted string to output.
 */
function void GPrintFunc(gchar* string);

extension GLib
{
	[LinkName("g_print")] public static extern void Print(gchar* format, ...);
	[LinkName("g_set_print_handler")] public static extern GPrintFunc SetPrintHandler(GPrintFunc func);
	[LinkName("g_printerr")] public static extern void Printerr(gchar* format, ...);
	[LinkName("g_set_printerr_handler")] public static extern GPrintFunc SetPrinterrHandler(GPrintFunc func);
}

struct GOptionContext;

struct GOptionGroup;


/** G_OPTION_FLAG_DEPRECATED:
 *  
 *  This flag marks the option as deprecated in the `--help`.
 *  
 *  You should update the description of the option to describe what
 *  the user should do in response to the deprecation, for instance:
 *  remove the option, or replace it with another one.
 *  
 *  Since: 2.84
 */
[AllowDuplicates] enum GOptionFlags : c_int
{
	None = 0,
	Hidden = 1 << 0,
	InMain = 1 << 1,
	Reverse = 1 << 2,
	NoArg = 1 << 3,
	Filename = 1 << 4,
	OptionalArg = 1 << 5,
	Noalias = 1 << 6,
	Deprecated = 1 << 7,
}

/** GOptionArg:
 *   @G _OPTION_ARG_NONE: No extra argument. This is useful for simple flags or booleans.
 *   @G _OPTION_ARG_STRING: The option takes a UTF-8 string argument.
 *   @G _OPTION_ARG_INT: The option takes an integer argument.
 *   @G _OPTION_ARG_CALLBACK: The option provides a callback (of type #GOptionArgFunc)
 *  to parse the extra argument.
 *   @G _OPTION_ARG_FILENAME: The option takes a filename as argument, which will
 *  be in the GLib filename encoding rather than UTF-8.
 *   @G _OPTION_ARG_STRING_ARRAY: The option takes a string argument, multiple
 *  uses of the option are collected into an array of strings.
 *   @G _OPTION_ARG_FILENAME_ARRAY: The option takes a filename as argument,
 *  multiple uses of the option are collected into an array of strings.
 *   @G _OPTION_ARG_DOUBLE: The option takes a double argument. The argument
 *  can be formatted either for the user's locale or for the "C" locale.
 *  Since 2.12
 *   @G _OPTION_ARG_INT64: The option takes a 64-bit integer. Like
 *  %G_OPTION_ARG_INT but for larger numbers. The number can be in
 *  decimal base, or in hexadecimal (when prefixed with `0x`, for
 *  example, `0xffffffff`). Since 2.12
 *  
 *  The #GOptionArg enum values determine which type of extra argument the
 *  options expect to find. If an option expects an extra argument, it can
 *  be specified in several ways; with a short option: `-x arg`, with a long
 *  option: `--name arg` or combined in a single argument: `--name=arg`.
 */
[AllowDuplicates] enum GOptionArg : c_int
{
	None = 0,
	String = 1,
	Int = 2,
	Callback = 3,
	Filename = 4,
	StringArray = 5,
	FilenameArray = 6,
	Double = 7,
	Int64 = 8,
}

/** GOptionArgFunc:
 *   @option _name: The name of the option being parsed. This will be either a
 *  single dash followed by a single letter (for a short name) or two dashes
 *  followed by a long option name.
 *   @value : The value to be parsed.
 *  @date : User data added to the #GOptionGroup containing the option when it
 *        was created with g_option_group_new()
 *         @error : A return location for errors. The error code %G_OPTION_ERROR_FAILED
 *        is intended to be used for errors in #GOptionArgFunc callbacks.
 *  
 *  The type of function to be passed as callback for %G_OPTION_ARG_CALLBACK
 *  options.
 *  
 *  Returns: %TRUE if the option was successfully parsed, %FALSE if an error
 *  occurred, in which case @error should be set with g_set_error()
 */
function gboolean GOptionArgFunc(gchar* option_name, gchar* value, gpointer data, GError** error);

/** GOptionParseFunc:
 *   @context : The active #GOptionContext
 *   @group : The group to which the function belongs
 *  @date : User data added to the #GOptionGroup containing the option when it
 *        was created with g_option_group_new()
 *         @error : A return location for error details
 *  
 *  The type of function that can be called before and after parsing.
 *  
 *  Returns: %TRUE if the function completed successfully, %FALSE if an error
 *  occurred, in which case @error should be set with g_set_error()
 */
function gboolean GOptionParseFunc(GOptionContext* context, GOptionGroup* group, gpointer data, GError** error);

/** GOptionErrorFunc:
 *   @context : The active #GOptionContext
 *   @group : The group to which the function belongs
 *  @date : User data added to the #GOptionGroup containing the option when it
 *        was created with g_option_group_new()
 *         @error : The #GError containing details about the parse error
 *  
 *  The type of function to be used as callback when a parse error occurs.
 */
function void GOptionErrorFunc(GOptionContext* context, GOptionGroup* group, gpointer data, GError** error);

/** GOptionError:
 *   @G _OPTION_ERROR_UNKNOWN_OPTION: An option was not known to the parser.
 *  This error will only be reported, if the parser hasn't been instructed
 *  to ignore unknown options, see g_option_context_set_ignore_unknown_options().
 *   @G _OPTION_ERROR_BAD_VALUE: A value couldn't be parsed.
 *   @G _OPTION_ERROR_FAILED: A #GOptionArgFunc callback failed.
 *  
 *  Error codes returned by option parsing.
 */
[AllowDuplicates] enum GOptionError : c_int
{
	UnknownOption = 0,
	BadValue = 1,
	Failed = 2,
}

extension GLib
{
	[LinkName("g_option_error_quark")] public static extern GQuark OptionErrorQuark();
}

/** GOptionEntry:
 *   @long _name: The long name of an option can be used to specify it
 *  in a commandline as `--long_name`. Every option must have a
 *  long name. To resolve conflicts if multiple option groups contain
 *  the same long name, it is also possible to specify the option as
 *  `--groupname-long_name`.
 *  @short _name: If an option has a short name, it can be specified
 *         `-short_name` in a commandline.@short _name must be  a printable
 *         ASCII character different from '-', or zero if the option has no
 *         short name.
 *          @flags : Flags from #GOptionFlags
 *         @arg : The type of the option, as a #GOptionArg
 *       @arg _data: If the@arg type is %G_OPTION_ARG_CALLBACK, then@arg _data
 *       must point to a #GOptionArgFunc callback function, which will be
 *       called to handle the extra argument. Otherwise,@arg _data is a
 *       pointer to a location to store the value, the required type of
 *       the location depends on the@arg type:
 *  
 *  - %G_OPTION_ARG_NONE: %gboolean
 *  - %G_OPTION_ARG_STRING: %gchar*
 *  - %G_OPTION_ARG_INT: %gint
 *  - %G_OPTION_ARG_FILENAME: %gchar*
 *  - %G_OPTION_ARG_STRING_ARRAY: %gchar**
 *  - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**
 *  - %G_OPTION_ARG_DOUBLE: %gdouble
 *  
 *  If@arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,
 *       the location will contain a newly allocated string if the option
 *       was given. That string needs to be freed by the callee using g_free().
 *       Likewise if@arg type is %G_OPTION_ARG_STRING_ARRAY or
 *       %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().
 *        @description : the description for the option in `--help`
 *       output. The @description is translated using the @translate _func
 *       of the group, see g_option_group_set_translation_domain().
 *       @arg _description: The placeholder to use for the extra argument parsed
 *       by the option in `--help` output. The@arg _description is translated
 *       using the @translate _func of the group, see
 *       g_option_group_set_translation_domain().
 *  
 *  A GOptionEntry struct defines a single option. To have an effect, they
 *  must be added to a #GOptionGroup with g_option_context_add_main_entries()
 *  or g_option_group_add_entries().
 */
[CRepr] struct GOptionEntry
{
	public gchar* long_name;
	public gchar short_name;
	public gint flags;
	public GOptionArg arg;
	public gpointer arg_data;
	public gchar* description;
	public gchar* arg_description;
}

extension GLib
{
	[LinkName("g_option_context_new")] public static extern GOptionContext* OptionContextNew(gchar* parameter_string);
	[LinkName("g_option_context_set_summary")] public static extern void OptionContextSetSummary(GOptionContext* context, gchar* summary);
	[LinkName("g_option_context_get_summary")] public static extern gchar* OptionContextGetSummary(GOptionContext* context);
	[LinkName("g_option_context_set_description")] public static extern void OptionContextSetDescription(GOptionContext* context, gchar* description);
	[LinkName("g_option_context_get_description")] public static extern gchar* OptionContextGetDescription(GOptionContext* context);
	[LinkName("g_option_context_free")] public static extern void OptionContextFree(GOptionContext* context);
	[LinkName("g_option_context_set_help_enabled")] public static extern void OptionContextSetHelpEnabled(GOptionContext* context, gboolean help_enabled);
	[LinkName("g_option_context_get_help_enabled")] public static extern gboolean OptionContextGetHelpEnabled(GOptionContext* context);
	[LinkName("g_option_context_set_ignore_unknown_options")] public static extern void OptionContextSetIgnoreUnknownOptions(GOptionContext* context, gboolean ignore_unknown);
	[LinkName("g_option_context_get_ignore_unknown_options")] public static extern gboolean OptionContextGetIgnoreUnknownOptions(GOptionContext* context);
	[LinkName("g_option_context_set_strict_posix")] public static extern void OptionContextSetStrictPosix(GOptionContext* context, gboolean strict_posix);
	[LinkName("g_option_context_get_strict_posix")] public static extern gboolean OptionContextGetStrictPosix(GOptionContext* context);
	[LinkName("g_option_context_add_main_entries")] public static extern void OptionContextAddMainEntries(GOptionContext* context, GOptionEntry* entries, gchar* translation_domain);
	[LinkName("g_option_context_parse")] public static extern gboolean OptionContextParse(GOptionContext* context, gint* argc, gchar*** argv, GError** error);
	[LinkName("g_option_context_parse_strv")] public static extern gboolean OptionContextParseStrv(GOptionContext* context, gchar*** arguments, GError** error);
	[LinkName("g_option_context_set_translate_func")] public static extern void OptionContextSetTranslateFunc(GOptionContext* context, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify);
	[LinkName("g_option_context_set_translation_domain")] public static extern void OptionContextSetTranslationDomain(GOptionContext* context, gchar* domain);
	[LinkName("g_option_context_add_group")] public static extern void OptionContextAddGroup(GOptionContext* context, GOptionGroup* group);
	[LinkName("g_option_context_set_main_group")] public static extern void OptionContextSetMainGroup(GOptionContext* context, GOptionGroup* group);
	[LinkName("g_option_context_get_main_group")] public static extern GOptionGroup* OptionContextGetMainGroup(GOptionContext* context);
	[LinkName("g_option_context_get_help")] public static extern gchar* OptionContextGetHelp(GOptionContext* context, gboolean main_help, GOptionGroup* group);
	[LinkName("g_option_group_new")] public static extern GOptionGroup* OptionGroupNew(gchar* name, gchar* description, gchar* help_description, gpointer user_data, GDestroyNotify destroy);
	[LinkName("g_option_group_set_parse_hooks")] public static extern void OptionGroupSetParseHooks(GOptionGroup* group, GOptionParseFunc pre_parse_func, GOptionParseFunc post_parse_func);
	[LinkName("g_option_group_set_error_hook")] public static extern void OptionGroupSetErrorHook(GOptionGroup* group, GOptionErrorFunc error_func);
	[LinkName("g_option_group_free")] public static extern void OptionGroupFree(GOptionGroup* group);
	[LinkName("g_option_group_ref")] public static extern GOptionGroup* OptionGroupRef(GOptionGroup* group);
	[LinkName("g_option_group_unref")] public static extern void OptionGroupUnref(GOptionGroup* group);
	[LinkName("g_option_group_add_entries")] public static extern void OptionGroupAddEntries(GOptionGroup* group, GOptionEntry* entries);
	[LinkName("g_option_group_set_translate_func")] public static extern void OptionGroupSetTranslateFunc(GOptionGroup* group, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify);
	[LinkName("g_option_group_set_translation_domain")] public static extern void OptionGroupSetTranslationDomain(GOptionGroup* group, gchar* domain);
}


[CRepr] struct GPathBuf
{
	public gpointer[8] dummy;
}

extension GLib
{
	[LinkName("g_path_buf_new")] public static extern GPathBuf* PathBufNew();
	[LinkName("g_path_buf_new_from_path")] public static extern GPathBuf* PathBufNewFromPath(c_char* path);
	[LinkName("g_path_buf_init")] public static extern GPathBuf* PathBufInit(GPathBuf* buf);
	[LinkName("g_path_buf_init_from_path")] public static extern GPathBuf* PathBufInitFromPath(GPathBuf* buf, c_char* path);
	[LinkName("g_path_buf_clear")] public static extern void PathBufClear(GPathBuf* buf);
	[LinkName("g_path_buf_clear_to_path")] public static extern c_char* PathBufClearToPath(GPathBuf* buf);
	[LinkName("g_path_buf_free")] public static extern void PathBufFree(GPathBuf* buf);
	[LinkName("g_path_buf_free_to_path")] public static extern c_char* PathBufFreeToPath(GPathBuf* buf);
	[LinkName("g_path_buf_copy")] public static extern GPathBuf* PathBufCopy(GPathBuf* buf);
	[LinkName("g_path_buf_push")] public static extern GPathBuf* PathBufPush(GPathBuf* buf, c_char* path);
	[LinkName("g_path_buf_pop")] public static extern gboolean PathBufPop(GPathBuf* buf);
	[LinkName("g_path_buf_set_filename")] public static extern gboolean PathBufSetFilename(GPathBuf* buf, c_char* file_name);
	[LinkName("g_path_buf_set_extension")] public static extern gboolean PathBufSetExtension(GPathBuf* buf, c_char* @extension);
	[LinkName("g_path_buf_to_path")] public static extern c_char* PathBufToPath(GPathBuf* buf);
	[LinkName("g_path_buf_equal")] public static extern gboolean PathBufEqual(gconstpointer v1, gconstpointer v2);
}

struct GPatternSpec;

extension GLib
{
	[LinkName("g_pattern_spec_new")] public static extern GPatternSpec* PatternSpecNew(gchar* pattern);
	[LinkName("g_pattern_spec_free")] public static extern void PatternSpecFree(GPatternSpec* pspec);
	[LinkName("g_pattern_spec_copy")] public static extern GPatternSpec* PatternSpecCopy(GPatternSpec* pspec);
	[LinkName("g_pattern_spec_equal")] public static extern gboolean PatternSpecEqual(GPatternSpec* pspec1, GPatternSpec* pspec2);
	[LinkName("g_pattern_spec_match")] public static extern gboolean PatternSpecMatch(GPatternSpec* pspec, gsize string_length, gchar* string, gchar* string_reversed);
	[LinkName("g_pattern_spec_match_string")] public static extern gboolean PatternSpecMatchString(GPatternSpec* pspec, gchar* string);
	[LinkName("g_pattern_match")] public static extern gboolean PatternMatch(GPatternSpec* pspec, guint string_length, gchar* string, gchar* string_reversed);
	[LinkName("g_pattern_match_string")] public static extern gboolean PatternMatchString(GPatternSpec* pspec, gchar* string);
	[LinkName("g_pattern_match_simple")] public static extern gboolean PatternMatchSimple(gchar* pattern, gchar* string);
	[LinkName("g_spaced_primes_closest")] public static extern guint SpacedPrimesClosest(guint num);
	[LinkName("g_qsort_with_data")] public static extern void QsortWithData(gconstpointer pbase, gint total_elems, gsize size, GCompareDataFunc compare_func, gpointer user_data);
	[LinkName("g_sort_array")] public static extern void SortArray(void* array, c_size n_elements, c_size element_size, GCompareDataFunc compare_func, void* user_data);
}


/** GQueue:
 *   @head : a pointer to the first element of the queue
 *   @tail : a pointer to the last element of the queue
 *   @length : the number of elements in the queue
 *  
 *  Contains the public fields of a
 *  [Queue](data-structures.html#double-ended-queues).
 */
[CRepr] struct GQueue
{
	public GList* head;
	public GList* tail;
	public guint length;
}

extension GLib
{
	[LinkName("g_queue_new")] public static extern GQueue* QueueNew();
	[LinkName("g_queue_free")] public static extern void QueueFree(GQueue* queue);
	[LinkName("g_queue_free_full")] public static extern void QueueFreeFull(GQueue* queue, GDestroyNotify free_func);
	[LinkName("g_queue_init")] public static extern void QueueInit(GQueue* queue);
	[LinkName("g_queue_clear")] public static extern void QueueClear(GQueue* queue);
	[LinkName("g_queue_is_empty")] public static extern gboolean QueueIsEmpty(GQueue* queue);
	[LinkName("g_queue_clear_full")] public static extern void QueueClearFull(GQueue* queue, GDestroyNotify free_func);
	[LinkName("g_queue_get_length")] public static extern guint QueueGetLength(GQueue* queue);
	[LinkName("g_queue_reverse")] public static extern void QueueReverse(GQueue* queue);
	[LinkName("g_queue_copy")] public static extern GQueue* QueueCopy(GQueue* queue);
	[LinkName("g_queue_foreach")] public static extern void QueueForeach(GQueue* queue, GFunc func, gpointer user_data);
	[LinkName("g_queue_find")] public static extern GList* QueueFind(GQueue* queue, gconstpointer data);
	[LinkName("g_queue_find_custom")] public static extern GList* QueueFindCustom(GQueue* queue, gconstpointer data, GCompareFunc func);
	[LinkName("g_queue_sort")] public static extern void QueueSort(GQueue* queue, GCompareDataFunc compare_func, gpointer user_data);
	[LinkName("g_queue_push_head")] public static extern void QueuePushHead(GQueue* queue, gpointer data);
	[LinkName("g_queue_push_tail")] public static extern void QueuePushTail(GQueue* queue, gpointer data);
	[LinkName("g_queue_push_nth")] public static extern void QueuePushNth(GQueue* queue, gpointer data, gint n);
	[LinkName("g_queue_pop_head")] public static extern gpointer QueuePopHead(GQueue* queue);
	[LinkName("g_queue_pop_tail")] public static extern gpointer QueuePopTail(GQueue* queue);
	[LinkName("g_queue_pop_nth")] public static extern gpointer QueuePopNth(GQueue* queue, guint n);
	[LinkName("g_queue_peek_head")] public static extern gpointer QueuePeekHead(GQueue* queue);
	[LinkName("g_queue_peek_tail")] public static extern gpointer QueuePeekTail(GQueue* queue);
	[LinkName("g_queue_peek_nth")] public static extern gpointer QueuePeekNth(GQueue* queue, guint n);
	[LinkName("g_queue_index")] public static extern gint QueueIndex(GQueue* queue, gconstpointer data);
	[LinkName("g_queue_remove")] public static extern gboolean QueueRemove(GQueue* queue, gconstpointer data);
	[LinkName("g_queue_remove_all")] public static extern guint QueueRemoveAll(GQueue* queue, gconstpointer data);
	[LinkName("g_queue_insert_before")] public static extern void QueueInsertBefore(GQueue* queue, GList* sibling, gpointer data);
	[LinkName("g_queue_insert_before_link")] public static extern void QueueInsertBeforeLink(GQueue* queue, GList* sibling, GList* link);
	[LinkName("g_queue_insert_after")] public static extern void QueueInsertAfter(GQueue* queue, GList* sibling, gpointer data);
	[LinkName("g_queue_insert_after_link")] public static extern void QueueInsertAfterLink(GQueue* queue, GList* sibling, GList* link);
	[LinkName("g_queue_insert_sorted")] public static extern void QueueInsertSorted(GQueue* queue, gpointer data, GCompareDataFunc func, gpointer user_data);
	[LinkName("g_queue_push_head_link")] public static extern void QueuePushHeadLink(GQueue* queue, GList* link);
	[LinkName("g_queue_push_tail_link")] public static extern void QueuePushTailLink(GQueue* queue, GList* link);
	[LinkName("g_queue_push_nth_link")] public static extern void QueuePushNthLink(GQueue* queue, gint n, GList* link);
	[LinkName("g_queue_pop_head_link")] public static extern GList* QueuePopHeadLink(GQueue* queue);
	[LinkName("g_queue_pop_tail_link")] public static extern GList* QueuePopTailLink(GQueue* queue);
	[LinkName("g_queue_pop_nth_link")] public static extern GList* QueuePopNthLink(GQueue* queue, guint n);
	[LinkName("g_queue_peek_head_link")] public static extern GList* QueuePeekHeadLink(GQueue* queue);
	[LinkName("g_queue_peek_tail_link")] public static extern GList* QueuePeekTailLink(GQueue* queue);
	[LinkName("g_queue_peek_nth_link")] public static extern GList* QueuePeekNthLink(GQueue* queue, guint n);
	[LinkName("g_queue_link_index")] public static extern gint QueueLinkIndex(GQueue* queue, GList* link);
	[LinkName("g_queue_unlink")] public static extern void QueueUnlink(GQueue* queue, GList* link);
	[LinkName("g_queue_delete_link")] public static extern void QueueDeleteLink(GQueue* queue, GList* link);
}

struct GRand;

extension GLib
{
	[LinkName("g_rand_new_with_seed")] public static extern GRand* RandNewWithSeed(guint32 seed);
	[LinkName("g_rand_new_with_seed_array")] public static extern GRand* RandNewWithSeedArray(guint32* seed, guint seed_length);
	[LinkName("g_rand_new")] public static extern GRand* RandNew();
	[LinkName("g_rand_free")] public static extern void RandFree(GRand* rand);
	[LinkName("g_rand_copy")] public static extern GRand* RandCopy(GRand* rand);
	[LinkName("g_rand_set_seed")] public static extern void RandSetSeed(GRand* rand, guint32 seed);
	[LinkName("g_rand_set_seed_array")] public static extern void RandSetSeedArray(GRand* rand, guint32* seed, guint seed_length);
	[LinkName("g_rand_int")] public static extern guint32 RandInt(GRand* rand);
	[LinkName("g_rand_int_range")] public static extern gint32 RandIntRange(GRand* rand, gint32 begin, gint32 end);
	[LinkName("g_rand_double")] public static extern gdouble RandDouble(GRand* rand);
	[LinkName("g_rand_double_range")] public static extern gdouble RandDoubleRange(GRand* rand, gdouble begin, gdouble end);
	[LinkName("g_random_set_seed")] public static extern void RandomSetSeed(guint32 seed);
	[LinkName("g_random_int")] public static extern guint32 RandomInt();
	[LinkName("g_random_int_range")] public static extern gint32 RandomIntRange(gint32 begin, gint32 end);
	[LinkName("g_random_double")] public static extern gdouble RandomDouble();
	[LinkName("g_random_double_range")] public static extern gdouble RandomDoubleRange(gdouble begin, gdouble end);
	[LinkName("g_rc_box_alloc")] public static extern gpointer RcBoxAlloc(gsize block_size);
	[LinkName("g_rc_box_alloc0")] public static extern gpointer RcBoxAlloc0(gsize block_size);
	[LinkName("g_rc_box_dup")] public static extern gpointer RcBoxDup(gsize block_size, gconstpointer mem_block);
	[LinkName("g_rc_box_acquire")] public static extern gpointer RcBoxAcquire(gpointer mem_block);
	[LinkName("g_rc_box_release")] public static extern void RcBoxRelease(gpointer mem_block);
	[LinkName("g_rc_box_release_full")] public static extern void RcBoxReleaseFull(gpointer mem_block, GDestroyNotify clear_func);
	[LinkName("g_rc_box_get_size")] public static extern gsize RcBoxGetSize(gpointer mem_block);
	[LinkName("g_atomic_rc_box_alloc")] public static extern gpointer AtomicRcBoxAlloc(gsize block_size);
	[LinkName("g_atomic_rc_box_alloc0")] public static extern gpointer AtomicRcBoxAlloc0(gsize block_size);
	[LinkName("g_atomic_rc_box_dup")] public static extern gpointer AtomicRcBoxDup(gsize block_size, gconstpointer mem_block);
	[LinkName("g_atomic_rc_box_acquire")] public static extern gpointer AtomicRcBoxAcquire(gpointer mem_block);
	[LinkName("g_atomic_rc_box_release")] public static extern void AtomicRcBoxRelease(gpointer mem_block);
	[LinkName("g_atomic_rc_box_release_full")] public static extern void AtomicRcBoxReleaseFull(gpointer mem_block, GDestroyNotify clear_func);
	[LinkName("g_atomic_rc_box_get_size")] public static extern gsize AtomicRcBoxGetSize(gpointer mem_block);
	[LinkName("g_ref_count_init")] public static extern void RefCountInit(grefcount* rc);
	[LinkName("g_ref_count_inc")] public static extern void RefCountInc(grefcount* rc);
	[LinkName("g_ref_count_dec")] public static extern gboolean RefCountDec(grefcount* rc);
	[LinkName("g_ref_count_compare")] public static extern gboolean RefCountCompare(grefcount* rc, gint val);
	[LinkName("g_atomic_ref_count_init")] public static extern void AtomicRefCountInit(gatomicrefcount* arc);
	[LinkName("g_atomic_ref_count_inc")] public static extern void AtomicRefCountInc(gatomicrefcount* arc);
	[LinkName("g_atomic_ref_count_dec")] public static extern gboolean AtomicRefCountDec(gatomicrefcount* arc);
	[LinkName("g_atomic_ref_count_compare")] public static extern gboolean AtomicRefCountCompare(gatomicrefcount* arc, gint val);
	[LinkName("g_ref_string_new")] public static extern c_char* RefStringNew(c_char* str);
	[LinkName("g_ref_string_new_len")] public static extern c_char* RefStringNewLen(c_char* str, gssize len);
	[LinkName("g_ref_string_new_intern")] public static extern c_char* RefStringNewIntern(c_char* str);
	[LinkName("g_ref_string_acquire")] public static extern c_char* RefStringAcquire(c_char* str);
	[LinkName("g_ref_string_release")] public static extern void RefStringRelease(c_char* str);
	[LinkName("g_ref_string_length")] public static extern gsize RefStringLength(c_char* str);
}

/** GRefString:
 *  
 *  A typedef for a reference-counted string. A pointer to a #GRefString can be
 *  treated like a standard `char*` array by all code, but can additionally have
 *  `g_ref_string_*()` methods called on it. `g_ref_string_*()` methods cannot be
 *  called on `char*` arrays not allocated using g_ref_string_new().
 *  
 *  If using #GRefString with autocleanups, g_autoptr() must be used rather than
 *  g_autofree(), so that the reference counting metadata is also freed.
 *  
 *  Since: 2.58
 */
typealias GRefString = c_char;

extension GLib
{
	[LinkName("g_ref_string_equal")] public static extern gboolean RefStringEqual(c_char* str1, c_char* str2);
}

/** GRegexError:
 *   @G _REGEX_ERROR_COMPILE: Compilation of the regular expression failed.
 *   @G _REGEX_ERROR_OPTIMIZE: Optimization of the regular expression failed.
 *   @G _REGEX_ERROR_REPLACE: Replacement failed due to an ill-formed replacement
 *  string.
 *   @G _REGEX_ERROR_MATCH: The match process failed.
 *   @G _REGEX_ERROR_INTERNAL: Internal error of the regular expression engine.
 *  Since 2.16
 *   @G _REGEX_ERROR_STRAY_BACKSLASH: "\\" at end of pattern. Since 2.16
 *   @G _REGEX_ERROR_MISSING_CONTROL_CHAR: "\\c" at end of pattern. Since 2.16
 *   @G _REGEX_ERROR_UNRECOGNIZED_ESCAPE: Unrecognized character follows "\\".
 *  Since 2.16
 *   @G _REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: Numbers out of order in "{}"
 *  quantifier. Since 2.16
 *   @G _REGEX_ERROR_QUANTIFIER_TOO_BIG: Number too big in "{}" quantifier.
 *  Since 2.16
 *   @G _REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: Missing terminating "]" for
 *  character class. Since 2.16
 *   @G _REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: Invalid escape sequence
 *  in character class. Since 2.16
 *   @G _REGEX_ERROR_RANGE_OUT_OF_ORDER: Range out of order in character class.
 *  Since 2.16
 *   @G _REGEX_ERROR_NOTHING_TO_REPEAT: Nothing to repeat. Since 2.16
 *   @G _REGEX_ERROR_UNRECOGNIZED_CHARACTER: Unrecognized character after "(?",
 *  "(?<" or "(?P". Since 2.16
 *   @G _REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: POSIX named classes are
 *  supported only within a class. Since 2.16
 *   @G _REGEX_ERROR_UNMATCHED_PARENTHESIS: Missing terminating ")" or ")"
 *  without opening "(". Since 2.16
 *   @G _REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: Reference to non-existent
 *  subpattern. Since 2.16
 *   @G _REGEX_ERROR_UNTERMINATED_COMMENT: Missing terminating ")" after comment.
 *  Since 2.16
 *   @G _REGEX_ERROR_EXPRESSION_TOO_LARGE: Regular expression too large.
 *  Since 2.16
 *   @G _REGEX_ERROR_MEMORY_ERROR: Failed to get memory. Since 2.16
 *   @G _REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: Lookbehind assertion is not
 *  fixed length. Since 2.16
 *   @G _REGEX_ERROR_MALFORMED_CONDITION: Malformed number or name after "(?(".
 *  Since 2.16
 *   @G _REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: Conditional group contains
 *  more than two branches. Since 2.16
 *   @G _REGEX_ERROR_ASSERTION_EXPECTED: Assertion expected after "(?(".
 *  Since 2.16
 *   @G _REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: Unknown POSIX class name.
 *  Since 2.16
 *   @G _REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: POSIX collating
 *  elements are not supported. Since 2.16
 *   @G _REGEX_ERROR_HEX_CODE_TOO_LARGE: Character value in "\\x{...}" sequence
 *  is too large. Since 2.16
 *   @G _REGEX_ERROR_INVALID_CONDITION: Invalid condition "(?(0)". Since 2.16
 *   @G _REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: @C not allowed in
 *  lookbehind assertion. Since 2.16
 *   @G _REGEX_ERROR_INFINITE_LOOP: Recursive call could loop indefinitely.
 *  Since 2.16
 *   @G _REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: Missing terminator
 *  in subpattern name. Since 2.16
 *   @G _REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: Two named subpatterns have
 *  the same name. Since 2.16
 *   @G _REGEX_ERROR_MALFORMED_PROPERTY: Malformed "\\P" or "\\p" sequence.
 *  Since 2.16
 *   @G _REGEX_ERROR_UNKNOWN_PROPERTY: Unknown property name after "\\P" or
 *  "\\p". Since 2.16
 *   @G _REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: Subpattern name is too long
 *  (maximum 32 characters). Since 2.16
 *   @G _REGEX_ERROR_TOO_MANY_SUBPATTERNS: Too many named subpatterns (maximum
 *  10,000). Since 2.16
 *   @G _REGEX_ERROR_INVALID_OCTAL_VALUE: Octal value is greater than "\\377".
 *  Since 2.16
 *   @G _REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: "DEFINE" group contains more
 *  than one branch. Since 2.16
 *   @G _REGEX_ERROR_DEFINE_REPETION: Repeating a "DEFINE" group is not allowed.
 *  This error is never raised. Since: 2.16 Deprecated: 2.34
 *   @G _REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: Inconsistent newline options.
 *  Since 2.16
 *   @G _REGEX_ERROR_MISSING_BACK_REFERENCE: "\\g" is not followed by a braced,
 *  angle-bracketed, or quoted name or number, or by a plain number. Since: 2.16
 *   @G _REGEX_ERROR_INVALID_RELATIVE_REFERENCE: relative reference must not be zero. Since: 2.34
 *   @G _REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: the backtracing
 *  control verb used does not allow an argument. Since: 2.34
 *   @G _REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: unknown backtracing
 *  control verb. Since: 2.34
 *   @G _REGEX_ERROR_NUMBER_TOO_BIG: number is too big in escape sequence. Since: 2.34
 *   @G _REGEX_ERROR_MISSING_SUBPATTERN_NAME: Missing subpattern name. Since: 2.34
 *   @G _REGEX_ERROR_MISSING_DIGIT: Missing digit. Since 2.34
 *   @G _REGEX_ERROR_INVALID_DATA_CHARACTER: In JavaScript compatibility mode,
 *  "[" is an invalid data character. Since: 2.34
 *   @G _REGEX_ERROR_EXTRA_SUBPATTERN_NAME: different names for subpatterns of the
 *  same number are not allowed. Since: 2.34
 *   @G _REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: the backtracing control
 *  verb requires an argument. Since: 2.34
 *   @G _REGEX_ERROR_INVALID_CONTROL_CHAR: "\\c" must be followed by an ASCII
 *  character. Since: 2.34
 *   @G _REGEX_ERROR_MISSING_NAME: "\\k" is not followed by a braced, angle-bracketed, or
 *  quoted name. Since: 2.34
 *   @G _REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: "\\N" is not supported in a class. Since: 2.34
 *   @G _REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: too many forward references. Since: 2.34
 *   @G _REGEX_ERROR_NAME_TOO_LONG: the name is too long in "(*MARK)", "(*PRUNE)",
 *  "(*SKIP)", or "(*THEN)". Since: 2.34
 *   @G _REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: the character value in the @u sequence is
 *  too large. Since: 2.34
 *  
 *  Error codes returned by regular expressions functions.
 *  
 *  Since: 2.14
 */
[AllowDuplicates] enum GRegexError : c_int
{
	Compile = 0,
	Optimize = 1,
	Replace = 2,
	Match = 3,
	Internal = 4,
	StrayBackslash = 101,
	MissingControlChar = 102,
	UnrecognizedEscape = 103,
	QuantifiersOutOfOrder = 104,
	QuantifierTooBig = 105,
	UnterminatedCharacterClass = 106,
	InvalidEscapeInCharacterClass = 107,
	RangeOutOfOrder = 108,
	NothingToRepeat = 109,
	UnrecognizedCharacter = 112,
	PosixNamedClassOutsideClass = 113,
	UnmatchedParenthesis = 114,
	InexistentSubpatternReference = 115,
	UnterminatedComment = 118,
	ExpressionTooLarge = 120,
	MemoryError = 121,
	VariableLengthLookbehind = 125,
	MalformedCondition = 126,
	TooManyConditionalBranches = 127,
	AssertionExpected = 128,
	UnknownPosixClassName = 130,
	PosixCollatingElementsNotSupported = 131,
	HexCodeTooLarge = 134,
	InvalidCondition = 135,
	SingleByteMatchInLookbehind = 136,
	InfiniteLoop = 140,
	MissingSubpatternNameTerminator = 142,
	DuplicateSubpatternName = 143,
	MalformedProperty = 146,
	UnknownProperty = 147,
	SubpatternNameTooLong = 148,
	TooManySubpatterns = 149,
	InvalidOctalValue = 151,
	TooManyBranchesInDefine = 154,
	DefineRepetion = 155,
	InconsistentNewlineOptions = 156,
	MissingBackReference = 157,
	InvalidRelativeReference = 158,
	BacktrackingControlVerbArgumentForbidden = 159,
	UnknownBacktrackingControlVerb = 160,
	NumberTooBig = 161,
	MissingSubpatternName = 162,
	MissingDigit = 163,
	InvalidDataCharacter = 164,
	ExtraSubpatternName = 165,
	BacktrackingControlVerbArgumentRequired = 166,
	InvalidControlChar = 168,
	MissingName = 169,
	NotSupportedInClass = 171,
	TooManyForwardReferences = 172,
	NameTooLong = 175,
	CharacterValueTooLarge = 176,
}

extension GLib
{
	[LinkName("g_regex_error_quark")] public static extern GQuark RegexErrorQuark();
}

/** GRegexCompileFlags:
 *   @G _REGEX_DEFAULT: No special options set. Since: 2.74
 *   @G _REGEX_CASELESS: Letters in the pattern match both upper- and
 *  lowercase letters. This option can be changed within a pattern
 *  by a "(?i)" option setting.
 *   @G _REGEX_MULTILINE: By default, GRegex treats the strings as consisting
 *  of a single line of characters (even if it actually contains
 *  newlines). The "start of line" metacharacter ("^") matches only
 *  at the start of the string, while the "end of line" metacharacter
 *  ("$") matches only at the end of the string, or before a terminating
 *  newline (unless %G_REGEX_DOLLAR_ENDONLY is set). When
 *  %G_REGEX_MULTILINE is set, the "start of line" and "end of line"
 *  constructs match immediately following or immediately before any
 *  newline in the string, respectively, as well as at the very start
 *  and end. This can be changed within a pattern by a "(?m)" option
 *  setting.
 *   @G _REGEX_DOTALL: A dot metacharacter (".") in the pattern matches all
 *  characters, including newlines. Without it, newlines are excluded.
 *  This option can be changed within a pattern by a ("?s") option setting.
 *   @G _REGEX_EXTENDED: Whitespace data characters in the pattern are
 *  totally ignored except when escaped or inside a character class.
 *  Whitespace does not include the VT character (code 11). In addition,
 *  characters between an unescaped "#" outside a character class and
 *  the next newline character, inclusive, are also ignored. This can
 *  be changed within a pattern by a "(?x)" option setting.
 *   @G _REGEX_ANCHORED: The pattern is forced to be "anchored", that is,
 *  it is constrained to match only at the first matching point in the
 *  string that is being searched. This effect can also be achieved by
 *  appropriate constructs in the pattern itself such as the "^"
 *  metacharacter.
 *   @G _REGEX_DOLLAR_ENDONLY: A dollar metacharacter ("$") in the pattern
 *  matches only at the end of the string. Without this option, a
 *  dollar also matches immediately before the final character if
 *  it is a newline (but not before any other newlines). This option
 *  is ignored if %G_REGEX_MULTILINE is set.
 *   @G _REGEX_UNGREEDY: Inverts the "greediness" of the quantifiers so that
 *  they are not greedy by default, but become greedy if followed by "?".
 *  It can also be set by a "(?U)" option setting within the pattern.
 *   @G _REGEX_RAW: Usually strings must be valid UTF-8 strings, using this
 *  flag they are considered as a raw sequence of bytes.
 *   @G _REGEX_NO_AUTO_CAPTURE: Disables the use of numbered capturing
 *  parentheses in the pattern. Any opening parenthesis that is not
 *  followed by "?" behaves as if it were followed by "?:" but named
 *  parentheses can still be used for capturing (and they acquire numbers
 *  in the usual way).
 *   @G _REGEX_OPTIMIZE: Since 2.74 and the port to pcre2, requests JIT
 *  compilation, which, if the just-in-time compiler is available, further
 *  processes a compiled pattern into machine code that executes much
 *  faster. However, it comes at the cost of extra processing before the
 *  match is performed, so it is most beneficial to use this when the same
 *  compiled pattern is used for matching many times. Before 2.74 this
 *  option used the built-in non-JIT optimizations in pcre1.
 *   @G _REGEX_FIRSTLINE: Limits an unanchored pattern to match before (or at) the
 *  first newline. Since: 2.34
 *   @G _REGEX_DUPNAMES: Names used to identify capturing subpatterns need not
 *  be unique. This can be helpful for certain types of pattern when it
 *  is known that only one instance of the named subpattern can ever be
 *  matched.
 *   @G _REGEX_NEWLINE_CR: Usually any newline character or character sequence is
 *  recognized. If this option is set, the only recognized newline character
 *  is '@r '.
 *   @G _REGEX_NEWLINE_LF: Usually any newline character or character sequence is
 *  recognized. If this option is set, the only recognized newline character
 *  is '@n '.
 *   @G _REGEX_NEWLINE_CRLF: Usually any newline character or character sequence is
 *  recognized. If this option is set, the only recognized newline character
 *  sequence is '@r @n '.
 *   @G _REGEX_NEWLINE_ANYCRLF: Usually any newline character or character sequence
 *  is recognized. If this option is set, the only recognized newline character
 *  sequences are '@r ', '@n ', and '@r @n '. Since: 2.34
 *   @G _REGEX_BSR_ANYCRLF: Usually any newline character or character sequence
 *  is recognised. If this option is set, then "\R" only recognizes the newline
 *  characters '@r ', '@n ' and '@r @n '. Since: 2.34
 *   @G _REGEX_JAVASCRIPT_COMPAT: Changes behaviour so that it is compatible with
 *  JavaScript rather than PCRE. Since GLib 2.74 this is no longer supported,
 *  as libpcre2 does not support it. Since: 2.34 Deprecated: 2.74
 *  
 *  Flags specifying compile-time options.
 *  
 *  Since: 2.14
 */
[AllowDuplicates] enum GRegexCompileFlags : c_int
{
	Default = 0,
	Aseless = 1 << 0,
	Multiline = 1 << 1,
	Dotall = 1 << 2,
	Extended = 1 << 3,
	Anchored = 1 << 4,
	DollarEndonly = 1 << 5,
	Ungreedy = 1 << 9,
	Raw = 1 << 11,
	NoAutoCapture = 1 << 12,
	Optimize = 1 << 13,
	Firstline = 1 << 18,
	Dupnames = 1 << 19,
	NewlineCr = 1 << 20,
	NewlineLf = 1 << 21,
	NewlineCrlf = NewlineCr | NewlineLf,
	NewlineAnycrlf = NewlineCr | 1 << 22,
	BsrAnycrlf = 1 << 23,
	JavascriptCompat = 1 << 25,
}

/** GRegexMatchFlags:
 *   @G _REGEX_MATCH_DEFAULT: No special options set. Since: 2.74
 *   @G _REGEX_MATCH_ANCHORED: The pattern is forced to be "anchored", that is,
 *  it is constrained to match only at the first matching point in the
 *  string that is being searched. This effect can also be achieved by
 *  appropriate constructs in the pattern itself such as the "^"
 *  metacharacter.
 *   @G _REGEX_MATCH_NOTBOL: Specifies that first character of the string is
 *  not the beginning of a line, so the circumflex metacharacter should
 *  not match before it. Setting this without %G_REGEX_MULTILINE (at
 *  compile time) causes circumflex never to match. This option affects
 *  only the behaviour of the circumflex metacharacter, it does not
 *  affect "\A".
 *   @G _REGEX_MATCH_NOTEOL: Specifies that the end of the subject string is
 *  not the end of a line, so the dollar metacharacter should not match
 *  it nor (except in multiline mode) a newline immediately before it.
 *  Setting this without %G_REGEX_MULTILINE (at compile time) causes
 *  dollar never to match. This option affects only the behaviour of
 *  the dollar metacharacter, it does not affect "\Z" or "\z".
 *   @G _REGEX_MATCH_NOTEMPTY: An empty string is not considered to be a valid
 *  match if this option is set. If there are alternatives in the pattern,
 *  they are tried. If all the alternatives match the empty string, the
 *  entire match fails. For example, if the pattern "a?b?" is applied to
 *  a string not beginning with "a" or "b", it matches the empty string
 *  at the start of the string. With this flag set, this match is not
 *  valid, so GRegex searches further into the string for occurrences
 *  of "a" or "b".
 *   @G _REGEX_MATCH_PARTIAL: Turns on the partial matching feature, for more
 *  documentation on partial matching see g_match_info_is_partial_match().
 *   @G _REGEX_MATCH_NEWLINE_CR: Overrides the newline definition set when
 *  creating a new #GRegex, setting the '@r ' character as line terminator.
 *   @G _REGEX_MATCH_NEWLINE_LF: Overrides the newline definition set when
 *  creating a new #GRegex, setting the '@n ' character as line terminator.
 *   @G _REGEX_MATCH_NEWLINE_CRLF: Overrides the newline definition set when
 *  creating a new #GRegex, setting the '@r @n ' characters sequence as line terminator.
 *   @G _REGEX_MATCH_NEWLINE_ANY: Overrides the newline definition set when
 *  creating a new #GRegex, any Unicode newline sequence
 *  is recognised as a newline. These are '@r ', '@n ' and '@rn ', and the
 *  single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),
 *  U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and
 *  U+2029 PARAGRAPH SEPARATOR.
 *   @G _REGEX_MATCH_NEWLINE_ANYCRLF: Overrides the newline definition set when
 *  creating a new #GRegex; any '@r ', '@n ', or '@r @n ' character sequence
 *  is recognized as a newline. Since: 2.34
 *   @G _REGEX_MATCH_BSR_ANYCRLF: Overrides the newline definition for "\R" set when
 *  creating a new #GRegex; only '@r ', '@n ', or '@r @n ' character sequences
 *  are recognized as a newline by "\R". Since: 2.34
 *   @G _REGEX_MATCH_BSR_ANY: Overrides the newline definition for "\R" set when
 *  creating a new #GRegex; any Unicode newline character or character sequence
 *  are recognized as a newline by "\R". These are '@r ', '@n ' and '@rn ', and the
 *  single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),
 *  U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and
 *  U+2029 PARAGRAPH SEPARATOR. Since: 2.34
 *   @G _REGEX_MATCH_PARTIAL_SOFT: An alias for %G_REGEX_MATCH_PARTIAL. Since: 2.34
 *   @G _REGEX_MATCH_PARTIAL_HARD: Turns on the partial matching feature. In contrast to
 *  to %G_REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a partial match
 *  is found, without continuing to search for a possible complete match. See
 *  g_match_info_is_partial_match() for more information. Since: 2.34
 *   @G _REGEX_MATCH_NOTEMPTY_ATSTART: Like %G_REGEX_MATCH_NOTEMPTY, but only applied to
 *  the start of the matched string. For anchored
 *  patterns this can only happen for pattern containing "\K". Since: 2.34
 *  
 *  Flags specifying match-time options.
 *  
 *  Since: 2.14
 */
[AllowDuplicates] enum GRegexMatchFlags : c_int
{
	Default = 0,
	Anchored = 1 << 4,
	Notbol = 1 << 7,
	Noteol = 1 << 8,
	Notempty = 1 << 10,
	Partial = 1 << 15,
	NewlineCr = 1 << 20,
	NewlineLf = 1 << 21,
	NewlineCrlf = NewlineCr | NewlineLf,
	NewlineAny = 1 << 22,
	NewlineAnycrlf = NewlineCr | NewlineAny,
	BsrAnycrlf = 1 << 23,
	BsrAny = 1 << 24,
	PartialSoft = Partial,
	PartialHard = 1 << 27,
	NotemptyAtstart = 1 << 28,
}

struct GRegex;

struct GMatchInfo;

/** GRegexEvalCallback:
 *   @match _info: the #GMatchInfo generated by the match.
 *  Use g_match_info_get_regex() and g_match_info_get_string() if you
 *  need the #GRegex or the matched string.
 *  @result : a #GString containing the new string
 *           @user _data: user data passed to g_regex_replace_eval()
 *  
 *  Specifies the type of the function passed to g_regex_replace_eval().
 *  It is called for each occurrence of the pattern in the string passed
 *  to g_regex_replace_eval(), and it should append the replacement to
 *  @result .
 *  
 *  Returns: %FALSE to continue the replacement process, %TRUE to stop it
 *  
 *  Since: 2.14
 */
function gboolean GRegexEvalCallback(GMatchInfo* match_info, GString* result, gpointer user_data);

extension GLib
{
	[LinkName("g_regex_new")] public static extern GRegex* RegexNew(gchar* pattern, GRegexCompileFlags compile_options, GRegexMatchFlags match_options, GError** error);
	[LinkName("g_regex_ref")] public static extern GRegex* RegexRef(GRegex* regex);
	[LinkName("g_regex_unref")] public static extern void RegexUnref(GRegex* regex);
	[LinkName("g_regex_get_pattern")] public static extern gchar* RegexGetPattern(GRegex* regex);
	[LinkName("g_regex_get_max_backref")] public static extern gint RegexGetMaxBackref(GRegex* regex);
	[LinkName("g_regex_get_capture_count")] public static extern gint RegexGetCaptureCount(GRegex* regex);
	[LinkName("g_regex_get_has_cr_or_lf")] public static extern gboolean RegexGetHasCrOrLf(GRegex* regex);
	[LinkName("g_regex_get_max_lookbehind")] public static extern gint RegexGetMaxLookbehind(GRegex* regex);
	[LinkName("g_regex_get_string_number")] public static extern gint RegexGetStringNumber(GRegex* regex, gchar* name);
	[LinkName("g_regex_escape_string")] public static extern gchar* RegexEscapeString(gchar* string, gint length);
	[LinkName("g_regex_escape_nul")] public static extern gchar* RegexEscapeNul(gchar* string, gint length);
	[LinkName("g_regex_get_compile_flags")] public static extern GRegexCompileFlags RegexGetCompileFlags(GRegex* regex);
	[LinkName("g_regex_get_match_flags")] public static extern GRegexMatchFlags RegexGetMatchFlags(GRegex* regex);
	[LinkName("g_regex_match_simple")] public static extern gboolean RegexMatchSimple(gchar* pattern, gchar* string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options);
	[LinkName("g_regex_match")] public static extern gboolean RegexMatch(GRegex* regex, gchar* string, GRegexMatchFlags match_options, GMatchInfo** match_info);
	[LinkName("g_regex_match_full")] public static extern gboolean RegexMatchFull(GRegex* regex, gchar* string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo** match_info, GError** error);
	[LinkName("g_regex_match_all")] public static extern gboolean RegexMatchAll(GRegex* regex, gchar* string, GRegexMatchFlags match_options, GMatchInfo** match_info);
	[LinkName("g_regex_match_all_full")] public static extern gboolean RegexMatchAllFull(GRegex* regex, gchar* string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo** match_info, GError** error);
	[LinkName("g_regex_split_simple")] public static extern gchar** RegexSplitSimple(gchar* pattern, gchar* string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options);
	[LinkName("g_regex_split")] public static extern gchar** RegexSplit(GRegex* regex, gchar* string, GRegexMatchFlags match_options);
	[LinkName("g_regex_split_full")] public static extern gchar** RegexSplitFull(GRegex* regex, gchar* string, gssize string_len, gint start_position, GRegexMatchFlags match_options, gint max_tokens, GError** error);
	[LinkName("g_regex_replace")] public static extern gchar* RegexReplace(GRegex* regex, gchar* string, gssize string_len, gint start_position, gchar* replacement, GRegexMatchFlags match_options, GError** error);
	[LinkName("g_regex_replace_literal")] public static extern gchar* RegexReplaceLiteral(GRegex* regex, gchar* string, gssize string_len, gint start_position, gchar* replacement, GRegexMatchFlags match_options, GError** error);
	[LinkName("g_regex_replace_eval")] public static extern gchar* RegexReplaceEval(GRegex* regex, gchar* string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GRegexEvalCallback eval, gpointer user_data, GError** error);
	[LinkName("g_regex_check_replacement")] public static extern gboolean RegexCheckReplacement(gchar* replacement, gboolean* has_references, GError** error);
	[LinkName("g_match_info_get_regex")] public static extern GRegex* MatchInfoGetRegex(GMatchInfo* match_info);
	[LinkName("g_match_info_get_string")] public static extern gchar* MatchInfoGetString(GMatchInfo* match_info);
	[LinkName("g_match_info_ref")] public static extern GMatchInfo* MatchInfoRef(GMatchInfo* match_info);
	[LinkName("g_match_info_unref")] public static extern void MatchInfoUnref(GMatchInfo* match_info);
	[LinkName("g_match_info_free")] public static extern void MatchInfoFree(GMatchInfo* match_info);
	[LinkName("g_match_info_next")] public static extern gboolean MatchInfoNext(GMatchInfo* match_info, GError** error);
	[LinkName("g_match_info_matches")] public static extern gboolean MatchInfoMatches(GMatchInfo* match_info);
	[LinkName("g_match_info_get_match_count")] public static extern gint MatchInfoGetMatchCount(GMatchInfo* match_info);
	[LinkName("g_match_info_is_partial_match")] public static extern gboolean MatchInfoIsPartialMatch(GMatchInfo* match_info);
	[LinkName("g_match_info_expand_references")] public static extern gchar* MatchInfoExpandReferences(GMatchInfo* match_info, gchar* string_to_expand, GError** error);
	[LinkName("g_match_info_fetch")] public static extern gchar* MatchInfoFetch(GMatchInfo* match_info, gint match_num);
	[LinkName("g_match_info_fetch_pos")] public static extern gboolean MatchInfoFetchPos(GMatchInfo* match_info, gint match_num, gint* start_pos, gint* end_pos);
	[LinkName("g_match_info_fetch_named")] public static extern gchar* MatchInfoFetchNamed(GMatchInfo* match_info, gchar* name);
	[LinkName("g_match_info_fetch_named_pos")] public static extern gboolean MatchInfoFetchNamedPos(GMatchInfo* match_info, gchar* name, gint* start_pos, gint* end_pos);
	[LinkName("g_match_info_fetch_all")] public static extern gchar** MatchInfoFetchAll(GMatchInfo* match_info);
}




function void GScannerMsgFunc(GScanner* scanner, gchar* message, gboolean error);

[AllowDuplicates] enum GErrorType : c_int
{
	Unknown = 0,
	UnexpEof = 1,
	UnexpEofInString = 2,
	UnexpEofInComment = 3,
	NonDigitInConst = 4,
	DigitRadix = 5,
	FloatRadix = 6,
	FloatMalformed = 7,
}

[AllowDuplicates] enum GTokenType : c_int
{
	Eof = 0,
	LeftParen = '(',
	RightParen = ')',
	LeftCurly = '{',
	RightCurly = '}',
	LeftBrace = '[',
	RightBrace = ']',
	EqualSign = '=',
	Comma = ',',
	None = 256,
	Error = 257,
	Char = 258,
	Binary = 259,
	Octal = 260,
	Int = 261,
	Hex = 262,
	Float = 263,
	String = 264,
	Symbol = 265,
	Identifier = 266,
	IdentifierNull = 267,
	CommentSingle = 268,
	CommentMulti = 269,
	Last = 270,
}

[Union, CRepr] struct GTokenValue
{
	public gpointer v_symbol;
	public gchar* v_identifier;
	public gulong v_binary;
	public gulong v_octal;
	public gulong v_int;
	public guint64 v_int64;
	public gdouble v_float;
	public gulong v_hex;
	public gchar* v_string;
	public gchar* v_comment;
	public guchar v_char;
	public guint v_error;
}

[CRepr] struct GScannerConfig
{
	public gchar* cset_skip_characters;
	public gchar* cset_identifier_first;
	public gchar* cset_identifier_nth;
	public gchar* cpair_comment_single;
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 0), "case_sensitive")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 1), "skip_comment_multi")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 2), "skip_comment_single")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 3), "scan_comment_multi")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 4), "scan_identifier")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 5), "scan_identifier_1char")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 6), "scan_identifier_NULL")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 7), "scan_symbols")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 8), "scan_binary")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 9), "scan_octal")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 10), "scan_float")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 11), "scan_hex")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 12), "scan_hex_dollar")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 13), "scan_string_sq")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 14), "scan_string_dq")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 15), "numbers_2_int")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 16), "int_2_float")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 17), "identifier_2_string")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 18), "char_2_token")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 19), "symbol_2_token")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 20), "scope_0_fallback")]
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 21), "store_int64")]
	private uint32 __bitfield_1742759;
	public guint padding_dummy;
}

[CRepr] struct GScanner
{
	public gpointer user_data;
	public guint max_parse_errors;
	public guint parse_errors;
	public gchar* input_name;
	public GData* qdata;
	public GScannerConfig* config;
	public GTokenType token;
	public GTokenValue value;
	public guint line;
	public guint position;
	public GTokenType next_token;
	public GTokenValue next_value;
	public guint next_line;
	public guint next_position;
	public GHashTable* symbol_table;
	public gint input_fd;
	public gchar* text;
	public gchar* text_end;
	public gchar* buffer;
	public guint scope_id;
	public GScannerMsgFunc msg_handler;
}

extension GLib
{
	[LinkName("g_scanner_new")] public static extern GScanner* ScannerNew(GScannerConfig* config_templ);
	[LinkName("g_scanner_destroy")] public static extern void ScannerDestroy(GScanner* scanner);
	[LinkName("g_scanner_input_file")] public static extern void ScannerInputFile(GScanner* scanner, gint input_fd);
	[LinkName("g_scanner_sync_file_offset")] public static extern void ScannerSyncFileOffset(GScanner* scanner);
	[LinkName("g_scanner_input_text")] public static extern void ScannerInputText(GScanner* scanner, gchar* text, guint text_len);
	[LinkName("g_scanner_get_next_token")] public static extern GTokenType ScannerGetNextToken(GScanner* scanner);
	[LinkName("g_scanner_peek_next_token")] public static extern GTokenType ScannerPeekNextToken(GScanner* scanner);
	[LinkName("g_scanner_cur_token")] public static extern GTokenType ScannerCurToken(GScanner* scanner);
	[LinkName("g_scanner_cur_value")] public static extern GTokenValue ScannerCurValue(GScanner* scanner);
	[LinkName("g_scanner_cur_line")] public static extern guint ScannerCurLine(GScanner* scanner);
	[LinkName("g_scanner_cur_position")] public static extern guint ScannerCurPosition(GScanner* scanner);
	[LinkName("g_scanner_eof")] public static extern gboolean ScannerEof(GScanner* scanner);
	[LinkName("g_scanner_set_scope")] public static extern guint ScannerSetScope(GScanner* scanner, guint scope_id);
	[LinkName("g_scanner_scope_add_symbol")] public static extern void ScannerScopeAddSymbol(GScanner* scanner, guint scope_id, gchar* symbol, gpointer value);
	[LinkName("g_scanner_scope_remove_symbol")] public static extern void ScannerScopeRemoveSymbol(GScanner* scanner, guint scope_id, gchar* symbol);
	[LinkName("g_scanner_scope_lookup_symbol")] public static extern gpointer ScannerScopeLookupSymbol(GScanner* scanner, guint scope_id, gchar* symbol);
	[LinkName("g_scanner_scope_foreach_symbol")] public static extern void ScannerScopeForeachSymbol(GScanner* scanner, guint scope_id, GHFunc func, gpointer user_data);
	[LinkName("g_scanner_lookup_symbol")] public static extern gpointer ScannerLookupSymbol(GScanner* scanner, gchar* symbol);
	[LinkName("g_scanner_unexp_token")] public static extern void ScannerUnexpToken(GScanner* scanner, GTokenType expected_token, gchar* identifier_spec, gchar* symbol_spec, gchar* symbol_name, gchar* message, gint is_error);
	[LinkName("g_scanner_error")] public static extern void ScannerError(GScanner* scanner, gchar* format, ...);
	[LinkName("g_scanner_warn")] public static extern void ScannerWarn(GScanner* scanner, gchar* format, ...);
}

struct GSequence;

struct GSequenceNode;
typealias GSequenceIter = GSequenceNode;

function gint GSequenceIterCompareFunc(GSequenceIter* a, GSequenceIter* b, gpointer data);

extension GLib
{
	[LinkName("g_sequence_new")] public static extern GSequence* SequenceNew(GDestroyNotify data_destroy);
	[LinkName("g_sequence_free")] public static extern void SequenceFree(GSequence* seq);
	[LinkName("g_sequence_get_length")] public static extern gint SequenceGetLength(GSequence* seq);
	[LinkName("g_sequence_foreach")] public static extern void SequenceForeach(GSequence* seq, GFunc func, gpointer user_data);
	[LinkName("g_sequence_foreach_range")] public static extern void SequenceForeachRange(GSequenceIter* begin, GSequenceIter* end, GFunc func, gpointer user_data);
	[LinkName("g_sequence_sort")] public static extern void SequenceSort(GSequence* seq, GCompareDataFunc cmp_func, gpointer cmp_data);
	[LinkName("g_sequence_sort_iter")] public static extern void SequenceSortIter(GSequence* seq, GSequenceIterCompareFunc cmp_func, gpointer cmp_data);
	[LinkName("g_sequence_is_empty")] public static extern gboolean SequenceIsEmpty(GSequence* seq);
	[LinkName("g_sequence_get_begin_iter")] public static extern GSequenceIter* SequenceGetBeginIter(GSequence* seq);
	[LinkName("g_sequence_get_end_iter")] public static extern GSequenceIter* SequenceGetEndIter(GSequence* seq);
	[LinkName("g_sequence_get_iter_at_pos")] public static extern GSequenceIter* SequenceGetIterAtPos(GSequence* seq, gint pos);
	[LinkName("g_sequence_append")] public static extern GSequenceIter* SequenceAppend(GSequence* seq, gpointer data);
	[LinkName("g_sequence_prepend")] public static extern GSequenceIter* SequencePrepend(GSequence* seq, gpointer data);
	[LinkName("g_sequence_insert_before")] public static extern GSequenceIter* SequenceInsertBefore(GSequenceIter* iter, gpointer data);
	[LinkName("g_sequence_move")] public static extern void SequenceMove(GSequenceIter* src, GSequenceIter* dest);
	[LinkName("g_sequence_swap")] public static extern void SequenceSwap(GSequenceIter* a, GSequenceIter* b);
	[LinkName("g_sequence_insert_sorted")] public static extern GSequenceIter* SequenceInsertSorted(GSequence* seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
	[LinkName("g_sequence_insert_sorted_iter")] public static extern GSequenceIter* SequenceInsertSortedIter(GSequence* seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
	[LinkName("g_sequence_sort_changed")] public static extern void SequenceSortChanged(GSequenceIter* iter, GCompareDataFunc cmp_func, gpointer cmp_data);
	[LinkName("g_sequence_sort_changed_iter")] public static extern void SequenceSortChangedIter(GSequenceIter* iter, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
	[LinkName("g_sequence_remove")] public static extern void SequenceRemove(GSequenceIter* iter);
	[LinkName("g_sequence_remove_range")] public static extern void SequenceRemoveRange(GSequenceIter* begin, GSequenceIter* end);
	[LinkName("g_sequence_move_range")] public static extern void SequenceMoveRange(GSequenceIter* dest, GSequenceIter* begin, GSequenceIter* end);
	[LinkName("g_sequence_search")] public static extern GSequenceIter* SequenceSearch(GSequence* seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
	[LinkName("g_sequence_search_iter")] public static extern GSequenceIter* SequenceSearchIter(GSequence* seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
	[LinkName("g_sequence_lookup")] public static extern GSequenceIter* SequenceLookup(GSequence* seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
	[LinkName("g_sequence_lookup_iter")] public static extern GSequenceIter* SequenceLookupIter(GSequence* seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
	[LinkName("g_sequence_get")] public static extern gpointer SequenceGet(GSequenceIter* iter);
	[LinkName("g_sequence_set")] public static extern void SequenceSet(GSequenceIter* iter, gpointer data);
	[LinkName("g_sequence_iter_is_begin")] public static extern gboolean SequenceIterIsBegin(GSequenceIter* iter);
	[LinkName("g_sequence_iter_is_end")] public static extern gboolean SequenceIterIsEnd(GSequenceIter* iter);
	[LinkName("g_sequence_iter_next")] public static extern GSequenceIter* SequenceIterNext(GSequenceIter* iter);
	[LinkName("g_sequence_iter_prev")] public static extern GSequenceIter* SequenceIterPrev(GSequenceIter* iter);
	[LinkName("g_sequence_iter_get_position")] public static extern gint SequenceIterGetPosition(GSequenceIter* iter);
	[LinkName("g_sequence_iter_move")] public static extern GSequenceIter* SequenceIterMove(GSequenceIter* iter, gint delta);
	[LinkName("g_sequence_iter_get_sequence")] public static extern GSequence* SequenceIterGetSequence(GSequenceIter* iter);
	[LinkName("g_sequence_iter_compare")] public static extern gint SequenceIterCompare(GSequenceIter* a, GSequenceIter* b);
	[LinkName("g_sequence_range_get_midpoint")] public static extern GSequenceIter* SequenceRangeGetMidpoint(GSequenceIter* begin, GSequenceIter* end);
}

[AllowDuplicates] enum GShellError : c_int
{
	BadQuoting = 0,
	EmptyString = 1,
	Failed = 2,
}

extension GLib
{
	[LinkName("g_shell_error_quark")] public static extern GQuark ShellErrorQuark();
	[LinkName("g_shell_quote")] public static extern gchar* ShellQuote(gchar* unquoted_string);
	[LinkName("g_shell_unquote")] public static extern gchar* ShellUnquote(gchar* quoted_string, GError** error);
	[LinkName("g_shell_parse_argv")] public static extern gboolean ShellParseArgv(gchar* command_line, gint* argcp, gchar*** argvp, GError** error);
	[LinkName("g_slice_alloc")] public static extern gpointer SliceAlloc(gsize block_size);
	[LinkName("g_slice_alloc0")] public static extern gpointer SliceAlloc0(gsize block_size);
	[LinkName("g_slice_copy")] public static extern gpointer SliceCopy(gsize block_size, gconstpointer mem_block);
	[LinkName("g_slice_free1")] public static extern void SliceFree1(gsize block_size, gpointer mem_block);
	[LinkName("g_slice_free_chain_with_offset")] public static extern void SliceFreeChainWithOffset(gsize block_size, gpointer mem_chain, gsize next_offset);
}

[AllowDuplicates] enum GSliceConfig : c_int
{
	AlwaysMalloc = 1,
	BypassMagazines = 2,
	WorkingSetMsecs = 3,
	ColorIncrement = 4,
	ChunkSizes = 5,
	ContentionCounter = 6,
}

extension GLib
{
	[LinkName("g_slice_set_config")] public static extern void SliceSetConfig(GSliceConfig ckey, gint64 value);
	[LinkName("g_slice_get_config")] public static extern gint64 SliceGetConfig(GSliceConfig ckey);
	[LinkName("g_slice_get_config_state")] public static extern gint64* SliceGetConfigState(GSliceConfig ckey, gint64 address, guint* n_values);
}

/** GSpawnError:
 *   @G _SPAWN_ERROR_FORK: Fork failed due to lack of memory.
 *   @G _SPAWN_ERROR_READ: Read or select on pipes failed.
 *   @G _SPAWN_ERROR_CHDIR: Changing to working directory failed.
 *   @G _SPAWN_ERROR_ACCES: execv() returned `EACCES`
 *   @G _SPAWN_ERROR_PERM: execv() returned `EPERM`
 *   @G _SPAWN_ERROR_TOO_BIG: execv() returned `E2BIG`
 *   @G _SPAWN_ERROR_2BIG: deprecated alias for %G_SPAWN_ERROR_TOO_BIG (deprecated since GLib 2.32)
 *   @G _SPAWN_ERROR_NOEXEC: execv() returned `ENOEXEC`
 *   @G _SPAWN_ERROR_NAMETOOLONG: execv() returned `ENAMETOOLONG`
 *   @G _SPAWN_ERROR_NOENT: execv() returned `ENOENT`
 *   @G _SPAWN_ERROR_NOMEM: execv() returned `ENOMEM`
 *   @G _SPAWN_ERROR_NOTDIR: execv() returned `ENOTDIR`
 *   @G _SPAWN_ERROR_LOOP: execv() returned `ELOOP`
 *   @G _SPAWN_ERROR_TXTBUSY: execv() returned `ETXTBUSY`
 *   @G _SPAWN_ERROR_IO: execv() returned `EIO`
 *   @G _SPAWN_ERROR_NFILE: execv() returned `ENFILE`
 *   @G _SPAWN_ERROR_MFILE: execv() returned `EMFILE`
 *   @G _SPAWN_ERROR_INVAL: execv() returned `EINVAL`
 *   @G _SPAWN_ERROR_ISDIR: execv() returned `EISDIR`
 *   @G _SPAWN_ERROR_LIBBAD: execv() returned `ELIBBAD`
 *   @G _SPAWN_ERROR_FAILED: Some other fatal failure,
 *  `error->message` should explain.
 *  
 *  Error codes returned by spawning processes.
 */
[AllowDuplicates] enum GSpawnError : c_int
{
	Fork = 0,
	Read = 1,
	Chdir = 2,
	Acces = 3,
	Perm = 4,
	TooBig = 5,
	_2big = TooBig,
	Noexec = 6,
	Nametoolong = 7,
	Noent = 8,
	Nomem = 9,
	Notdir = 10,
	Loop = 11,
	Txtbusy = 12,
	Io = 13,
	Nfile = 14,
	Mfile = 15,
	Inval = 16,
	Isdir = 17,
	Libbad = 18,
	Failed = 19,
}

/** GSpawnChildSetupFunc:
 *  @date : user data passed to the function.
 *  
 *  Specifies the type of the setup function passed to g_spawn_async(),
 *  g_spawn_sync() and g_spawn_async_with_pipes(), which can, in very
 *  limited ways, be used to affect the child's execution.
 *  
 *  On POSIX platforms, the function is called in the child after GLib
 *  has performed all the setup it plans to perform, but before calling
 *  exec(). Actions taken in this function will only affect the child,
 *  not the parent.
 *  
 *  On Windows, the function is called in the parent. Its usefulness on
 *  Windows is thus questionable. In many cases executing the child setup
 *  function in the parent can have ill effects, and you should be very
 *  careful when porting software to Windows that uses child setup
 *  functions.
 *  
 *  However, even on POSIX, you are extremely limited in what you can
 *  safely do from a #GSpawnChildSetupFunc, because any mutexes that were
 *  held by other threads in the parent process at the time of the fork()
 *  will still be locked in the child process, and they will never be
 *  unlocked (since the threads that held them don't exist in the child).
 *  POSIX allows only async-signal-safe functions (see signal(7)) to be
 *  called in the child between fork() and exec(), which drastically limits
 *  the usefulness of child setup functions.
 *  
 *  In particular, it is not safe to call any function which may
 *  call malloc(), which includes POSIX functions such as setenv().
 *  If you need to set up the child environment differently from
 *  the parent, you should use g_get_environ(), g_environ_setenv(),
 *  and g_environ_unsetenv(), and then pass the complete environment
 *  list to the `g_spawn...` function.
 */
function void GSpawnChildSetupFunc(gpointer data);

/** GSpawnFlags:
 *   @G _SPAWN_DEFAULT: no flags, default behaviour
 *   @G _SPAWN_LEAVE_DESCRIPTORS_OPEN: the parent's open file descriptors will
 *  be inherited by the child; otherwise all descriptors except stdin,
 *  stdout and stderr will be closed before calling exec() in the child.
 *   @G _SPAWN_DO_NOT_REAP_CHILD: the child will not be automatically reaped;
 *  you must use g_child_watch_add() yourself (or call waitpid() or handle
 *  `SIGCHLD` yourself), or the child will become a zombie.
 *   @G _SPAWN_SEARCH_PATH: `argv[0]` need not be an absolute path, it will be
 *  looked for in the user's `PATH`.
 *   @G _SPAWN_STDOUT_TO_DEV_NULL: the child's standard output will be discarded,
 *  instead of going to the same location as the parent's standard output.
 *   @G _SPAWN_STDERR_TO_DEV_NULL: the child's standard error will be discarded.
 *   @G _SPAWN_CHILD_INHERITS_STDIN: the child will inherit the parent's standard
 *  input (by default, the child's standard input is attached to `/dev/null`).
 *   @G _SPAWN_FILE_AND_ARGV_ZERO: the first element of `argv` is the file to
 *  execute, while the remaining elements are the actual argument vector
 *  to pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]`
 *  as the file to execute, and passes all of `argv` to the child.
 *   @G _SPAWN_SEARCH_PATH_FROM_ENVP: if `argv[0]` is not an absolute path,
 *  it will be looked for in the `PATH` from the passed child environment.
 *  Since: 2.34
 *   @G _SPAWN_CLOEXEC_PIPES: create all pipes with the `O_CLOEXEC` flag set.
 *  Since: 2.40
 *   @G _SPAWN_CHILD_INHERITS_STDOUT: the child will inherit the parent's standard output.
 *  Since: 2.74
 *   @G _SPAWN_CHILD_INHERITS_STDERR: the child will inherit the parent's standard error.
 *  Since: 2.74
 *   @G _SPAWN_STDIN_FROM_DEV_NULL: the child's standard input is attached to `/dev/null`.
 *  Since: 2.74
 *  
 *  Flags passed to g_spawn_sync(), g_spawn_async() and g_spawn_async_with_pipes().
 */
[AllowDuplicates] enum GSpawnFlags : c_int
{
	Default = 0,
	LeaveDescriptorsOpen = 1 << 0,
	DoNotReapChild = 1 << 1,
	SearchPath = 1 << 2,
	StdoutToDevNull = 1 << 3,
	StderrToDevNull = 1 << 4,
	ChildInheritsStdin = 1 << 5,
	IleAndArgvZero = 1 << 6,
	SearchPathFromEnvp = 1 << 7,
	CloexecPipes = 1 << 8,

	/** G_SPAWN_CHILD_INHERITS_STDOUT:
	 *  
	 *  The child will inherit the parent's standard output.
	 *  
	 *  Since: 2.74
	 */
	ChildInheritsStdout = 1 << 9,

	/** G_SPAWN_CHILD_INHERITS_STDERR:
	 *  
	 *  The child will inherit the parent's standard error.
	 *  
	 *  Since: 2.74
	 */
	ChildInheritsStderr = 1 << 10,

	/** G_SPAWN_STDIN_FROM_DEV_NULL:
	 *  
	 *  The child's standard input is attached to `/dev/null`.
	 *  
	 *  Since: 2.74
	 */
	StdinFromDevNull = 1 << 11,
}

extension GLib
{
	[LinkName("g_spawn_error_quark")] public static extern GQuark SpawnErrorQuark();
	[LinkName("g_spawn_exit_error_quark")] public static extern GQuark SpawnExitErrorQuark();
	[LinkName("g_spawn_async")] public static extern gboolean SpawnAsync(gchar* working_directory, gchar** argv, gchar** envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid* child_pid, GError** error);
	[LinkName("g_spawn_async_with_pipes")] public static extern gboolean SpawnAsyncWithPipes(gchar* working_directory, gchar** argv, gchar** envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid* child_pid, gint* standard_input, gint* standard_output, gint* standard_error, GError** error);
	[LinkName("g_spawn_async_with_pipes_and_fds")] public static extern gboolean SpawnAsyncWithPipesAndFds(gchar* working_directory, gchar** argv, gchar** envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gint stdin_fd, gint stdout_fd, gint stderr_fd, gint* source_fds, gint* target_fds, gsize n_fds, GPid* child_pid_out, gint* stdin_pipe_out, gint* stdout_pipe_out, gint* stderr_pipe_out, GError** error);
	[LinkName("g_spawn_async_with_fds")] public static extern gboolean SpawnAsyncWithFds(gchar* working_directory, gchar** argv, gchar** envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid* child_pid, gint stdin_fd, gint stdout_fd, gint stderr_fd, GError** error);
	[LinkName("g_spawn_sync")] public static extern gboolean SpawnSync(gchar* working_directory, gchar** argv, gchar** envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gchar** standard_output, gchar** standard_error, gint* wait_status, GError** error);
	[LinkName("g_spawn_command_line_sync")] public static extern gboolean SpawnCommandLineSync(gchar* command_line, gchar** standard_output, gchar** standard_error, gint* wait_status, GError** error);
	[LinkName("g_spawn_command_line_async")] public static extern gboolean SpawnCommandLineAsync(gchar* command_line, GError** error);
	[LinkName("g_spawn_check_wait_status")] public static extern gboolean SpawnCheckWaitStatus(gint wait_status, GError** error);
	[LinkName("g_spawn_check_exit_status")] public static extern gboolean SpawnCheckExitStatus(gint wait_status, GError** error);
	[LinkName("g_spawn_close_pid")] public static extern void SpawnClosePid(GPid pid);
}

struct GStringChunk;

extension GLib
{
	[LinkName("g_string_chunk_new")] public static extern GStringChunk* StringChunkNew(gsize size);
	[LinkName("g_string_chunk_free")] public static extern void StringChunkFree(GStringChunk* chunk);
	[LinkName("g_string_chunk_clear")] public static extern void StringChunkClear(GStringChunk* chunk);
	[LinkName("g_string_chunk_insert")] public static extern gchar* StringChunkInsert(GStringChunk* chunk, gchar* string);
	[LinkName("g_string_chunk_insert_len")] public static extern gchar* StringChunkInsertLen(GStringChunk* chunk, gchar* string, gssize len);
	[LinkName("g_string_chunk_insert_const")] public static extern gchar* StringChunkInsertConst(GStringChunk* chunk, gchar* string);
}

struct GStrvBuilder;

extension GLib
{
	[LinkName("g_strv_builder_new")] public static extern GStrvBuilder* StrvBuilderNew();
	[LinkName("g_strv_builder_unref")] public static extern void StrvBuilderUnref(GStrvBuilder* builder);
	[LinkName("g_strv_builder_unref_to_strv")] public static extern GStrv StrvBuilderUnrefToStrv(GStrvBuilder* builder);
	[LinkName("g_strv_builder_ref")] public static extern GStrvBuilder* StrvBuilderRef(GStrvBuilder* builder);
	[LinkName("g_strv_builder_add")] public static extern void StrvBuilderAdd(GStrvBuilder* builder, c_char* value);
	[LinkName("g_strv_builder_addv")] public static extern void StrvBuilderAddv(GStrvBuilder* builder, c_char** value);
	[LinkName("g_strv_builder_add_many")] public static extern void StrvBuilderAddMany(GStrvBuilder* builder, ...);
	[LinkName("g_strv_builder_take")] public static extern void StrvBuilderTake(GStrvBuilder* builder, c_char* value);
	[LinkName("g_strv_builder_end")] public static extern GStrv StrvBuilderEnd(GStrvBuilder* builder);
}

struct GTestCase;

struct GTestSuite;

function void GTestFunc();

function void GTestDataFunc(gconstpointer user_data);

function void GTestFixtureFunc(gpointer fixture, gconstpointer user_data);

extension GLib
{
	[LinkName("g_strcmp0")] public static extern c_int Strcmp0(c_char* str1, c_char* str2);
	[LinkName("g_test_minimized_result")] public static extern void TestMinimizedResult(double minimized_quantity, c_char* format, ...);
	[LinkName("g_test_maximized_result")] public static extern void TestMaximizedResult(double maximized_quantity, c_char* format, ...);
	[LinkName("g_test_init")] public static extern void TestInit(c_int* argc, c_char*** argv, ...);
	[LinkName("g_test_subprocess")] public static extern gboolean TestSubprocess();
	[LinkName("g_test_run")] public static extern c_int TestRun();
	[LinkName("g_test_add_func")] public static extern void TestAddFunc(c_char* testpath, GTestFunc test_func);
	[LinkName("g_test_add_data_func")] public static extern void TestAddDataFunc(c_char* testpath, gconstpointer test_data, GTestDataFunc test_func);
	[LinkName("g_test_add_data_func_full")] public static extern void TestAddDataFuncFull(c_char* testpath, gpointer test_data, GTestDataFunc test_func, GDestroyNotify data_free_func);
	[LinkName("g_test_get_path")] public static extern c_char* TestGetPath();
	[LinkName("g_test_fail")] public static extern void TestFail();
	[LinkName("g_test_fail_printf")] public static extern void TestFailPrintf(c_char* format, ...);
	[LinkName("g_test_incomplete")] public static extern void TestIncomplete(gchar* msg);
	[LinkName("g_test_incomplete_printf")] public static extern void TestIncompletePrintf(c_char* format, ...);
	[LinkName("g_test_skip")] public static extern void TestSkip(gchar* msg);
	[LinkName("g_test_skip_printf")] public static extern void TestSkipPrintf(c_char* format, ...);
	[LinkName("g_test_failed")] public static extern gboolean TestFailed();
	[LinkName("g_test_set_nonfatal_assertions")] public static extern void TestSetNonfatalAssertions();
	[LinkName("g_test_disable_crash_reporting")] public static extern void TestDisableCrashReporting();
	[LinkName("g_test_message")] public static extern void TestMessage(c_char* format, ...);
	[LinkName("g_test_bug_base")] public static extern void TestBugBase(c_char* uri_pattern);
	[LinkName("g_test_bug")] public static extern void TestBug(c_char* bug_uri_snippet);
	[LinkName("g_test_summary")] public static extern void TestSummary(c_char* summary);
	[LinkName("g_test_timer_start")] public static extern void TestTimerStart();
	[LinkName("g_test_timer_elapsed")] public static extern double TestTimerElapsed();
	[LinkName("g_test_timer_last")] public static extern double TestTimerLast();
	[LinkName("g_test_queue_free")] public static extern void TestQueueFree(gpointer gfree_pointer);
	[LinkName("g_test_queue_destroy")] public static extern void TestQueueDestroy(GDestroyNotify destroy_func, gpointer destroy_data);
}

/** GTestTrapFlags:
 *   @G _TEST_TRAP_DEFAULT: Default behaviour. Since: 2.74
 *   @G _TEST_TRAP_SILENCE_STDOUT: Redirect stdout of the test child to
 *  `/dev/null` so it cannot be observed on the console during test
 *  runs. The actual output is still captured though to allow later
 *  tests with g_test_trap_assert_stdout().
 *   @G _TEST_TRAP_SILENCE_STDERR: Redirect stderr of the test child to
 *  `/dev/null` so it cannot be observed on the console during test
 *  runs. The actual output is still captured though to allow later
 *  tests with g_test_trap_assert_stderr().
 *   @G _TEST_TRAP_INHERIT_STDIN: If this flag is given, stdin of the
 *  child process is shared with stdin of its parent process.
 *  It is redirected to `/dev/null` otherwise.
 *  
 *  Flags to pass to [func @GLib .test_trap_fork] to control input and output.
 *  
 *  Test traps are guards around forked tests. These flags determine what traps to set.
 *  
 *  Deprecated: 2.38: `GTestTrapFlags` is used only with [func @GLib .test_trap_fork],
 *  which is deprecated. Its replacement, [func @GLib .test_trap_subprocess] uses
 *  [flags @GLib .TestSubprocessFlags].
 */
[AllowDuplicates] enum GTestTrapFlags : c_int
{
	Default = 0,
	SilenceStdout = 1 << 7,
	SilenceStderr = 1 << 8,
	InheritStdin = 1 << 9,
}

extension GLib
{
	[LinkName("g_test_trap_fork")] public static extern gboolean TestTrapFork(guint64 usec_timeout, GTestTrapFlags test_trap_flags);
}

[AllowDuplicates] enum GTestSubprocessFlags : c_int
{
	Default = 0,
	InheritStdin = 1 << 0,
	InheritStdout = 1 << 1,
	InheritStderr = 1 << 2,
}

extension GLib
{
	[LinkName("g_test_trap_subprocess")] public static extern void TestTrapSubprocess(c_char* test_path, guint64 usec_timeout, GTestSubprocessFlags test_flags);
	[LinkName("g_test_trap_subprocess_with_envp")] public static extern void TestTrapSubprocessWithEnvp(c_char* test_path, c_char** envp, guint64 usec_timeout, GTestSubprocessFlags test_flags);
	[LinkName("g_test_trap_has_passed")] public static extern gboolean TestTrapHasPassed();
	[LinkName("g_test_trap_reached_timeout")] public static extern gboolean TestTrapReachedTimeout();
	[LinkName("g_test_rand_int")] public static extern gint32 TestRandInt();
	[LinkName("g_test_rand_int_range")] public static extern gint32 TestRandIntRange(gint32 begin, gint32 end);
	[LinkName("g_test_rand_double")] public static extern double TestRandDouble();
	[LinkName("g_test_rand_double_range")] public static extern double TestRandDoubleRange(double range_start, double range_end);
	[LinkName("g_test_create_case")] public static extern GTestCase* TestCreateCase(c_char* test_name, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown);
	[LinkName("g_test_create_suite")] public static extern GTestSuite* TestCreateSuite(c_char* suite_name);
	[LinkName("g_test_get_root")] public static extern GTestSuite* TestGetRoot();
	[LinkName("g_test_suite_add")] public static extern void TestSuiteAdd(GTestSuite* suite, GTestCase* test_case);
	[LinkName("g_test_suite_add_suite")] public static extern void TestSuiteAddSuite(GTestSuite* suite, GTestSuite* nestedsuite);
	[LinkName("g_test_run_suite")] public static extern c_int TestRunSuite(GTestSuite* suite);
	[LinkName("g_test_case_free")] public static extern void TestCaseFree(GTestCase* test_case);
	[LinkName("g_test_suite_free")] public static extern void TestSuiteFree(GTestSuite* suite);
	[LinkName("g_test_trap_assertions")] public static extern void TestTrapAssertions(c_char* domain, c_char* file, c_int line, c_char* func, guint64 assertion_flags, c_char* pattern);
	[LinkName("g_assertion_message")] public static extern void AssertionMessage(c_char* domain, c_char* file, c_int line, c_char* func, c_char* message);
	[LinkName("g_assertion_message_expr")] public static extern void AssertionMessageExpr(c_char* domain, c_char* file, c_int line, c_char* func, c_char* expr);
	[LinkName("g_assertion_message_cmpstr")] public static extern void AssertionMessageCmpstr(c_char* domain, c_char* file, c_int line, c_char* func, c_char* expr, c_char* arg1, c_char* cmp, c_char* arg2);
	[LinkName("g_assertion_message_cmpstrv")] public static extern void AssertionMessageCmpstrv(c_char* domain, c_char* file, c_int line, c_char* func, c_char* expr, c_char** arg1, c_char** arg2, gsize first_wrong_idx);
	[LinkName("g_assertion_message_cmpint")] public static extern void AssertionMessageCmpint(c_char* domain, c_char* file, c_int line, c_char* func, c_char* expr, guint64 arg1, c_char* cmp, guint64 arg2, c_char numtype);
	[LinkName("g_assertion_message_cmpnum")] public static extern void AssertionMessageCmpnum(c_char* domain, c_char* file, c_int line, c_char* func, c_char* expr, /*long double*/ System.Numerics.v128 arg1, c_char* cmp, /*long double*/ System.Numerics.v128 arg2, c_char numtype);
	[LinkName("g_assertion_message_error")] public static extern void AssertionMessageError(c_char* domain, c_char* file, c_int line, c_char* func, c_char* expr, GError* error, GQuark error_domain, c_int error_code);
	[LinkName("g_test_add_vtable")] public static extern void TestAddVtable(c_char* testpath, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown);
}

[CRepr] struct GTestConfig
{
	public gboolean test_initialized;
	public gboolean test_quick;
	public gboolean test_perf;
	public gboolean test_verbose;
	public gboolean test_quiet;
	public gboolean test_undefined;
}

static
{
	[CLink] public static extern GTestConfig* g_test_config_vars;
}

[AllowDuplicates] enum GTestResult : c_int
{
	UnSuccess = 0,
	UnSkipped = 1,
	UnFailure = 2,
	UnIncomplete = 3,
}

[AllowDuplicates] enum GTestLogType : c_int
{
	None = 0,
	Error = 1,
	StartBinary = 2,
	ListCase = 3,
	SkipCase = 4,
	StartCase = 5,
	StopCase = 6,
	MinResult = 7,
	MaxResult = 8,
	Message = 9,
	StartSuite = 10,
	StopSuite = 11,
}

[CRepr] struct GTestLogMsg
{
	public GTestLogType log_type;
	public guint n_strings;
	public gchar** strings;
	public guint n_nums;
	public /*long double*/ System.Numerics.v128* nums;
}

[CRepr] struct GTestLogBuffer
{
	public GString* data;
	public GSList* msgs;
}

extension GLib
{
	[LinkName("g_test_log_type_name")] public static extern c_char* TestLogTypeName(GTestLogType log_type);
	[LinkName("g_test_log_buffer_new")] public static extern GTestLogBuffer* TestLogBufferNew();
	[LinkName("g_test_log_buffer_free")] public static extern void TestLogBufferFree(GTestLogBuffer* tbuffer);
	[LinkName("g_test_log_buffer_push")] public static extern void TestLogBufferPush(GTestLogBuffer* tbuffer, guint n_bytes, guint8* bytes);
	[LinkName("g_test_log_buffer_pop")] public static extern GTestLogMsg* TestLogBufferPop(GTestLogBuffer* tbuffer);
	[LinkName("g_test_log_msg_free")] public static extern void TestLogMsgFree(GTestLogMsg* tmsg);
}

/** GTestLogFatalFunc:
 *   @log _domain: the log domain of the message
 *   @log _level: the log level of the message (including the fatal and recursion flags)
 *   @message : the message to process
 *   @user _data: user data, set in g_test_log_set_fatal_handler()
 *  
 *  Specifies the prototype of fatal log handler functions.
 *  
 *  Returns: %TRUE if the program should abort, %FALSE otherwise
 *  
 *  Since: 2.22
 */
function gboolean GTestLogFatalFunc(gchar* log_domain, GLogLevelFlags log_level, gchar* message, gpointer user_data);

extension GLib
{
	[LinkName("g_test_log_set_fatal_handler")] public static extern void TestLogSetFatalHandler(GTestLogFatalFunc log_func, gpointer user_data);
	[LinkName("g_test_expect_message")] public static extern void TestExpectMessage(gchar* log_domain, GLogLevelFlags log_level, gchar* pattern);
	[LinkName("g_test_assert_expected_messages_internal")] public static extern void TestAssertExpectedMessagesInternal(c_char* domain, c_char* file, c_int line, c_char* func);
}

[AllowDuplicates] enum GTestFileType : c_int
{
	Dist = 0,
	Built = 1,
}

extension GLib
{
	[LinkName("g_test_build_filename")] public static extern gchar* TestBuildFilename(GTestFileType file_type, gchar* first_path, ...);
	[LinkName("g_test_get_dir")] public static extern gchar* TestGetDir(GTestFileType file_type);
	[LinkName("g_test_get_filename")] public static extern gchar* TestGetFilename(GTestFileType file_type, gchar* first_path, ...);
}


[CRepr] struct GThreadPool
{
	public GFunc func;
	public gpointer user_data;
	public gboolean exclusive;
}

extension GLib
{
	[LinkName("g_thread_pool_new")] public static extern GThreadPool* ThreadPoolNew(GFunc func, gpointer user_data, gint max_threads, gboolean exclusive, GError** error);
	[LinkName("g_thread_pool_new_full")] public static extern GThreadPool* ThreadPoolNewFull(GFunc func, gpointer user_data, GDestroyNotify item_free_func, gint max_threads, gboolean exclusive, GError** error);
	[LinkName("g_thread_pool_free")] public static extern void ThreadPoolFree(GThreadPool* pool, gboolean immediate, gboolean wait);
	[LinkName("g_thread_pool_push")] public static extern gboolean ThreadPoolPush(GThreadPool* pool, gpointer data, GError** error);
	[LinkName("g_thread_pool_unprocessed")] public static extern guint ThreadPoolUnprocessed(GThreadPool* pool);
	[LinkName("g_thread_pool_set_sort_function")] public static extern void ThreadPoolSetSortFunction(GThreadPool* pool, GCompareDataFunc func, gpointer user_data);
	[LinkName("g_thread_pool_move_to_front")] public static extern gboolean ThreadPoolMoveToFront(GThreadPool* pool, gpointer data);
	[LinkName("g_thread_pool_set_max_threads")] public static extern gboolean ThreadPoolSetMaxThreads(GThreadPool* pool, gint max_threads, GError** error);
	[LinkName("g_thread_pool_get_max_threads")] public static extern gint ThreadPoolGetMaxThreads(GThreadPool* pool);
	[LinkName("g_thread_pool_get_num_threads")] public static extern guint ThreadPoolGetNumThreads(GThreadPool* pool);
	[LinkName("g_thread_pool_set_max_unused_threads")] public static extern void ThreadPoolSetMaxUnusedThreads(gint max_threads);
	[LinkName("g_thread_pool_get_max_unused_threads")] public static extern gint ThreadPoolGetMaxUnusedThreads();
	[LinkName("g_thread_pool_get_num_unused_threads")] public static extern guint ThreadPoolGetNumUnusedThreads();
	[LinkName("g_thread_pool_stop_unused_threads")] public static extern void ThreadPoolStopUnusedThreads();
	[LinkName("g_thread_pool_set_max_idle_time")] public static extern void ThreadPoolSetMaxIdleTime(guint interval);
	[LinkName("g_thread_pool_get_max_idle_time")] public static extern guint ThreadPoolGetMaxIdleTime();
}

struct GTimer;

extension GLib
{
	[LinkName("g_timer_new")] public static extern GTimer* TimerNew();
	[LinkName("g_timer_destroy")] public static extern void TimerDestroy(GTimer* timer);
	[LinkName("g_timer_start")] public static extern void TimerStart(GTimer* timer);
	[LinkName("g_timer_stop")] public static extern void TimerStop(GTimer* timer);
	[LinkName("g_timer_reset")] public static extern void TimerReset(GTimer* timer);
	[LinkName("g_timer_continue")] public static extern void TimerContinue(GTimer* timer);
	[LinkName("g_timer_elapsed")] public static extern gdouble TimerElapsed(GTimer* timer, gulong* microseconds);
	[LinkName("g_timer_is_active")] public static extern gboolean TimerIsActive(GTimer* timer);
	[LinkName("g_usleep")] public static extern void Usleep(gulong microseconds);
	[LinkName("g_time_val_add")] public static extern void TimeValAdd(GTimeVal* time, glong microseconds);
	[LinkName("g_time_val_from_iso8601")] public static extern gboolean TimeValFromIso8601(gchar* iso_date, GTimeVal* time);
	[LinkName("g_time_val_to_iso8601")] public static extern gchar* TimeValToIso8601(GTimeVal* time);
}


[CRepr] struct GTrashStack
{
	public GTrashStack* next;
}

extension GLib
{
	[LinkName("g_trash_stack_push")] public static extern void TrashStackPush(GTrashStack** stack_p, gpointer data_p);
	[LinkName("g_trash_stack_pop")] public static extern gpointer TrashStackPop(GTrashStack** stack_p);
	[LinkName("g_trash_stack_peek")] public static extern gpointer TrashStackPeek(GTrashStack** stack_p);
	[LinkName("g_trash_stack_height")] public static extern guint TrashStackHeight(GTrashStack** stack_p);
}

struct GTree;

struct GTreeNode;

function gboolean GTraverseFunc(gpointer key, gpointer value, gpointer data);

/** GTraverseNodeFunc:
 *   @node : a #GTreeNode
 *  @date : user data passed to g_tree_foreach_node()
 *  
 *  Specifies the type of function passed to g_tree_foreach_node(). It is
 *  passed each node, together with the @user _data parameter passed to
 *  g_tree_foreach_node(). If the function returns %TRUE, the traversal is
 *  stopped.
 *  
 *  Returns: %TRUE to stop the traversal
 *  Since: 2.68
 */
function gboolean GTraverseNodeFunc(GTreeNode* node, gpointer data);

extension GLib
{
	[LinkName("g_tree_new")] public static extern GTree* TreeNew(GCompareFunc key_compare_func);
	[LinkName("g_tree_new_with_data")] public static extern GTree* TreeNewWithData(GCompareDataFunc key_compare_func, gpointer key_compare_data);
	[LinkName("g_tree_new_full")] public static extern GTree* TreeNewFull(GCompareDataFunc key_compare_func, gpointer key_compare_data, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func);
	[LinkName("g_tree_node_first")] public static extern GTreeNode* TreeNodeFirst(GTree* tree);
	[LinkName("g_tree_node_last")] public static extern GTreeNode* TreeNodeLast(GTree* tree);
	[LinkName("g_tree_node_previous")] public static extern GTreeNode* TreeNodePrevious(GTreeNode* node);
	[LinkName("g_tree_node_next")] public static extern GTreeNode* TreeNodeNext(GTreeNode* node);
	[LinkName("g_tree_ref")] public static extern GTree* TreeRef(GTree* tree);
	[LinkName("g_tree_unref")] public static extern void TreeUnref(GTree* tree);
	[LinkName("g_tree_destroy")] public static extern void TreeDestroy(GTree* tree);
	[LinkName("g_tree_insert_node")] public static extern GTreeNode* TreeInsertNode(GTree* tree, gpointer key, gpointer value);
	[LinkName("g_tree_insert")] public static extern void TreeInsert(GTree* tree, gpointer key, gpointer value);
	[LinkName("g_tree_replace_node")] public static extern GTreeNode* TreeReplaceNode(GTree* tree, gpointer key, gpointer value);
	[LinkName("g_tree_replace")] public static extern void TreeReplace(GTree* tree, gpointer key, gpointer value);
	[LinkName("g_tree_remove")] public static extern gboolean TreeRemove(GTree* tree, gconstpointer key);
	[LinkName("g_tree_remove_all")] public static extern void TreeRemoveAll(GTree* tree);
	[LinkName("g_tree_steal")] public static extern gboolean TreeSteal(GTree* tree, gconstpointer key);
	[LinkName("g_tree_node_key")] public static extern gpointer TreeNodeKey(GTreeNode* node);
	[LinkName("g_tree_node_value")] public static extern gpointer TreeNodeValue(GTreeNode* node);
	[LinkName("g_tree_lookup_node")] public static extern GTreeNode* TreeLookupNode(GTree* tree, gconstpointer key);
	[LinkName("g_tree_lookup")] public static extern gpointer TreeLookup(GTree* tree, gconstpointer key);
	[LinkName("g_tree_lookup_extended")] public static extern gboolean TreeLookupExtended(GTree* tree, gconstpointer lookup_key, gpointer* orig_key, gpointer* value);
	[LinkName("g_tree_foreach")] public static extern void TreeForeach(GTree* tree, GTraverseFunc func, gpointer user_data);
	[LinkName("g_tree_foreach_node")] public static extern void TreeForeachNode(GTree* tree, GTraverseNodeFunc func, gpointer user_data);
	[LinkName("g_tree_traverse")] public static extern void TreeTraverse(GTree* tree, GTraverseFunc traverse_func, GTraverseType traverse_type, gpointer user_data);
	[LinkName("g_tree_search_node")] public static extern GTreeNode* TreeSearchNode(GTree* tree, GCompareFunc search_func, gconstpointer user_data);
	[LinkName("g_tree_search")] public static extern gpointer TreeSearch(GTree* tree, GCompareFunc search_func, gconstpointer user_data);
	[LinkName("g_tree_lower_bound")] public static extern GTreeNode* TreeLowerBound(GTree* tree, gconstpointer key);
	[LinkName("g_tree_upper_bound")] public static extern GTreeNode* TreeUpperBound(GTree* tree, gconstpointer key);
	[LinkName("g_tree_height")] public static extern gint TreeHeight(GTree* tree);
	[LinkName("g_tree_nnodes")] public static extern gint TreeNnodes(GTree* tree);
}

struct GUri;

extension GLib
{
	[LinkName("g_uri_ref")] public static extern GUri* UriRef(GUri* uri);
	[LinkName("g_uri_unref")] public static extern void UriUnref(GUri* uri);
}

/** GUriFlags:
 *   @G _URI_FLAGS_NONE: No flags set.
 *   @G _URI_FLAGS_PARSE_RELAXED: Parse the URI more relaxedly than the
 *  [RFC 3986](https://tools.ietf.org/html/rfc3986) grammar specifies,
 *  fixing up or ignoring common mistakes in URIs coming from external
 *  sources. This is also needed for some obscure URI schemes where `;`
 *  separates the host from the path. Dont use this flag unless you need to.
 *   @G _URI_FLAGS_HAS_PASSWORD: The userinfo field may contain a password,
 *  which will be separated from the username by `:`.
 *   @G _URI_FLAGS_HAS_AUTH_PARAMS: The userinfo may contain additional
 *  authentication-related parameters, which will be separated from
 *  the username and/or password by `;`.
 *   @G _URI_FLAGS_NON_DNS: The host component should not be assumed to be a
 *  DNS hostname or IP address (for example, for `smb` URIs with NetBIOS
 *  hostnames).
 *   @G _URI_FLAGS_ENCODED: When parsing a URI, this indicates that `%`-encoded
 *  characters in the userinfo, path, query, and fragment fields
 *  should not be decoded. (And likewise the host field if
 *  %G_URI_FLAGS_NON_DNS is also set.) When building a URI, it indicates
 *  that you have already `%`-encoded the components, and so #GUri
 *  should not do any encoding itself.
 *   @G _URI_FLAGS_ENCODED_QUERY: Same as %G_URI_FLAGS_ENCODED, for the query
 *  field only.
 *   @G _URI_FLAGS_ENCODED_PATH: Same as %G_URI_FLAGS_ENCODED, for the path only.
 *   @G _URI_FLAGS_ENCODED_FRAGMENT: Same as %G_URI_FLAGS_ENCODED, for the
 *  fragment only.
 *   @G _URI_FLAGS_SCHEME_NORMALIZE: A scheme-based normalization will be applied.
 *  For example, when parsing an HTTP URI changing omitted path to `/` and
 *  omitted port to `80`; and when building a URI, changing empty path to `/`
 *  and default port `80`). This only supports a subset of known schemes. (Since: 2.68)
 *  
 *  Flags that describe a URI.
 *  
 *  When parsing a URI, if you need to choose different flags based on
 *  the type of URI, you can use g_uri_peek_scheme() on the URI string
 *  to check the scheme first, and use that to decide what flags to
 *  parse it with.
 *  
 *  Since: 2.66
 */
[AllowDuplicates] enum GUriFlags : c_int
{
	None = 0,
	ParseRelaxed = 1 << 0,
	HasPassword = 1 << 1,
	HasAuthParams = 1 << 2,
	Encoded = 1 << 3,
	NonDns = 1 << 4,
	EncodedQuery = 1 << 5,
	EncodedPath = 1 << 6,
	EncodedFragment = 1 << 7,
	SchemeNormalize = 1 << 8,
}

extension GLib
{
	[LinkName("g_uri_split")] public static extern gboolean UriSplit(gchar* uri_ref, GUriFlags flags, gchar** scheme, gchar** userinfo, gchar** host, gint* port, gchar** path, gchar** query, gchar** fragment, GError** error);
	[LinkName("g_uri_split_with_user")] public static extern gboolean UriSplitWithUser(gchar* uri_ref, GUriFlags flags, gchar** scheme, gchar** user, gchar** password, gchar** auth_params, gchar** host, gint* port, gchar** path, gchar** query, gchar** fragment, GError** error);
	[LinkName("g_uri_split_network")] public static extern gboolean UriSplitNetwork(gchar* uri_string, GUriFlags flags, gchar** scheme, gchar** host, gint* port, GError** error);
	[LinkName("g_uri_is_valid")] public static extern gboolean UriIsValid(gchar* uri_string, GUriFlags flags, GError** error);
	[LinkName("g_uri_join")] public static extern gchar* UriJoin(GUriFlags flags, gchar* scheme, gchar* userinfo, gchar* host, gint port, gchar* path, gchar* query, gchar* fragment);
	[LinkName("g_uri_join_with_user")] public static extern gchar* UriJoinWithUser(GUriFlags flags, gchar* scheme, gchar* user, gchar* password, gchar* auth_params, gchar* host, gint port, gchar* path, gchar* query, gchar* fragment);
	[LinkName("g_uri_parse")] public static extern GUri* UriParse(gchar* uri_string, GUriFlags flags, GError** error);
	[LinkName("g_uri_parse_relative")] public static extern GUri* UriParseRelative(GUri* base_uri, gchar* uri_ref, GUriFlags flags, GError** error);
	[LinkName("g_uri_resolve_relative")] public static extern gchar* UriResolveRelative(gchar* base_uri_string, gchar* uri_ref, GUriFlags flags, GError** error);
	[LinkName("g_uri_build")] public static extern GUri* UriBuild(GUriFlags flags, gchar* scheme, gchar* userinfo, gchar* host, gint port, gchar* path, gchar* query, gchar* fragment);
	[LinkName("g_uri_build_with_user")] public static extern GUri* UriBuildWithUser(GUriFlags flags, gchar* scheme, gchar* user, gchar* password, gchar* auth_params, gchar* host, gint port, gchar* path, gchar* query, gchar* fragment);
}

/** GUriHideFlags:
 *   @G _URI_HIDE_NONE: No flags set.
 *   @G _URI_HIDE_USERINFO: Hide the userinfo.
 *   @G _URI_HIDE_PASSWORD: Hide the password.
 *   @G _URI_HIDE_AUTH_PARAMS: Hide the auth_params.
 *   @G _URI_HIDE_QUERY: Hide the query.
 *   @G _URI_HIDE_FRAGMENT: Hide the fragment.
 *  
 *  Flags describing what parts of the URI to hide in
 *  g_uri_to_string_partial(). Note that %G_URI_HIDE_PASSWORD and
 *  %G_URI_HIDE_AUTH_PARAMS will only work if the #GUri was parsed with
 *  the corresponding flags.
 *  
 *  Since: 2.66
 */
[AllowDuplicates] enum GUriHideFlags : c_int
{
	None = 0,
	Userinfo = 1 << 0,
	Password = 1 << 1,
	AuthParams = 1 << 2,
	Query = 1 << 3,
	Ragment = 1 << 4,
}

extension GLib
{
	[LinkName("g_uri_to_string")] public static extern c_char* UriToString(GUri* uri);
	[LinkName("g_uri_to_string_partial")] public static extern c_char* UriToStringPartial(GUri* uri, GUriHideFlags flags);
	[LinkName("g_uri_get_scheme")] public static extern gchar* UriGetScheme(GUri* uri);
	[LinkName("g_uri_get_userinfo")] public static extern gchar* UriGetUserinfo(GUri* uri);
	[LinkName("g_uri_get_user")] public static extern gchar* UriGetUser(GUri* uri);
	[LinkName("g_uri_get_password")] public static extern gchar* UriGetPassword(GUri* uri);
	[LinkName("g_uri_get_auth_params")] public static extern gchar* UriGetAuthParams(GUri* uri);
	[LinkName("g_uri_get_host")] public static extern gchar* UriGetHost(GUri* uri);
	[LinkName("g_uri_get_port")] public static extern gint UriGetPort(GUri* uri);
	[LinkName("g_uri_get_path")] public static extern gchar* UriGetPath(GUri* uri);
	[LinkName("g_uri_get_query")] public static extern gchar* UriGetQuery(GUri* uri);
	[LinkName("g_uri_get_fragment")] public static extern gchar* UriGetFragment(GUri* uri);
	[LinkName("g_uri_get_flags")] public static extern GUriFlags UriGetFlags(GUri* uri);
}

/** GUriParamsFlags:
 *   @G _URI_PARAMS_NONE: No flags set.
 *   @G _URI_PARAMS_CASE_INSENSITIVE: Parameter names are case insensitive.
 *   @G _URI_PARAMS_WWW_FORM: Replace `+` with space character. Only useful for
 *  URLs on the web, using the `https` or `http` schemas.
 *   @G _URI_PARAMS_PARSE_RELAXED: See %G_URI_FLAGS_PARSE_RELAXED.
 *  
 *  Flags modifying the way parameters are handled by g_uri_parse_params() and
 *  #GUriParamsIter.
 *  
 *  Since: 2.66
 */
[AllowDuplicates] enum GUriParamsFlags : c_int
{
	None = 0,
	CaseInsensitive = 1 << 0,
	WwwForm = 1 << 1,
	ParseRelaxed = 1 << 2,
}

extension GLib
{
	[LinkName("g_uri_parse_params")] public static extern GHashTable* UriParseParams(gchar* @params, gssize length, gchar* separators, GUriParamsFlags flags, GError** error);
}


[CRepr] struct GUriParamsIter
{
	public gint dummy0;
	public gpointer dummy1;
	public gpointer dummy2;
	public guint8[256] dummy3;
}

extension GLib
{
	[LinkName("g_uri_params_iter_init")] public static extern void UriParamsIterInit(GUriParamsIter* iter, gchar* @params, gssize length, gchar* separators, GUriParamsFlags flags);
	[LinkName("g_uri_params_iter_next")] public static extern gboolean UriParamsIterNext(GUriParamsIter* iter, gchar** attribute, gchar** value, GError** error);
	[LinkName("g_uri_error_quark")] public static extern GQuark UriErrorQuark();
}

/** GUriError:
 *   @G _URI_ERROR_FAILED: Generic error if no more specific error is available.
 *  See the error message for details.
 *   @G _URI_ERROR_BAD_SCHEME: The scheme of a URI could not be parsed.
 *   @G _URI_ERROR_BAD_USER: The user/userinfo of a URI could not be parsed.
 *   @G _URI_ERROR_BAD_PASSWORD: The password of a URI could not be parsed.
 *   @G _URI_ERROR_BAD_AUTH_PARAMS: The authentication parameters of a URI could not be parsed.
 *   @G _URI_ERROR_BAD_HOST: The host of a URI could not be parsed.
 *   @G _URI_ERROR_BAD_PORT: The port of a URI could not be parsed.
 *   @G _URI_ERROR_BAD_PATH: The path of a URI could not be parsed.
 *   @G _URI_ERROR_BAD_QUERY: The query of a URI could not be parsed.
 *   @G _URI_ERROR_BAD_FRAGMENT: The fragment of a URI could not be parsed.
 *  
 *  Error codes returned by #GUri methods.
 *  
 *  Since: 2.66
 */
[AllowDuplicates] enum GUriError : c_int
{
	Failed = 0,
	BadScheme = 1,
	BadUser = 2,
	BadPassword = 3,
	BadAuthParams = 4,
	BadHost = 5,
	BadPort = 6,
	BadPath = 7,
	BadQuery = 8,
	BadFragment = 9,
}

extension GLib
{
	[LinkName("g_uri_unescape_string")] public static extern c_char* UriUnescapeString(c_char* escaped_string, c_char* illegal_characters);
	[LinkName("g_uri_unescape_segment")] public static extern c_char* UriUnescapeSegment(c_char* escaped_string, c_char* escaped_string_end, c_char* illegal_characters);
	[LinkName("g_uri_parse_scheme")] public static extern c_char* UriParseScheme(c_char* uri);
	[LinkName("g_uri_peek_scheme")] public static extern c_char* UriPeekScheme(c_char* uri);
	[LinkName("g_uri_escape_string")] public static extern c_char* UriEscapeString(c_char* unescaped, c_char* reserved_chars_allowed, gboolean allow_utf8);
	[LinkName("g_uri_unescape_bytes")] public static extern GBytes* UriUnescapeBytes(c_char* escaped_string, gssize length, c_char* illegal_characters, GError** error);
	[LinkName("g_uri_escape_bytes")] public static extern c_char* UriEscapeBytes(guint8* unescaped, gsize length, c_char* reserved_chars_allowed);
	[LinkName("g_uuid_string_is_valid")] public static extern gboolean UuidStringIsValid(gchar* str);
	[LinkName("g_uuid_string_random")] public static extern gchar* UuidStringRandom();
}

static
{
	[CLink] public static extern guint glib_major_version;
	[CLink] public static extern guint glib_minor_version;
	[CLink] public static extern guint glib_micro_version;
	[CLink] public static extern guint glib_interface_age;
	[CLink] public static extern guint glib_binary_age;
}

extension GLib
{
	[LinkName("glib_check_version")] public static extern gchar* GlibCheckVersion(guint required_major, guint required_minor, guint required_micro);
	[LinkName("g_win32_ftruncate")] public static extern gint Win32Ftruncate(gint f, guint size);
	[LinkName("g_win32_getlocale")] public static extern gchar* Win32Getlocale();
	[LinkName("g_win32_error_message")] public static extern gchar* Win32ErrorMessage(gint error);
	[LinkName("g_win32_get_package_installation_directory")] public static extern gchar* Win32GetPackageInstallationDirectory(gchar* package, gchar* dll_name);
	[LinkName("g_win32_get_package_installation_subdirectory")] public static extern gchar* Win32GetPackageInstallationSubdirectory(gchar* package, gchar* dll_name, gchar* subdir);
	[LinkName("g_win32_get_package_installation_directory_of_module")] public static extern gchar* Win32GetPackageInstallationDirectoryOfModule(gpointer hmodule);
	[LinkName("g_win32_get_windows_version")] public static extern guint Win32GetWindowsVersion();
	[LinkName("g_win32_locale_filename_from_utf8")] public static extern gchar* Win32LocaleFilenameFromUtf8(gchar* utf8filename);
	[LinkName("g_win32_get_command_line")] public static extern gchar** Win32GetCommandLine();
}

/** GWin32OSType:
 *   @G _WIN32_OS_ANY: The running system can be a workstation or a server edition of
 *  Windows.  The type of the running system is therefore not checked.
 *   @G _WIN32_OS_WORKSTATION: The running system is a workstation edition of Windows,
 *  such as Windows 7 Professional.
 *   @G _WIN32_OS_SERVER: The running system is a server edition of Windows, such as
 *  Windows Server 2008 R2.
 *  
 *  Type of Windows edition to check for at run-time.
 */
[AllowDuplicates] enum GWin32OSType : c_int
{
	Any = 0,
	Workstation = 1,
	Server = 2,
}

extension GLib
{
	[LinkName("g_win32_check_windows_version")] public static extern gboolean Win32CheckWindowsVersion(gint major, gint minor, gint spver, GWin32OSType os_type);
}

struct GAllocator;

struct GMemChunk;

extension GLib
{
	[LinkName("g_mem_chunk_new")] public static extern GMemChunk* MemChunkNew(gchar* name, gint atom_size, gsize area_size, gint type);
	[LinkName("g_mem_chunk_destroy")] public static extern void MemChunkDestroy(GMemChunk* mem_chunk);
	[LinkName("g_mem_chunk_alloc")] public static extern gpointer MemChunkAlloc(GMemChunk* mem_chunk);
	[LinkName("g_mem_chunk_alloc0")] public static extern gpointer MemChunkAlloc0(GMemChunk* mem_chunk);
	[LinkName("g_mem_chunk_free")] public static extern void MemChunkFree(GMemChunk* mem_chunk, gpointer mem);
	[LinkName("g_mem_chunk_clean")] public static extern void MemChunkClean(GMemChunk* mem_chunk);
	[LinkName("g_mem_chunk_reset")] public static extern void MemChunkReset(GMemChunk* mem_chunk);
	[LinkName("g_mem_chunk_print")] public static extern void MemChunkPrint(GMemChunk* mem_chunk);
	[LinkName("g_mem_chunk_info")] public static extern void MemChunkInfo();
	[LinkName("g_blow_chunks")] public static extern void BlowChunks();
	[LinkName("g_allocator_new")] public static extern GAllocator* AllocatorNew(gchar* name, guint n_preallocs);
	[LinkName("g_allocator_free")] public static extern void AllocatorFree(GAllocator* allocator);
	[LinkName("g_list_push_allocator")] public static extern void ListPushAllocator(GAllocator* allocator);
	[LinkName("g_list_pop_allocator")] public static extern void ListPopAllocator();
	[LinkName("g_slist_push_allocator")] public static extern void SlistPushAllocator(GAllocator* allocator);
	[LinkName("g_slist_pop_allocator")] public static extern void SlistPopAllocator();
	[LinkName("g_node_push_allocator")] public static extern void NodePushAllocator(GAllocator* allocator);
	[LinkName("g_node_pop_allocator")] public static extern void NodePopAllocator();
}

struct GCache;

function gpointer GCacheNewFunc(gpointer key);

function gpointer GCacheDupFunc(gpointer value);

function void GCacheDestroyFunc(gpointer value);

extension GLib
{
	[LinkName("g_cache_new")] public static extern GCache* CacheNew(GCacheNewFunc value_new_func, GCacheDestroyFunc value_destroy_func, GCacheDupFunc key_dup_func, GCacheDestroyFunc key_destroy_func, GHashFunc hash_key_func, GHashFunc hash_value_func, GEqualFunc key_equal_func);
	[LinkName("g_cache_destroy")] public static extern void CacheDestroy(GCache* cache);
	[LinkName("g_cache_insert")] public static extern gpointer CacheInsert(GCache* cache, gpointer key);
	[LinkName("g_cache_remove")] public static extern void CacheRemove(GCache* cache, gconstpointer value);
	[LinkName("g_cache_key_foreach")] public static extern void CacheKeyForeach(GCache* cache, GHFunc func, gpointer user_data);
	[LinkName("g_cache_value_foreach")] public static extern void CacheValueForeach(GCache* cache, GHFunc func, gpointer user_data);
}


function gchar* GCompletionFunc(gpointer item);

function gint GCompletionStrncmpFunc(gchar* s1, gchar* s2, gsize n);

[CRepr] struct GCompletion
{
	public GList* items;
	public GCompletionFunc func;
	public gchar* prefix;
	public GList* cache;
	public GCompletionStrncmpFunc strncmp_func;
}

extension GLib
{
	[LinkName("g_completion_new")] public static extern GCompletion* CompletionNew(GCompletionFunc func);
	[LinkName("g_completion_add_items")] public static extern void CompletionAddItems(GCompletion* cmp, GList* items);
	[LinkName("g_completion_remove_items")] public static extern void CompletionRemoveItems(GCompletion* cmp, GList* items);
	[LinkName("g_completion_clear_items")] public static extern void CompletionClearItems(GCompletion* cmp);
	[LinkName("g_completion_complete")] public static extern GList* CompletionComplete(GCompletion* cmp, gchar* prefix, gchar** new_prefix);
	[LinkName("g_completion_complete_utf8")] public static extern GList* CompletionCompleteUtf8(GCompletion* cmp, gchar* prefix, gchar** new_prefix);
	[LinkName("g_completion_set_compare")] public static extern void CompletionSetCompare(GCompletion* cmp, GCompletionStrncmpFunc strncmp_func);
	[LinkName("g_completion_free")] public static extern void CompletionFree(GCompletion* cmp);
}

struct GRelation;


[CRepr] struct GTuples
{
	public guint len;
}

extension GLib
{
	[LinkName("g_relation_new")] public static extern GRelation* RelationNew(gint fields);
	[LinkName("g_relation_destroy")] public static extern void RelationDestroy(GRelation* relation);
	[LinkName("g_relation_index")] public static extern void RelationIndex(GRelation* relation, gint field, GHashFunc hash_func, GEqualFunc key_equal_func);
	[LinkName("g_relation_insert")] public static extern void RelationInsert(GRelation* relation, ...);
	[LinkName("g_relation_delete")] public static extern gint RelationDelete(GRelation* relation, gconstpointer key, gint field);
	[LinkName("g_relation_select")] public static extern GTuples* RelationSelect(GRelation* relation, gconstpointer key, gint field);
	[LinkName("g_relation_count")] public static extern gint RelationCount(GRelation* relation, gconstpointer key, gint field);
	[LinkName("g_relation_exists")] public static extern gboolean RelationExists(GRelation* relation, ...);
	[LinkName("g_relation_print")] public static extern void RelationPrint(GRelation* relation);
	[LinkName("g_tuples_destroy")] public static extern void TuplesDestroy(GTuples* tuples);
	[LinkName("g_tuples_index")] public static extern gpointer TuplesIndex(GTuples* tuples, gint index, gint field);
}

[AllowDuplicates] enum GThreadPriority : c_int
{
	Low = 0,
	Normal = 1,
	High = 2,
	Urgent = 3,
}

[CRepr] struct GThread
{
	public GThreadFunc func;
	public gpointer data;
	public gboolean joinable;
	public GThreadPriority priority;
}


[CRepr] struct GThreadFunctions
{
	public function GMutex*() mutex_new;
	public function void(GMutex*) mutex_lock;
	public function gboolean(GMutex*) mutex_trylock;
	public function void(GMutex*) mutex_unlock;
	public function void(GMutex*) mutex_free;
	public function GCond*() cond_new;
	public function void(GCond*) cond_signal;
	public function void(GCond*) cond_broadcast;
	public function void(GCond*, GMutex*) cond_wait;
	public function gboolean(GCond*, GMutex*, GTimeVal*) cond_timed_wait;
	public function void(GCond*) cond_free;
	public function GPrivate*(GDestroyNotify) private_new;
	public function gpointer(GPrivate*) private_get;
	public function void(GPrivate*, gpointer) private_set;
	public function void(GThreadFunc, gpointer, gulong, gboolean, gboolean, GThreadPriority, gpointer, GError**) thread_create;
	public function void() thread_yield;
	public function void(gpointer) thread_join;
	public function void() thread_exit;
	public function void(gpointer, GThreadPriority) thread_set_priority;
	public function void(gpointer) thread_self;
	public function gboolean(gpointer, gpointer) thread_equal;
}

static
{
	[CLink] public static extern GThreadFunctions g_thread_functions_for_glib_use;
	[CLink] public static extern gboolean g_thread_use_default_impl;
	[CLink] public static extern function guint64() g_thread_gettime;
}

extension GLib
{
	[LinkName("g_thread_create")] public static extern GThread* ThreadCreate(GThreadFunc func, gpointer data, gboolean joinable, GError** error);
	[LinkName("g_thread_create_full")] public static extern GThread* ThreadCreateFull(GThreadFunc func, gpointer data, gulong stack_size, gboolean joinable, gboolean bound, GThreadPriority priority, GError** error);
	[LinkName("g_thread_set_priority")] public static extern void ThreadSetPriority(GThread* thread, GThreadPriority priority);
	[LinkName("g_thread_foreach")] public static extern void ThreadForeach(GFunc thread_func, gpointer user_data);
}

[CRepr] struct GStaticMutex
{
	public GMutex* mutex;
}

extension GLib
{
	[LinkName("g_static_mutex_init")] public static extern void StaticMutexInit(GStaticMutex* mutex);
	[LinkName("g_static_mutex_free")] public static extern void StaticMutexFree(GStaticMutex* mutex);
	[LinkName("g_static_mutex_get_mutex_impl")] public static extern GMutex* StaticMutexGetMutexImpl(GStaticMutex* mutex);
}


[CRepr] struct GStaticRecMutex
{
	public GStaticMutex mutex;
	public guint depth;
	[Union, CRepr]public  struct 
	{
		public void* owner;
		public gdouble dummy;
	} unused;
}

extension GLib
{
	[LinkName("g_static_rec_mutex_init")] public static extern void StaticRecMutexInit(GStaticRecMutex* mutex);
	[LinkName("g_static_rec_mutex_lock")] public static extern void StaticRecMutexLock(GStaticRecMutex* mutex);
	[LinkName("g_static_rec_mutex_trylock")] public static extern gboolean StaticRecMutexTrylock(GStaticRecMutex* mutex);
	[LinkName("g_static_rec_mutex_unlock")] public static extern void StaticRecMutexUnlock(GStaticRecMutex* mutex);
	[LinkName("g_static_rec_mutex_lock_full")] public static extern void StaticRecMutexLockFull(GStaticRecMutex* mutex, guint depth);
	[LinkName("g_static_rec_mutex_unlock_full")] public static extern guint StaticRecMutexUnlockFull(GStaticRecMutex* mutex);
	[LinkName("g_static_rec_mutex_free")] public static extern void StaticRecMutexFree(GStaticRecMutex* mutex);
}


[CRepr] struct GStaticRWLock
{
	public GStaticMutex mutex;
	public GCond* read_cond;
	public GCond* write_cond;
	public guint read_counter;
	public gboolean have_writer;
	public guint want_to_read;
	public guint want_to_write;
}

extension GLib
{
	[LinkName("g_static_rw_lock_init")] public static extern void StaticRwLockInit(GStaticRWLock* lock);
	[LinkName("g_static_rw_lock_reader_lock")] public static extern void StaticRwLockReaderLock(GStaticRWLock* lock);
	[LinkName("g_static_rw_lock_reader_trylock")] public static extern gboolean StaticRwLockReaderTrylock(GStaticRWLock* lock);
	[LinkName("g_static_rw_lock_reader_unlock")] public static extern void StaticRwLockReaderUnlock(GStaticRWLock* lock);
	[LinkName("g_static_rw_lock_writer_lock")] public static extern void StaticRwLockWriterLock(GStaticRWLock* lock);
	[LinkName("g_static_rw_lock_writer_trylock")] public static extern gboolean StaticRwLockWriterTrylock(GStaticRWLock* lock);
	[LinkName("g_static_rw_lock_writer_unlock")] public static extern void StaticRwLockWriterUnlock(GStaticRWLock* lock);
	[LinkName("g_static_rw_lock_free")] public static extern void StaticRwLockFree(GStaticRWLock* lock);
	[LinkName("g_private_new")] public static extern GPrivate* PrivateNew(GDestroyNotify notify);
}


[CRepr] struct GStaticPrivate
{
	public guint index;
}

extension GLib
{
	[LinkName("g_static_private_init")] public static extern void StaticPrivateInit(GStaticPrivate* private_key);
	[LinkName("g_static_private_get")] public static extern gpointer StaticPrivateGet(GStaticPrivate* private_key);
	[LinkName("g_static_private_set")] public static extern void StaticPrivateSet(GStaticPrivate* private_key, gpointer data, GDestroyNotify notify);
	[LinkName("g_static_private_free")] public static extern void StaticPrivateFree(GStaticPrivate* private_key);
	[LinkName("g_once_init_enter_impl")] public static extern gboolean OnceInitEnterImpl(gsize* location);
	[LinkName("g_thread_init")] public static extern void ThreadInit(gpointer vtable);
	[LinkName("g_thread_init_with_errorcheck_mutexes")] public static extern void ThreadInitWithErrorcheckMutexes(gpointer vtable);
	[LinkName("g_thread_get_initialized")] public static extern gboolean ThreadGetInitialized();
}

static
{
	[CLink] public static extern gboolean g_threads_got_initialized;
}

extension GLib
{
	[LinkName("g_mutex_new")] public static extern GMutex* MutexNew();
	[LinkName("g_mutex_free")] public static extern void MutexFree(GMutex* mutex);
	[LinkName("g_cond_new")] public static extern GCond* CondNew();
	[LinkName("g_cond_free")] public static extern void CondFree(GCond* cond);
	[LinkName("g_cond_timed_wait")] public static extern gboolean CondTimedWait(GCond* cond, GMutex* mutex, GTimeVal* abs_time);
}

typealias GAsyncQueue_autoptr = GAsyncQueue*;

typealias GAsyncQueue_listautoptr = GList*;

typealias GAsyncQueue_slistautoptr = GSList*;

typealias GAsyncQueue_queueautoptr = GQueue*;

typealias GBookmarkFile_autoptr = GBookmarkFile*;

typealias GBookmarkFile_listautoptr = GList*;

typealias GBookmarkFile_slistautoptr = GSList*;

typealias GBookmarkFile_queueautoptr = GQueue*;

typealias GBytes_autoptr = GBytes*;

typealias GBytes_listautoptr = GList*;

typealias GBytes_slistautoptr = GSList*;

typealias GBytes_queueautoptr = GQueue*;

typealias GChecksum_autoptr = GChecksum*;

typealias GChecksum_listautoptr = GList*;

typealias GChecksum_slistautoptr = GSList*;

typealias GChecksum_queueautoptr = GQueue*;

typealias GDateTime_autoptr = GDateTime*;

typealias GDateTime_listautoptr = GList*;

typealias GDateTime_slistautoptr = GSList*;

typealias GDateTime_queueautoptr = GQueue*;

typealias GDate_autoptr = GDate*;

typealias GDate_listautoptr = GList*;

typealias GDate_slistautoptr = GSList*;

typealias GDate_queueautoptr = GQueue*;

typealias GDir_autoptr = GDir*;

typealias GDir_listautoptr = GList*;

typealias GDir_slistautoptr = GSList*;

typealias GDir_queueautoptr = GQueue*;

typealias GError_autoptr = GError*;

typealias GError_listautoptr = GList*;

typealias GError_slistautoptr = GSList*;

typealias GError_queueautoptr = GQueue*;

typealias GHashTable_autoptr = GHashTable*;

typealias GHashTable_listautoptr = GList*;

typealias GHashTable_slistautoptr = GSList*;

typealias GHashTable_queueautoptr = GQueue*;

typealias GHmac_autoptr = GHmac*;

typealias GHmac_listautoptr = GList*;

typealias GHmac_slistautoptr = GSList*;

typealias GHmac_queueautoptr = GQueue*;

typealias GIOChannel_autoptr = GIOChannel*;

typealias GIOChannel_listautoptr = GList*;

typealias GIOChannel_slistautoptr = GSList*;

typealias GIOChannel_queueautoptr = GQueue*;

typealias GKeyFile_autoptr = GKeyFile*;

typealias GKeyFile_listautoptr = GList*;

typealias GKeyFile_slistautoptr = GSList*;

typealias GKeyFile_queueautoptr = GQueue*;

typealias GList_autoptr = GList*;

typealias GList_listautoptr = GList*;

typealias GList_slistautoptr = GSList*;

typealias GList_queueautoptr = GQueue*;

typealias GArray_autoptr = GArray*;

typealias GArray_listautoptr = GList*;

typealias GArray_slistautoptr = GSList*;

typealias GArray_queueautoptr = GQueue*;

typealias GPtrArray_autoptr = GPtrArray*;

typealias GPtrArray_listautoptr = GList*;

typealias GPtrArray_slistautoptr = GSList*;

typealias GPtrArray_queueautoptr = GQueue*;

typealias GByteArray_autoptr = GByteArray*;

typealias GByteArray_listautoptr = GList*;

typealias GByteArray_slistautoptr = GSList*;

typealias GByteArray_queueautoptr = GQueue*;

typealias GMainContext_autoptr = GMainContext*;

typealias GMainContext_listautoptr = GList*;

typealias GMainContext_slistautoptr = GSList*;

typealias GMainContext_queueautoptr = GQueue*;

typealias GMainContextPusher_autoptr = GMainContextPusher*;

typealias GMainContextPusher_listautoptr = GList*;

typealias GMainContextPusher_slistautoptr = GSList*;

typealias GMainContextPusher_queueautoptr = GQueue*;

typealias GMainLoop_autoptr = GMainLoop*;

typealias GMainLoop_listautoptr = GList*;

typealias GMainLoop_slistautoptr = GSList*;

typealias GMainLoop_queueautoptr = GQueue*;

typealias GSource_autoptr = GSource*;

typealias GSource_listautoptr = GList*;

typealias GSource_slistautoptr = GSList*;

typealias GSource_queueautoptr = GQueue*;

typealias GMappedFile_autoptr = GMappedFile*;

typealias GMappedFile_listautoptr = GList*;

typealias GMappedFile_slistautoptr = GSList*;

typealias GMappedFile_queueautoptr = GQueue*;

typealias GMarkupParseContext_autoptr = GMarkupParseContext*;

typealias GMarkupParseContext_listautoptr = GList*;

typealias GMarkupParseContext_slistautoptr = GSList*;

typealias GMarkupParseContext_queueautoptr = GQueue*;

typealias GNode_autoptr = GNode*;

typealias GNode_listautoptr = GList*;

typealias GNode_slistautoptr = GSList*;

typealias GNode_queueautoptr = GQueue*;

typealias GOptionContext_autoptr = GOptionContext*;

typealias GOptionContext_listautoptr = GList*;

typealias GOptionContext_slistautoptr = GSList*;

typealias GOptionContext_queueautoptr = GQueue*;

typealias GOptionGroup_autoptr = GOptionGroup*;

typealias GOptionGroup_listautoptr = GList*;

typealias GOptionGroup_slistautoptr = GSList*;

typealias GOptionGroup_queueautoptr = GQueue*;

typealias GPatternSpec_autoptr = GPatternSpec*;

typealias GPatternSpec_listautoptr = GList*;

typealias GPatternSpec_slistautoptr = GSList*;

typealias GPatternSpec_queueautoptr = GQueue*;

typealias GQueue_autoptr = GQueue*;

typealias GQueue_listautoptr = GList*;

typealias GQueue_slistautoptr = GSList*;

typealias GQueue_queueautoptr = GQueue*;

typealias GRand_autoptr = GRand*;

typealias GRand_listautoptr = GList*;

typealias GRand_slistautoptr = GSList*;

typealias GRand_queueautoptr = GQueue*;

typealias GRegex_autoptr = GRegex*;

typealias GRegex_listautoptr = GList*;

typealias GRegex_slistautoptr = GSList*;

typealias GRegex_queueautoptr = GQueue*;

typealias GMatchInfo_autoptr = GMatchInfo*;

typealias GMatchInfo_listautoptr = GList*;

typealias GMatchInfo_slistautoptr = GSList*;

typealias GMatchInfo_queueautoptr = GQueue*;

typealias GScanner_autoptr = GScanner*;

typealias GScanner_listautoptr = GList*;

typealias GScanner_slistautoptr = GSList*;

typealias GScanner_queueautoptr = GQueue*;

typealias GSequence_autoptr = GSequence*;

typealias GSequence_listautoptr = GList*;

typealias GSequence_slistautoptr = GSList*;

typealias GSequence_queueautoptr = GQueue*;

typealias GSList_autoptr = GSList*;

typealias GSList_listautoptr = GList*;

typealias GSList_slistautoptr = GSList*;

typealias GSList_queueautoptr = GQueue*;

typealias GString_autoptr = GString*;

typealias GString_listautoptr = GList*;

typealias GString_slistautoptr = GSList*;

typealias GString_queueautoptr = GQueue*;

typealias GStringChunk_autoptr = GStringChunk*;

typealias GStringChunk_listautoptr = GList*;

typealias GStringChunk_slistautoptr = GSList*;

typealias GStringChunk_queueautoptr = GQueue*;

typealias GStrvBuilder_autoptr = GStrvBuilder*;

typealias GStrvBuilder_listautoptr = GList*;

typealias GStrvBuilder_slistautoptr = GSList*;

typealias GStrvBuilder_queueautoptr = GQueue*;

typealias GThread_autoptr = GThread*;

typealias GThread_listautoptr = GList*;

typealias GThread_slistautoptr = GSList*;

typealias GThread_queueautoptr = GQueue*;

typealias GMutexLocker_autoptr = GMutexLocker*;

typealias GMutexLocker_listautoptr = GList*;

typealias GMutexLocker_slistautoptr = GSList*;

typealias GMutexLocker_queueautoptr = GQueue*;

typealias GRecMutexLocker_autoptr = GRecMutexLocker*;

typealias GRecMutexLocker_listautoptr = GList*;

typealias GRecMutexLocker_slistautoptr = GSList*;

typealias GRecMutexLocker_queueautoptr = GQueue*;

typealias GRWLockWriterLocker_autoptr = GRWLockWriterLocker*;

typealias GRWLockWriterLocker_listautoptr = GList*;

typealias GRWLockWriterLocker_slistautoptr = GSList*;

typealias GRWLockWriterLocker_queueautoptr = GQueue*;

typealias GRWLockReaderLocker_autoptr = GRWLockReaderLocker*;

typealias GRWLockReaderLocker_listautoptr = GList*;

typealias GRWLockReaderLocker_slistautoptr = GSList*;

typealias GRWLockReaderLocker_queueautoptr = GQueue*;

typealias GTimer_autoptr = GTimer*;

typealias GTimer_listautoptr = GList*;

typealias GTimer_slistautoptr = GSList*;

typealias GTimer_queueautoptr = GQueue*;

typealias GTimeZone_autoptr = GTimeZone*;

typealias GTimeZone_listautoptr = GList*;

typealias GTimeZone_slistautoptr = GSList*;

typealias GTimeZone_queueautoptr = GQueue*;

typealias GTree_autoptr = GTree*;

typealias GTree_listautoptr = GList*;

typealias GTree_slistautoptr = GSList*;

typealias GTree_queueautoptr = GQueue*;

typealias GVariant_autoptr = GVariant*;

typealias GVariant_listautoptr = GList*;

typealias GVariant_slistautoptr = GSList*;

typealias GVariant_queueautoptr = GQueue*;

typealias GVariantBuilder_autoptr = GVariantBuilder*;

typealias GVariantBuilder_listautoptr = GList*;

typealias GVariantBuilder_slistautoptr = GSList*;

typealias GVariantBuilder_queueautoptr = GQueue*;

typealias GVariantIter_autoptr = GVariantIter*;

typealias GVariantIter_listautoptr = GList*;

typealias GVariantIter_slistautoptr = GSList*;

typealias GVariantIter_queueautoptr = GQueue*;

typealias GVariantDict_autoptr = GVariantDict*;

typealias GVariantDict_listautoptr = GList*;

typealias GVariantDict_slistautoptr = GSList*;

typealias GVariantDict_queueautoptr = GQueue*;

typealias GVariantType_autoptr = GVariantType*;

typealias GVariantType_listautoptr = GList*;

typealias GVariantType_slistautoptr = GSList*;

typealias GVariantType_queueautoptr = GQueue*;

typealias GRefString_autoptr = GRefString*;

typealias GRefString_listautoptr = GList*;

typealias GRefString_slistautoptr = GSList*;

typealias GRefString_queueautoptr = GQueue*;

typealias GUri_autoptr = GUri*;

typealias GUri_listautoptr = GList*;

typealias GUri_slistautoptr = GSList*;

typealias GUri_queueautoptr = GQueue*;

typealias GPathBuf_autoptr = GPathBuf*;

typealias GPathBuf_listautoptr = GList*;

typealias GPathBuf_slistautoptr = GSList*;

typealias GPathBuf_queueautoptr = GQueue*;
