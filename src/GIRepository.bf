/* Auto generated by https://github.com/Rune-Magic/C2Beef-Binding-Generator
 * DO NOT EDIT
 */

using System;
using System.Interop;

namespace GObject.Introspection;

static
{
	public const let GI_MAJOR_VERSION = 1;
	public const let GI_MINOR_VERSION = 86;
	public const let GI_MICRO_VERSION = 0;
}

[CRepr] struct GIBaseInfoStub
{
	public gint32 dummy1;
	public gint32 dummy2;
	public gpointer dummy3;
	public gpointer dummy4;
	public gpointer dummy5;
	public guint32 dummy6;
	public guint32 dummy7;
	public gpointer[4] padding;
}

struct GIBaseInfo : GIBaseInfoStub;
struct GICallableInfo : GIBaseInfo;
struct GIFunctionInfo : GIBaseInfo;
struct GICallbackInfo : GIBaseInfo;
struct GIRegisteredTypeInfo : GIBaseInfo;
struct GIStructInfo : GIBaseInfo;
struct GIUnionInfo : GIBaseInfo;
struct GIEnumInfo : GIBaseInfo;
struct GIObjectInfo : GIBaseInfo;
struct GIInterfaceInfo : GIBaseInfo;
struct GIConstantInfo : GIBaseInfo;
struct GIValueInfo : GIBaseInfo;
struct GISignalInfo : GIBaseInfo;
struct GIVFuncInfo : GIBaseInfo;
struct GIPropertyInfo : GIBaseInfo;
struct GIFieldInfo : GIBaseInfo;
struct GIArgInfo : GIBaseInfo;
struct GITypeInfo : GIBaseInfo;
struct GIUnresolvedInfo;

[Union, CRepr] struct GIArgument
{
	public gboolean v_boolean;
	public gint8 v_int8;
	public guint8 v_uint8;
	public gint16 v_int16;
	public guint16 v_uint16;
	public gint32 v_int32;
	public guint32 v_uint32;
	public gint64 v_int64;
	public guint64 v_uint64;
	public gfloat v_float;
	public gdouble v_double;
	public gshort v_short;
	public gushort v_ushort;
	public gint v_int;
	public guint v_uint;
	public glong v_long;
	public gulong v_ulong;
	public gssize v_ssize;
	public gsize v_size;
	public gchar* v_string;
	public gpointer v_pointer;
}

/** GIInfoType:
 *   @GI _INFO_TYPE_INVALID: invalid type
 *   @GI _INFO_TYPE_FUNCTION: function, see #GIFunctionInfo
 *   @GI _INFO_TYPE_CALLBACK: callback, see #GIFunctionInfo
 *   @GI _INFO_TYPE_STRUCT: struct, see #GIStructInfo
 *   @GI _INFO_TYPE_BOXED: boxed, see #GIStructInfo or #GIUnionInfo
 *   @GI _INFO_TYPE_ENUM: enum, see #GIEnumInfo
 *   @GI _INFO_TYPE_FLAGS: flags, see #GIEnumInfo
 *   @GI _INFO_TYPE_OBJECT: object, see #GIObjectInfo
 *   @GI _INFO_TYPE_INTERFACE: interface, see #GIInterfaceInfo
 *   @GI _INFO_TYPE_CONSTANT: contant, see #GIConstantInfo
 *   @GI _INFO_TYPE_INVALID_0: deleted, used to be GI_INFO_TYPE_ERROR_DOMAIN.
 *   @GI _INFO_TYPE_UNION: union, see #GIUnionInfo
 *   @GI _INFO_TYPE_VALUE: enum value, see #GIValueInfo
 *   @GI _INFO_TYPE_SIGNAL: signal, see #GISignalInfo
 *   @GI _INFO_TYPE_VFUNC: virtual function, see #GIVFuncInfo
 *   @GI _INFO_TYPE_PROPERTY: GObject property, see #GIPropertyInfo
 *   @GI _INFO_TYPE_FIELD: struct or union field, see #GIFieldInfo
 *   @GI _INFO_TYPE_ARG: argument of a function or callback, see #GIArgInfo
 *   @GI _INFO_TYPE_TYPE: type information, see #GITypeInfo
 *   @GI _INFO_TYPE_UNRESOLVED: unresolved type, a type which is not present in
 *  the typelib, or any of its dependencies.
 *  
 *  The type of a GIBaseInfo struct.
 */
[AllowDuplicates] enum GIInfoType : c_int
{
	Invalid = 0,
	Function = 1,
	Callback = 2,
	Struct = 3,
	Boxed = 4,
	Enum = 5,
	Flags = 6,
	Object = 7,
	Interface = 8,
	Constant = 9,
	Invalid0 = 10,
	Union = 11,
	Value = 12,
	Signal = 13,
	Vfunc = 14,
	Property = 15,
	Field = 16,
	Arg = 17,
	Type = 18,
	Unresolved = 19,
}

/** GITransfer:
 *   @GI _TRANSFER_NOTHING: transfer nothing from the callee (function or the type
 *  instance the property belongs to) to the caller. The callee retains the
 *  ownership of the transfer and the caller doesn't need to do anything to free
 *  up the resources of this transfer.
 *   @GI _TRANSFER_CONTAINER: transfer the container (list, array, hash table) from
 *  the callee to the caller. The callee retains the ownership of the individual
 *  items in the container and the caller has to free up the container resources
 *  (g_list_free()/g_hash_table_destroy() etc) of this transfer.
 *   @GI _TRANSFER_EVERYTHING: transfer everything, eg the container and its
 *  contents from the callee to the caller. This is the case when the callee
 *  creates a copy of all the data it returns. The caller is responsible for
 *  cleaning up the container and item resources of this transfer.
 *  
 *  The transfer is the exchange of data between two parts, from the callee to
 *  the caller. The callee is either a function/method/signal or an
 *  object/interface where a property is defined. The caller is the side
 *  accessing a property or calling a function.
 *  #GITransfer specifies who's responsible for freeing the resources after the
 *  ownership transfer is complete. In case of a containing type such as a list,
 *  an array or a hash table the container itself is specified differently from
 *  the items within the container itself. Each container is freed differently,
 *  check the documentation for the types themselves for information on how to
 *  free them.
 */
[AllowDuplicates] enum GITransfer : c_int
{
	Nothing = 0,
	Container = 1,
	Everything = 2,
}

/** GIDirection:
 *   @GI _DIRECTION_IN: in argument.
 *   @GI _DIRECTION_OUT: out argument.
 *   @GI _DIRECTION_INOUT: in and out argument.
 *  
 *  The direction of a #GIArgInfo.
 */
[AllowDuplicates] enum GIDirection : c_int
{
	In = 0,
	Out = 1,
	Inout = 2,
}

/** GIScopeType:
 *   @GI _SCOPE_TYPE_INVALID: The argument is not of callback type.
 *   @GI _SCOPE_TYPE_CALL: The callback and associated user_data is only
 *  used during the call to this function.
 *   @GI _SCOPE_TYPE_ASYNC: The callback and associated user_data is
 *  only used until the callback is invoked, and the callback.
 *  is invoked always exactly once.
 *   @GI _SCOPE_TYPE_NOTIFIED: The callback and associated
 *  user_data is used until the caller is notfied via the destroy_notify.
 *   @GI _SCOPE_TYPE_FOREVER: The callback and associated user_data is
 *  used until the process terminates
 *  
 *  Scope type of a #GIArgInfo representing callback, determines how the
 *  callback is invoked and is used to decided when the invoke structs
 *  can be freed.
 */
[AllowDuplicates] enum GIScopeType : c_int
{
	Invalid = 0,
	Call = 1,
	Async = 2,
	Notified = 3,
	Forever = 4,
}

/** GITypeTag:
 *   @GI _TYPE_TAG_VOID: void
 *   @GI _TYPE_TAG_BOOLEAN: boolean
 *   @GI _TYPE_TAG_INT8: 8-bit signed integer
 *   @GI _TYPE_TAG_UINT8: 8-bit unsigned integer
 *   @GI _TYPE_TAG_INT16: 16-bit signed integer
 *   @GI _TYPE_TAG_UINT16: 16-bit unsigned integer
 *   @GI _TYPE_TAG_INT32: 32-bit signed integer
 *   @GI _TYPE_TAG_UINT32: 32-bit unsigned integer
 *   @GI _TYPE_TAG_INT64: 64-bit signed integer
 *   @GI _TYPE_TAG_UINT64: 64-bit unsigned integer
 *   @GI _TYPE_TAG_FLOAT: float
 *   @GI _TYPE_TAG_DOUBLE: double floating point
 *   @GI _TYPE_TAG_GTYPE: a #GType
 *   @GI _TYPE_TAG_UTF8: a UTF-8 encoded string
 *   @GI _TYPE_TAG_FILENAME: a filename, encoded in the same encoding
 *  as the native filesystem is using.
 *   @GI _TYPE_TAG_ARRAY: an array
 *   @GI _TYPE_TAG_INTERFACE: an extended interface object
 *   @GI _TYPE_TAG_GLIST: a #GList
 *   @GI _TYPE_TAG_GSLIST: a #GSList
 *   @GI _TYPE_TAG_GHASH: a #GHashTable
 *   @GI _TYPE_TAG_ERROR: a #GError
 *   @GI _TYPE_TAG_UNICHAR: Unicode character
 *  
 *  The type tag of a #GITypeInfo.
 */
[AllowDuplicates] enum GITypeTag : c_int
{
	Void = 0,
	Boolean = 1,
	Int8 = 2,
	Uint8 = 3,
	Int16 = 4,
	Uint16 = 5,
	Int32 = 6,
	Uint32 = 7,
	Int64 = 8,
	Uint64 = 9,
	Float = 10,
	Double = 11,
	Gtype = 12,
	Utf8 = 13,
	Filename = 14,
	Array = 15,
	Interface = 16,
	Glist = 17,
	Gslist = 18,
	Ghash = 19,
	Error = 20,
	Unichar = 21,
}

/** GIArrayType:
 *   @GI _ARRAY_TYPE_C: a C array, char[] for instance
 *   @GI _ARRAY_TYPE_ARRAY: a @GArray array
 *   @GI _ARRAY_TYPE_PTR_ARRAY: a #GPtrArray array
 *   @GI _ARRAY_TYPE_BYTE_ARRAY: a #GByteArray array
 *  
 *  The type of array in a #GITypeInfo.
 */
[AllowDuplicates] enum GIArrayType : c_int
{
	C = 0,
	Array = 1,
	PtrArray = 2,
	ByteArray = 3,
}

/** GIFieldInfoFlags:
 *   @GI _FIELD_IS_READABLE: field is readable.
 *   @GI _FIELD_IS_WRITABLE: field is writable.
 *  
 *  Flags for a #GIFieldInfo.
 */
[AllowDuplicates] enum GIFieldInfoFlags : c_int
{
	SReadable = 1 << 0,
	SWritable = 1 << 1,
}

/** GIVFuncInfoFlags:
 *   @GI _VFUNC_MUST_CHAIN_UP: chains up to the parent type
 *   @GI _VFUNC_MUST_OVERRIDE: overrides
 *   @GI _VFUNC_MUST_NOT_OVERRIDE: does not override
 *   @GI _VFUNC_THROWS: Includes a #GError
 *  
 *  Flags of a #GIVFuncInfo struct.
 */
[AllowDuplicates] enum GIVFuncInfoFlags : c_int
{
	MustChainUp = 1 << 0,
	MustOverride = 1 << 1,
	MustNotOverride = 1 << 2,
	Throws = 1 << 3,
}

/** GIFunctionInfoFlags:
 *   @GI _FUNCTION_IS_METHOD: is a method.
 *   @GI _FUNCTION_IS_CONSTRUCTOR: is a constructor.
 *   @GI _FUNCTION_IS_GETTER: is a getter of a #GIPropertyInfo.
 *   @GI _FUNCTION_IS_SETTER: is a setter of a #GIPropertyInfo.
 *   @GI _FUNCTION_WRAPS_VFUNC: represents a virtual function.
 *   @GI _FUNCTION_THROWS: the function may throw an error.
 *  
 *  Flags for a #GIFunctionInfo struct.
 */
[AllowDuplicates] enum GIFunctionInfoFlags : c_int
{
	SMethod = 1 << 0,
	SConstructor = 1 << 1,
	SGetter = 1 << 2,
	SSetter = 1 << 3,
	WrapsVfunc = 1 << 4,
	Throws = 1 << 5,
}

typealias GArgument = GIArgument;

struct GITypelib;
typealias GTypelib = GITypelib;

extension GIArgInfo
{
	[LinkName("g_arg_info_get_direction")] public static extern GIDirection GetDirection(GIArgInfo* info);
	[LinkName("g_arg_info_is_return_value")] public static extern gboolean IsReturnValue(GIArgInfo* info);
	[LinkName("g_arg_info_is_optional")] public static extern gboolean IsOptional(GIArgInfo* info);
	[LinkName("g_arg_info_is_caller_allocates")] public static extern gboolean IsCallerAllocates(GIArgInfo* info);
	[LinkName("g_arg_info_may_be_null")] public static extern gboolean MayBeNull(GIArgInfo* info);
	[LinkName("g_arg_info_is_skip")] public static extern gboolean IsSkip(GIArgInfo* info);
	[LinkName("g_arg_info_get_ownership_transfer")] public static extern GITransfer GetOwnershipTransfer(GIArgInfo* info);
	[LinkName("g_arg_info_get_scope")] public static extern GIScopeType GetScope(GIArgInfo* info);
	[LinkName("g_arg_info_get_closure")] public static extern gint GetClosure(GIArgInfo* info);
	[LinkName("g_arg_info_get_destroy")] public static extern gint GetDestroy(GIArgInfo* info);
	[LinkName("g_arg_info_get_type")] public static extern GITypeInfo* GetType(GIArgInfo* info);
	[LinkName("g_arg_info_load_type")] public static extern void LoadType(GIArgInfo* info, GITypeInfo* type);
}


extension GITypelib
{
	[LinkName("g_typelib_new_from_memory")] public static extern GITypelib* NewFromMemory(guint8* memory, gsize len, GError** error);
	[LinkName("g_typelib_new_from_const_memory")] public static extern GITypelib* NewFromConstMemory(guint8* memory, gsize len, GError** error);
	[LinkName("g_typelib_new_from_mapped_file")] public static extern GITypelib* NewFromMappedFile(GMappedFile* mfile, GError** error);
	[LinkName("g_typelib_free")] public static extern void Free(GITypelib* typelib);
	[LinkName("g_typelib_symbol")] public static extern gboolean Symbol(GITypelib* typelib, gchar* symbol_name, gpointer* symbol);
	[LinkName("g_typelib_get_namespace")] public static extern gchar* GetNamespace(GITypelib* typelib);
}

/** GIAttributeIter:
 *  
 *  An opaque structure used to iterate over attributes
 *  in a #GIBaseInfo struct.
 */
[CRepr] struct GIAttributeIter
{
	public gpointer data;
	public gpointer data2;
	public gpointer data3;
	public gpointer data4;
}

extension GIBaseInfo
{
	[LinkName("g_base_info_gtype_get_type")] public static extern GType GtypeGetType();
	[LinkName("g_base_info_ref")] public static extern GIBaseInfo* Ref(GIBaseInfo* info);
	[LinkName("g_base_info_unref")] public static extern void Unref(GIBaseInfo* info);
	[LinkName("g_base_info_get_type")] public static extern GIInfoType GetType(GIBaseInfo* info);
	[LinkName("g_base_info_get_name")] public static extern gchar* GetName(GIBaseInfo* info);
	[LinkName("g_base_info_get_namespace")] public static extern gchar* GetNamespace(GIBaseInfo* info);
	[LinkName("g_base_info_is_deprecated")] public static extern gboolean IsDeprecated(GIBaseInfo* info);
	[LinkName("g_base_info_get_attribute")] public static extern gchar* GetAttribute(GIBaseInfo* info, gchar* name);
	[LinkName("g_base_info_iterate_attributes")] public static extern gboolean IterateAttributes(GIBaseInfo* info, GIAttributeIter* iterator, c_char** name, c_char** value);
	[LinkName("g_base_info_get_container")] public static extern GIBaseInfo* GetContainer(GIBaseInfo* info);
	[LinkName("g_base_info_get_typelib")] public static extern GITypelib* GetTypelib(GIBaseInfo* info);
	[LinkName("g_base_info_equal")] public static extern gboolean Equal(GIBaseInfo* info1, GIBaseInfo* info2);
}

extension GIR
{
	[LinkName("g_info_new")] public static extern GIBaseInfo* InfoNew(GIInfoType type, GIBaseInfo* container, GITypelib* typelib, guint32 offset);
}

extension GICallableInfo
{
	[LinkName("g_callable_info_is_method")] public static extern gboolean IsMethod(GICallableInfo* info);
	[LinkName("g_callable_info_can_throw_gerror")] public static extern gboolean CanThrowGerror(GICallableInfo* info);
	[LinkName("g_callable_info_get_return_type")] public static extern GITypeInfo* GetReturnType(GICallableInfo* info);
	[LinkName("g_callable_info_load_return_type")] public static extern void LoadReturnType(GICallableInfo* info, GITypeInfo* type);
	[LinkName("g_callable_info_get_return_attribute")] public static extern gchar* GetReturnAttribute(GICallableInfo* info, gchar* name);
	[LinkName("g_callable_info_iterate_return_attributes")] public static extern gboolean IterateReturnAttributes(GICallableInfo* info, GIAttributeIter* iterator, c_char** name, c_char** value);
	[LinkName("g_callable_info_get_caller_owns")] public static extern GITransfer GetCallerOwns(GICallableInfo* info);
	[LinkName("g_callable_info_may_return_null")] public static extern gboolean MayReturnNull(GICallableInfo* info);
	[LinkName("g_callable_info_skip_return")] public static extern gboolean SkipReturn(GICallableInfo* info);
	[LinkName("g_callable_info_get_n_args")] public static extern gint GetNArgs(GICallableInfo* info);
	[LinkName("g_callable_info_get_arg")] public static extern GIArgInfo* GetArg(GICallableInfo* info, gint n);
	[LinkName("g_callable_info_load_arg")] public static extern void LoadArg(GICallableInfo* info, gint n, GIArgInfo* arg);
	[LinkName("g_callable_info_invoke")] public static extern gboolean Invoke(GICallableInfo* info, gpointer @function, GIArgument* in_args, c_int n_in_args, GIArgument* out_args, c_int n_out_args, GIArgument* return_value, gboolean is_method, gboolean throws, GError** error);
	[LinkName("g_callable_info_get_instance_ownership_transfer")] public static extern GITransfer GetInstanceOwnershipTransfer(GICallableInfo* info);
}

extension GIConstantInfo
{
	[LinkName("g_constant_info_get_type")] public static extern GITypeInfo* GetType(GIConstantInfo* info);
	[LinkName("g_constant_info_free_value")] public static extern void FreeValue(GIConstantInfo* info, GIArgument* value);
	[LinkName("g_constant_info_get_value")] public static extern gint GetValue(GIConstantInfo* info, GIArgument* value);
}

extension GIEnumInfo
{
	[LinkName("g_enum_info_get_n_values")] public static extern gint GetNValues(GIEnumInfo* info);
	[LinkName("g_enum_info_get_value")] public static extern GIValueInfo* GetValue(GIEnumInfo* info, gint n);
	[LinkName("g_enum_info_get_n_methods")] public static extern gint GetNMethods(GIEnumInfo* info);
	[LinkName("g_enum_info_get_method")] public static extern GIFunctionInfo* GetMethod(GIEnumInfo* info, gint n);
	[LinkName("g_enum_info_get_storage_type")] public static extern GITypeTag GetStorageType(GIEnumInfo* info);
	[LinkName("g_enum_info_get_error_domain")] public static extern gchar* GetErrorDomain(GIEnumInfo* info);
}

extension GIValueInfo
{
	[LinkName("g_value_info_get_value")] public static extern gint64 GetValue(GIValueInfo* info);
}

extension GIFieldInfo
{
	[LinkName("g_field_info_get_flags")] public static extern GIFieldInfoFlags GetFlags(GIFieldInfo* info);
	[LinkName("g_field_info_get_size")] public static extern gint GetSize(GIFieldInfo* info);
	[LinkName("g_field_info_get_offset")] public static extern gint GetOffset(GIFieldInfo* info);
	[LinkName("g_field_info_get_type")] public static extern GITypeInfo* GetType(GIFieldInfo* info);
	[LinkName("g_field_info_get_field")] public static extern gboolean GetField(GIFieldInfo* field_info, gpointer mem, GIArgument* value);
	[LinkName("g_field_info_set_field")] public static extern gboolean SetField(GIFieldInfo* field_info, gpointer mem, GIArgument* value);
}

extension GIFunctionInfo
{
	[LinkName("g_function_info_get_symbol")] public static extern gchar* GetSymbol(GIFunctionInfo* info);
	[LinkName("g_function_info_get_flags")] public static extern GIFunctionInfoFlags GetFlags(GIFunctionInfo* info);
	[LinkName("g_function_info_get_property")] public static extern GIPropertyInfo* GetProperty(GIFunctionInfo* info);
	[LinkName("g_function_info_get_vfunc")] public static extern GIVFuncInfo* GetVfunc(GIFunctionInfo* info);
}

extension GIR
{
	[LinkName("g_invoke_error_quark")] public static extern GQuark InvokeErrorQuark();
}

/** GInvokeError:
 *   @G _INVOKE_ERROR_FAILED: invokation failed, unknown error.
 *   @G _INVOKE_ERROR_SYMBOL_NOT_FOUND: symbol couldn't be found in any of the
 *  libraries associated with the typelib of the function.
 *   @G _INVOKE_ERROR_ARGUMENT_MISMATCH: the arguments provided didn't match
 *  the expected arguments for the functions type signature.
 *  
 *  An error occuring while invoking a function via
 *  g_function_info_invoke().
 */
[AllowDuplicates] enum GInvokeError : c_int
{
	Failed = 0,
	SymbolNotFound = 1,
	ArgumentMismatch = 2,
}

extension GIFunctionInfo
{
	[LinkName("g_function_info_invoke")] public static extern gboolean Invoke(GIFunctionInfo* info, GIArgument* in_args, c_int n_in_args, GIArgument* out_args, c_int n_out_args, GIArgument* return_value, GError** error);
}

extension GIInterfaceInfo
{
	[LinkName("g_interface_info_get_n_prerequisites")] public static extern gint GetNPrerequisites(GIInterfaceInfo* info);
	[LinkName("g_interface_info_get_prerequisite")] public static extern GIBaseInfo* GetPrerequisite(GIInterfaceInfo* info, gint n);
	[LinkName("g_interface_info_get_n_properties")] public static extern gint GetNProperties(GIInterfaceInfo* info);
	[LinkName("g_interface_info_get_property")] public static extern GIPropertyInfo* GetProperty(GIInterfaceInfo* info, gint n);
	[LinkName("g_interface_info_get_n_methods")] public static extern gint GetNMethods(GIInterfaceInfo* info);
	[LinkName("g_interface_info_get_method")] public static extern GIFunctionInfo* GetMethod(GIInterfaceInfo* info, gint n);
	[LinkName("g_interface_info_find_method")] public static extern GIFunctionInfo* FindMethod(GIInterfaceInfo* info, gchar* name);
	[LinkName("g_interface_info_get_n_signals")] public static extern gint GetNSignals(GIInterfaceInfo* info);
	[LinkName("g_interface_info_get_signal")] public static extern GISignalInfo* GetSignal(GIInterfaceInfo* info, gint n);
	[LinkName("g_interface_info_find_signal")] public static extern GISignalInfo* FindSignal(GIInterfaceInfo* info, gchar* name);
	[LinkName("g_interface_info_get_n_vfuncs")] public static extern gint GetNVfuncs(GIInterfaceInfo* info);
	[LinkName("g_interface_info_get_vfunc")] public static extern GIVFuncInfo* GetVfunc(GIInterfaceInfo* info, gint n);
	[LinkName("g_interface_info_find_vfunc")] public static extern GIVFuncInfo* FindVfunc(GIInterfaceInfo* info, gchar* name);
	[LinkName("g_interface_info_get_n_constants")] public static extern gint GetNConstants(GIInterfaceInfo* info);
	[LinkName("g_interface_info_get_constant")] public static extern GIConstantInfo* GetConstant(GIInterfaceInfo* info, gint n);
	[LinkName("g_interface_info_get_iface_struct")] public static extern GIStructInfo* GetIfaceStruct(GIInterfaceInfo* info);
}

/** GIObjectInfoRefFunction: (skip)
 *   @object : object instance pointer
 *  
 *  Increases the reference count of an object instance.
 *  
 *  Returns: (transfer full): the object instance
 */
function void* GIObjectInfoRefFunction(void* object);

/** GIObjectInfoUnrefFunction: (skip)
 *   @object : object instance pointer
 *  
 *  Decreases the reference count of an object instance.
 */
function void GIObjectInfoUnrefFunction(void* object);

/** GIObjectInfoSetValueFunction: (skip)
 *   @value : a #GValue
 *   @object : object instance pointer
 *  
 *  Update @value and attach the object instance pointer @object to it.
 */
function void GIObjectInfoSetValueFunction(GValue* value, void* object);

/** GIObjectInfoGetValueFunction: (skip)
 *   @value : a #GValue
 *  
 *  Extract an object instance out of @value
 *  
 *  Returns: (transfer full): the object instance
 */
function void* GIObjectInfoGetValueFunction(GValue* value);

extension GIObjectInfo
{
	[LinkName("g_object_info_get_type_name")] public static extern gchar* GetTypeName(GIObjectInfo* info);
	[LinkName("g_object_info_get_type_init")] public static extern gchar* GetTypeInit(GIObjectInfo* info);
	[LinkName("g_object_info_get_abstract")] public static extern gboolean GetAbstract(GIObjectInfo* info);
	[LinkName("g_object_info_get_final")] public static extern gboolean GetFinal(GIObjectInfo* info);
	[LinkName("g_object_info_get_fundamental")] public static extern gboolean GetFundamental(GIObjectInfo* info);
	[LinkName("g_object_info_get_parent")] public static extern GIObjectInfo* GetParent(GIObjectInfo* info);
	[LinkName("g_object_info_get_n_interfaces")] public static extern gint GetNInterfaces(GIObjectInfo* info);
	[LinkName("g_object_info_get_interface")] public static extern GIInterfaceInfo* GetInterface(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_get_n_fields")] public static extern gint GetNFields(GIObjectInfo* info);
	[LinkName("g_object_info_get_field")] public static extern GIFieldInfo* GetField(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_get_n_properties")] public static extern gint GetNProperties(GIObjectInfo* info);
	[LinkName("g_object_info_get_property")] public static extern GIPropertyInfo* GetProperty(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_get_n_methods")] public static extern gint GetNMethods(GIObjectInfo* info);
	[LinkName("g_object_info_get_method")] public static extern GIFunctionInfo* GetMethod(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_find_method")] public static extern GIFunctionInfo* FindMethod(GIObjectInfo* info, gchar* name);
	[LinkName("g_object_info_find_method_using_interfaces")] public static extern GIFunctionInfo* FindMethodUsingInterfaces(GIObjectInfo* info, gchar* name, GIObjectInfo** implementor);
	[LinkName("g_object_info_get_n_signals")] public static extern gint GetNSignals(GIObjectInfo* info);
	[LinkName("g_object_info_get_signal")] public static extern GISignalInfo* GetSignal(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_find_signal")] public static extern GISignalInfo* FindSignal(GIObjectInfo* info, gchar* name);
	[LinkName("g_object_info_get_n_vfuncs")] public static extern gint GetNVfuncs(GIObjectInfo* info);
	[LinkName("g_object_info_get_vfunc")] public static extern GIVFuncInfo* GetVfunc(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_find_vfunc")] public static extern GIVFuncInfo* FindVfunc(GIObjectInfo* info, gchar* name);
	[LinkName("g_object_info_find_vfunc_using_interfaces")] public static extern GIVFuncInfo* FindVfuncUsingInterfaces(GIObjectInfo* info, gchar* name, GIObjectInfo** implementor);
	[LinkName("g_object_info_get_n_constants")] public static extern gint GetNConstants(GIObjectInfo* info);
	[LinkName("g_object_info_get_constant")] public static extern GIConstantInfo* GetConstant(GIObjectInfo* info, gint n);
	[LinkName("g_object_info_get_class_struct")] public static extern GIStructInfo* GetClassStruct(GIObjectInfo* info);
	[LinkName("g_object_info_get_ref_function")] public static extern c_char* GetRefFunction(GIObjectInfo* info);
	[LinkName("g_object_info_get_ref_function_pointer")] public static extern GIObjectInfoRefFunction GetRefFunctionPointer(GIObjectInfo* info);
	[LinkName("g_object_info_get_unref_function")] public static extern c_char* GetUnrefFunction(GIObjectInfo* info);
	[LinkName("g_object_info_get_unref_function_pointer")] public static extern GIObjectInfoUnrefFunction GetUnrefFunctionPointer(GIObjectInfo* info);
	[LinkName("g_object_info_get_set_value_function")] public static extern c_char* GetSetValueFunction(GIObjectInfo* info);
	[LinkName("g_object_info_get_set_value_function_pointer")] public static extern GIObjectInfoSetValueFunction GetSetValueFunctionPointer(GIObjectInfo* info);
	[LinkName("g_object_info_get_get_value_function")] public static extern c_char* GetGetValueFunction(GIObjectInfo* info);
	[LinkName("g_object_info_get_get_value_function_pointer")] public static extern GIObjectInfoGetValueFunction GetGetValueFunctionPointer(GIObjectInfo* info);
}

extension GIPropertyInfo
{
	[LinkName("g_property_info_get_flags")] public static extern GParamFlags GetFlags(GIPropertyInfo* info);
	[LinkName("g_property_info_get_type")] public static extern GITypeInfo* GetType(GIPropertyInfo* info);
	[LinkName("g_property_info_get_ownership_transfer")] public static extern GITransfer GetOwnershipTransfer(GIPropertyInfo* info);
	[LinkName("g_property_info_get_setter")] public static extern GIFunctionInfo* GetSetter(GIPropertyInfo* info);
	[LinkName("g_property_info_get_getter")] public static extern GIFunctionInfo* GetGetter(GIPropertyInfo* info);
}

extension GIRegisteredTypeInfo
{
	[LinkName("g_registered_type_info_get_type_name")] public static extern gchar* GetTypeName(GIRegisteredTypeInfo* info);
	[LinkName("g_registered_type_info_get_type_init")] public static extern gchar* GetTypeInit(GIRegisteredTypeInfo* info);
	[LinkName("g_registered_type_info_get_g_type")] public static extern GType GetGType(GIRegisteredTypeInfo* info);
}

extension GISignalInfo
{
	[LinkName("g_signal_info_get_flags")] public static extern GSignalFlags GetFlags(GISignalInfo* info);
	[LinkName("g_signal_info_get_class_closure")] public static extern GIVFuncInfo* GetClassClosure(GISignalInfo* info);
	[LinkName("g_signal_info_true_stops_emit")] public static extern gboolean TrueStopsEmit(GISignalInfo* info);
}

extension GIStructInfo
{
	[LinkName("g_struct_info_get_n_fields")] public static extern gint GetNFields(GIStructInfo* info);
	[LinkName("g_struct_info_get_field")] public static extern GIFieldInfo* GetField(GIStructInfo* info, gint n);
	[LinkName("g_struct_info_find_field")] public static extern GIFieldInfo* FindField(GIStructInfo* info, gchar* name);
	[LinkName("g_struct_info_get_n_methods")] public static extern gint GetNMethods(GIStructInfo* info);
	[LinkName("g_struct_info_get_method")] public static extern GIFunctionInfo* GetMethod(GIStructInfo* info, gint n);
	[LinkName("g_struct_info_find_method")] public static extern GIFunctionInfo* FindMethod(GIStructInfo* info, gchar* name);
	[LinkName("g_struct_info_get_size")] public static extern gsize GetSize(GIStructInfo* info);
	[LinkName("g_struct_info_get_alignment")] public static extern gsize GetAlignment(GIStructInfo* info);
	[LinkName("g_struct_info_is_gtype_struct")] public static extern gboolean IsGtypeStruct(GIStructInfo* info);
	[LinkName("g_struct_info_is_foreign")] public static extern gboolean IsForeign(GIStructInfo* info);
	[LinkName("g_struct_info_get_copy_function")] public static extern c_char* GetCopyFunction(GIStructInfo* info);
	[LinkName("g_struct_info_get_free_function")] public static extern c_char* GetFreeFunction(GIStructInfo* info);
}

extension GIR
{
	[LinkName("g_type_tag_to_string")] public static extern gchar* TypeTagToString(GITypeTag type);
	[LinkName("g_info_type_to_string")] public static extern gchar* InfoTypeToString(GIInfoType type);
}

extension GITypeInfo
{
	[LinkName("g_type_info_is_pointer")] public static extern gboolean IsPointer(GITypeInfo* info);
	[LinkName("g_type_info_get_tag")] public static extern GITypeTag GetTag(GITypeInfo* info);
	[LinkName("g_type_info_get_param_type")] public static extern GITypeInfo* GetParamType(GITypeInfo* info, gint n);
	[LinkName("g_type_info_get_interface")] public static extern GIBaseInfo* GetInterface(GITypeInfo* info);
	[LinkName("g_type_info_get_array_length")] public static extern gint GetArrayLength(GITypeInfo* info);
	[LinkName("g_type_info_get_array_fixed_size")] public static extern gint GetArrayFixedSize(GITypeInfo* info);
	[LinkName("g_type_info_is_zero_terminated")] public static extern gboolean IsZeroTerminated(GITypeInfo* info);
	[LinkName("g_type_info_get_array_type")] public static extern GIArrayType GetArrayType(GITypeInfo* info);
	[LinkName("g_type_info_get_storage_type")] public static extern GITypeTag GetStorageType(GITypeInfo* info);
	[LinkName("g_type_info_argument_from_hash_pointer")] public static extern void ArgumentFromHashPointer(GITypeInfo* info, gpointer hash_pointer, GIArgument* arg);
	[LinkName("g_type_info_hash_pointer_from_argument")] public static extern gpointer HashPointerFromArgument(GITypeInfo* info, GIArgument* arg);
}

extension GIR
{
	[LinkName("gi_type_tag_argument_from_hash_pointer")] public static extern void iTypeTagArgumentFromHashPointer(GITypeTag storage_type, gpointer hash_pointer, GIArgument* arg);
	[LinkName("gi_type_tag_hash_pointer_from_argument")] public static extern gpointer iTypeTagHashPointerFromArgument(GITypeTag storage_type, GIArgument* arg);
}

extension GIUnionInfo
{
	[LinkName("g_union_info_get_n_fields")] public static extern gint GetNFields(GIUnionInfo* info);
	[LinkName("g_union_info_get_field")] public static extern GIFieldInfo* GetField(GIUnionInfo* info, gint n);
	[LinkName("g_union_info_get_n_methods")] public static extern gint GetNMethods(GIUnionInfo* info);
	[LinkName("g_union_info_get_method")] public static extern GIFunctionInfo* GetMethod(GIUnionInfo* info, gint n);
	[LinkName("g_union_info_is_discriminated")] public static extern gboolean IsDiscriminated(GIUnionInfo* info);
	[LinkName("g_union_info_get_discriminator_offset")] public static extern gint GetDiscriminatorOffset(GIUnionInfo* info);
	[LinkName("g_union_info_get_discriminator_type")] public static extern GITypeInfo* GetDiscriminatorType(GIUnionInfo* info);
	[LinkName("g_union_info_get_discriminator")] public static extern GIConstantInfo* GetDiscriminator(GIUnionInfo* info, gint n);
	[LinkName("g_union_info_find_method")] public static extern GIFunctionInfo* FindMethod(GIUnionInfo* info, gchar* name);
	[LinkName("g_union_info_get_size")] public static extern gsize GetSize(GIUnionInfo* info);
	[LinkName("g_union_info_get_alignment")] public static extern gsize GetAlignment(GIUnionInfo* info);
	[LinkName("g_union_info_get_copy_function")] public static extern c_char* GetCopyFunction(GIUnionInfo* info);
	[LinkName("g_union_info_get_free_function")] public static extern c_char* GetFreeFunction(GIUnionInfo* info);
}

extension GIVFuncInfo
{
	[LinkName("g_vfunc_info_get_flags")] public static extern GIVFuncInfoFlags GetFlags(GIVFuncInfo* info);
	[LinkName("g_vfunc_info_get_offset")] public static extern gint GetOffset(GIVFuncInfo* info);
	[LinkName("g_vfunc_info_get_signal")] public static extern GISignalInfo* GetSignal(GIVFuncInfo* info);
	[LinkName("g_vfunc_info_get_invoker")] public static extern GIFunctionInfo* GetInvoker(GIVFuncInfo* info);
	[LinkName("g_vfunc_info_get_address")] public static extern gpointer GetAddress(GIVFuncInfo* info, GType implementor_gtype, GError** error);
	[LinkName("g_vfunc_info_invoke")] public static extern gboolean Invoke(GIVFuncInfo* info, GType implementor, GIArgument* in_args, c_int n_in_args, GIArgument* out_args, c_int n_out_args, GIArgument* return_value, GError** error);
}

extension GIR
{
	[LinkName("gi_get_major_version")] public static extern guint iGetMajorVersion();
	[LinkName("gi_get_minor_version")] public static extern guint iGetMinorVersion();
	[LinkName("gi_get_micro_version")] public static extern guint iGetMicroVersion();
}

struct GIRepository;

struct GIRepositoryClass;

struct GIRepositoryPrivate;

/** GIRepositoryLoadFlags:
 *   @G _IREPOSITORY_LOAD_FLAG_LAZY: Lazily load the typelib.
 *  
 *  Flags that control how a typelib is loaded.
 */
[AllowDuplicates] enum GIRepositoryLoadFlags : c_int
{
	Lazy = 1 << 0,
}

extension GIRepository
{
	[LinkName("g_irepository_get_type")] public static extern GType GetType();
	[LinkName("g_irepository_get_default")] public static extern GIRepository* GetDefault();
	[LinkName("g_irepository_prepend_search_path")] public static extern void PrependSearchPath(c_char* directory);
	[LinkName("g_irepository_prepend_library_path")] public static extern void PrependLibraryPath(c_char* directory);
	[LinkName("g_irepository_get_search_path")] public static extern GSList* GetSearchPath();
	[LinkName("g_irepository_load_typelib")] public static extern c_char* LoadTypelib(GIRepository* repository, GITypelib* typelib, GIRepositoryLoadFlags flags, GError** error);
	[LinkName("g_irepository_is_registered")] public static extern gboolean IsRegistered(GIRepository* repository, gchar* @namespace, gchar* version);
	[LinkName("g_irepository_find_by_name")] public static extern GIBaseInfo* FindByName(GIRepository* repository, gchar* @namespace, gchar* name);
	[LinkName("g_irepository_enumerate_versions")] public static extern GList* EnumerateVersions(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_require")] public static extern GITypelib* Require(GIRepository* repository, gchar* @namespace, gchar* version, GIRepositoryLoadFlags flags, GError** error);
	[LinkName("g_irepository_require_private")] public static extern GITypelib* RequirePrivate(GIRepository* repository, gchar* typelib_dir, gchar* @namespace, gchar* version, GIRepositoryLoadFlags flags, GError** error);
	[LinkName("g_irepository_get_immediate_dependencies")] public static extern gchar** GetImmediateDependencies(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_dependencies")] public static extern gchar** GetDependencies(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_loaded_namespaces")] public static extern gchar** GetLoadedNamespaces(GIRepository* repository);
	[LinkName("g_irepository_find_by_gtype")] public static extern GIBaseInfo* FindByGtype(GIRepository* repository, GType gtype);
	[LinkName("g_irepository_get_object_gtype_interfaces")] public static extern void GetObjectGtypeInterfaces(GIRepository* repository, GType gtype, guint* n_interfaces_out, GIInterfaceInfo*** interfaces_out);
	[LinkName("g_irepository_get_n_infos")] public static extern gint GetNInfos(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_info")] public static extern GIBaseInfo* GetInfo(GIRepository* repository, gchar* @namespace, gint index);
	[LinkName("g_irepository_find_by_error_domain")] public static extern GIEnumInfo* FindByErrorDomain(GIRepository* repository, GQuark domain);
	[LinkName("g_irepository_get_typelib_path")] public static extern gchar* GetTypelibPath(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_shared_library")] public static extern gchar* GetSharedLibrary(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_c_prefix")] public static extern gchar* GetCPrefix(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_version")] public static extern gchar* GetVersion(GIRepository* repository, gchar* @namespace);
	[LinkName("g_irepository_get_option_group")] public static extern GOptionGroup* GetOptionGroup();
	[LinkName("g_irepository_dump")] public static extern gboolean Dump(c_char* arg, GError** error);
}

/** GIRepositoryError:
 *   @G _IREPOSITORY_ERROR_TYPELIB_NOT_FOUND: the typelib could not be found.
 *   @G _IREPOSITORY_ERROR_NAMESPACE_MISMATCH: the namespace does not match the
 *  requested namespace.
 *   @G _IREPOSITORY_ERROR_NAMESPACE_VERSION_CONFLICT: the version of the
 *  typelib does not match the requested version.
 *   @G _IREPOSITORY_ERROR_LIBRARY_NOT_FOUND: the library used by the typelib
 *  could not be found.
 *  
 *  An error code used with #G_IREPOSITORY_ERROR in a #GError returned
 *  from a #GIRepository routine.
 */
[AllowDuplicates] enum GIRepositoryError : c_int
{
	TypelibNotFound = 0,
	NamespaceMismatch = 1,
	NamespaceVersionConflict = 2,
	LibraryNotFound = 3,
}

extension GIRepository
{
	[LinkName("g_irepository_error_quark")] public static extern GQuark ErrorQuark();
}

extension GIR
{
	[LinkName("gi_cclosure_marshal_generic")] public static extern void iCclosureMarshalGeneric(GClosure* closure, GValue* return_gvalue, guint n_param_values, GValue* param_values, gpointer invocation_hint, gpointer marshal_data);
}

